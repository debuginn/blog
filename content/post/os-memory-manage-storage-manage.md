---
title: "操作系统 内存管理 内存存储管理方案"
date: 2017-12-26T22:03:37+08:00
keywords: "os,introduction"
comments: true
tags: ["os", "system"]
categories: ["OS"]
image: "https://webp.debuginn.com/202302221853276.jpg"
---

> 基本思想：是把内存划分成若干个连续的区域，称为分区，每个分区装入一个运行程序。

## 固定分区

### 基本思想

固定分区是指系统先把内存划分为若干个大小固定的分区，一旦分配好，在系统运行期间便不再重新划分。程序运行时必须提供对内存资源的最大申请量。

### 内存分配表与分区的分配、回收

用于固定分区管理的内存分配表是一张分区说明表，按顺序每个分区说明表中对应一个表目。表目内容包括分区序号、分区大小、分区起始地址以及使用状态（空闲或占用）。一个程序在运行时，想要根据其对内存的需求量，按一定的分配策略在分区说明表中查找空闲分区。若找到合乎需要的分区，就将该分区分配给程序，并将该分区置为占用状态。当程序完成时释放这块分区内存，由系统回收，并在分区说明表中间回收的分区重新置为空闲状态。

![内存分配表](https://webp.debuginn.com/202304132205430.png)

固定分区方案灵活性差，可接纳程序的大小受到了分区大小的严格限制。

## 可变分区

### 基本思想

可变分区是指系统不预先划分固定分区，而是在装入程序时划分内存分区，使为程序分配的分区的大小正好等于该程序的需求量，且分区的个数是可变的。可变分区有较大的灵活性，较之固定分区能更好的内存利用率。

系统初次启动后，在内存中出操作系统区之外，其余空间为一个完整的大空闲区，当有程序要求装入内存运行时，系统从该空闲区中划分出一块与程序大小相同的区域进行分配。当系统运行一段时间后，随一系列的内存分配与回收，原来的一整块大空闲区形成了若干占用区和空闲区相间的布局，若有上下相邻的两块空闲区，系统应将他们合并成为一块连续的大空闲区。

![可变分区](https://webp.debuginn.com/202304132206895.png)

### 移动技术

内存经过一段时间的分配回收之后们会存在很多晓得空闲块。它们每一块都不足以满足程序进一步分配内存的要求，但其总和却可以满足程序的分配要求，这些空闲块称之为碎片。

解决碎片的办法：在适当时刻进行碎片整理，通过移动内存中的程序，把所有空闲碎片合成一个连续的大空闲区且放在内存的一端，而把所有程序占用区放在内存的另一端，称为“移动技术”或“紧凑技术”或“紧缩技术”。

提高内存的利用率，便于作业动态扩充内存。采用移动技术需要注意以下问题：

1. 移动技术会增加系统的开销。增大了系统运行时间。 
2. 移动是由条件的，不是任何在内存中的作业都能随时移动。

采用移动技术是应该尽可能减少需要移动的作业数和信息量。

![移动技术](https://webp.debuginn.com/202304132207002.png)

### 可变分区的实现

采用可变分区方式管理时，要有硬件的地址转换机构作为支持。硬件设置两个专用的控制寄存器：基址寄存器和限长寄存器。

- 基址寄存器用来存放程序所占用分区的起始地址。 
- 限长寄存器用来存放程序所占分区的长度。

但程序被装到所分配的分区后，把分区的起始地址和长度作为现场信息存入该作业进程的进程控制块中。

![akb](https://webp.debuginn.com/202304132207613.png)

为了实现可变分区的管理，必须设置某种数据结构用以记录内存分配的情况，确定某种分配策略并且实施内存的分配与回收。

内存分配表由两张表格组成：

- 已分配区表：记录已装入的程序在内存中占用分区的起始地址和长度，用标志位指出占用分区的程序名。 
- 空闲区表：记录内存中可供分配的空闲区的起始地址和长度，用标志位指出该分区是未分配的空闲区。

![空闲区表](https://webp.debuginn.com/202304132208287.png)

### 空闲分区的分配策略

#### 最先适应算法

最先适应算法，又称顺序分配算法，当接到内存申请是，顺序查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配，可以快速做出分配决定。

![最先适应算法](https://webp.debuginn.com/202304132209930.png)

#### 最优适应算法

当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其分割并分配。

- 优点：最节约空间，因为它尽量不分割大的空闲区。
- 缺点：可能会形成很多很小的空闲区域，称为碎片。

#### 最坏适应算法

当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。

基本思想：在大空闲区中装入信息后，分割剩下的空闲区相对也很大，还能用于装入其他程序。

优点：是可以避免形成碎片。

缺点：分割了大的空闲区后，如果在遇到较大的程序申请内存时，无法满足要求的可能性越大。

#### 下次适应算法

当接到内存申请时，查找分区说明表，从上一次分配的位置开始扫描内存，选择下一个大小足够的可用块。

### 分区的回收

当用户程序执行接受后，系统要回收已经使用完毕的分区，将其记录在空闲区表中。在回收空间时，应首先检查是否有与回收区相邻的空闲区，即检查相邻的空闲区表中标志为“未分配”的栏目，以确定是否有相邻空闲区，若有，则应合并成一个空闲区登记。

假定作业归还的分区起始地址为S，长度为L。

**（1）回收区的上邻分区是空闲的，需要将两个空闲区合并成一个更大的空闲区，然后修改空闲区表。**

如果空闲区表中第i个登记栏中的“起始地址+长度”正好等于S，则说明回收区有一个上邻空闲区。

长度 = 原长度 + L

![长度](https://webp.debuginn.com/202304132219133.png)

**2）回收分区的下邻分区是空闲的，需要将两个空闲区合并成一个更大的空闲区，然后修改空闲区表。**

如果S+L正好等于空闲区表中某个登记的栏目（假定为第i栏）所示分区的起始地址表明回收区有一个下邻空闲区。

起始地址 = S

长度 = 原长度 + L

第i栏指示的空闲区是回收区与下邻空闲区合并之后的一个大空闲区。

**（3）回收区的上邻分区和下邻分区都是空闲的，需要将三个空闲区合并成一个更大的空闲区，然后修改空闲区表。**

S = 第i栏起始地址 + 长度
S + L = 第k栏起始地址

表明回收区既有上邻空闲区，又有下邻空闲区。必须把这三个区合并为一个空闲区。

- 第i栏起始地址不变。 
- 第i蓝长度为“i栏中原长度+k栏中长度+L”。 
- 第k栏目的标志应修改为“空”状态。

**（4）回收分区的上邻分区和下邻分区都不是空闲的，则直接将空闲分区记录在空闲区表中。**

应找一个标志为“空”的登记栏，把回收区的起始地址和长度登记入表，且把该栏目中的标志位修改成“未分配”，表示该登记栏中指示了一个空闲区。

### 分区的保护

（1）系统设置界限寄存器，界限寄存器是可以上下界寄存器或基址、限长寄存器。

![系统设置界限寄存器](https://webp.debuginn.com/202304132221699.png)

（2）保护键发：即为每个分区分配一个保护键，相当于一把锁。同时为每个进程分配一个相应的保护键，相当于一把钥匙，存放在程序状态字中。美方访问内存时，都要检查钥匙和锁是否匹配，若不匹配，将发出保护性中断。

### 分区管理方案的优缺点           

优点：分区管理是实现多道程序设计中一种简单易行的存储管理技术。通过分区管理，内存真正成了共享资源，有效地利用了处理机和I/O设备，从而提高了系统的吞吐量和缩短了周转时间。在内存利用率方面，可变分区的内存利用率比固定分区高。

缺点：内存使用不充分，并且存在较为严重的碎片问题，虽然可以解决碎片问题，但需要移动大量信息，浪费了处理机时间。收到物理存储器实际存储容量的限制。
