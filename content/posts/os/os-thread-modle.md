---
title: "操作系统 进程线程模型 线程模型"
date: 2017-12-10T22:57:38+08:00
draft: false
author: "Meng小羽"
authorLink: "https://www.debuginn.cn"
authorEmail: "debuginn@icloud.com"
keywords: "os,introduction"
comment: true
weight: 0

tags: ["os", "system"]
categories: ["os"]

hiddenFromHomePage: false
hiddenFromSearch: false

featuredImage: "https://image.debuginn.cn/202302221853276.jpg"
featuredImagePreview: "https://image.debuginn.cn/202302221853276.jpg"
---

## 线程模型

**线程**：能够独立运行的基本单位，试图用它来提高系统内程序并发执行的程度。

### 线程的引入

**基本属性**：进程是一个可拥有资源的独立单位，又是一个可以独立调度和分派的基本单位。

1. 创建进程：必须为其分配所有资源（除CPU外），包括内存空间、I/O设备以及建立相应的数据结构PCB。 
2. 撤销进程：必须先对这些资源进行回收操作，然后在撤销PCB。 
3. 进程切换：由于要保留当前进程的CPU环境和设置新选中进程的CPU环境，为此需要花费不少的CPU时间。

进程是一个资源拥有者，因而在进程的创建、撤销和切换中，系统必须为之付出较大的时空开销。

创建背景：如果将作为调度和分派的经本单位不同时作为独立分配资源的单位，以使轻快运行；而对拥有资源的基本单位，又不频繁地对之进行切换。

### 线程的基本概念

线程是进程中的一个实体，是CPU调度和分派的基本单位。

一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。

线程也同样有就绪、等待和运行三种基本状态。

### 线程的属性

- 每一个线程有一个唯一的标识符和一张线程描述表，记录了线程执行的寄存器和栈等现场状态。 
- 不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时操作系统为它创建不同的线程。 
- 同一个进程中的各个线程共享进程的内存地址空间。 
- 线程是处理器的独立调度单位，多个线程是可以并发执行的，在单个CPU的计算机系统中，各个线程可交替的占用CPU；在多个CPU计算机系统中，各个线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各种线程服务是可以缩短进程的处理时间。 
- 一个线程被创建后便开始了它的生命周期，直至终止，县城在生命周期内会经历等待、就绪和运行等各种状态变化。

### 引入线程的好处

- 创建一个新的进程花费的时间少，不需另行分配资源，创建线程的速度比创建进程的速度快，且系统的开销也少。 
- 两个线程的切换花费时间少。 
- 由于同一个进程内的线程共享内存和文件，线程之间相互通信无须调用内核。 
- 线程能独立运行，能充分利用和发挥处理器与外围设备并行工作能力。

### 线程与进程的比较

线程具有许多传统进程所具有的特征，故又称为轻量级进程或者是进程元，把床听的进程称为重量级进程。

1. 调度：在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。而在引入县城的操作系统中，则把线程作为调度和分派的基本单位。同一进程中，线程切换不会引起进程切换；而在由一个进程中的线程切换到另一个进程中的线程时，将会引起进程切换。 
2. 并发性：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行。很有效的使用系统资源和提高系统的吞吐量。 
3. 拥有资源：线程的自己不拥有系统资源，但它可以访问其隶属进程的资源，可供同一进程的其他所有线程共享。 
4. 系统开销：由于在创建或撤销进程时，系统都要为之分配或回收资源。因此，操作系统所付出的开销将显著地大于在创建或撤销线程时的开销。

## 线程实现机制

### 用户级线程

用户级线程不依赖于内核。用户级线程只存在于用户态中，对它的创建、撤销和切换不会通过系统调用来实现，因而这种线程与内核无关。内核也并不知道有用户级线程的存在，从内核角度考虑，就是按正常的方式管理即单线程进程。

支持用户级进程的典型操作系统就是Linux。

在用户空间管理线程时，每个进程都需要有其专用的线程表。用来跟踪该进程中的线程。该线程表由运行时系统管理。但一个线程转换到就绪状态或阻塞状态时，在该进程表中存放着从新启动该线程所需要的信息，于内核在进程表中存放进程的信息完全一样。

### 内核级线程

内核级线程依赖于内核，无论是在用户进程中的线程，还是系统进程中的线程，他们的创建、撤销和切换都是有内核实现的。在内核中保留一个线程控制块，系统根据该控制块而感知该线程的存在并对县城进行控制。

支持内核级线程的典型操作系统是Windows。

内核的线程表保存了每个线程的仅存表、状态和其他信息。所以能够阻塞线程的表用都以系统调用的形式实现。当一个线程阻塞时，内核可以选择运行的同一个进程中的另一个线程（若有一个就绪进程）或者运行另一个进程中的线程。而在用户及线程中，运行时系统时钟运行自己进程中的线程，直到内核剥夺它的CPU（或者没有可运行的线程存在了）为止。

**用户级线程和内核级线程比较**

1. 线程的调度与切换速度：核心级线程的调度与切换与进程的调度和切换十分相似。在线程调度时的调度方式，同样也是采用抢占方式和非抢占方式两种。在线程的调度算法上，也同样可采用时间片轮转法、优先权算法等。用户级线程的切换通常是发生在一个应用进程的诸线程之间，这时，不仅无需同福哦终端进入操作系统的内核，而且切换的规则页远比进程调度和切换的规则简单。用户级线程的切换速度特别快。 
2. 系统调用：在传统的用户进程调用一个西戎调用时，要由用户状态转入核心状态，用户进程将被封锁。当那个完成系统调用而返回时，才将该进程唤醒，继续执行，而在用户级线程调用一个系统调用时，由于内核并不知道有该用户级进程的存在，因而把西戎调用看作是整个进程的行为，于是使该进程等待，而调度另一个进程执行。当一个进程调用一个系统调用时，内核把系统调用只看作是该线程的行为，以问封锁该进程中的其他线程执行。 
3. 线程执行时间：对于只设置了用户级线程的系统，调度是以进程为单位进行的。

### 混合实现方式

支持混合方式线程的典型操作系统是Solaris。

### Pthread线程包

IEEE标准1003.1c定义了线程标准，Pthread是基于该标准实现的线程包。