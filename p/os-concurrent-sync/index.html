<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="进程（线程）间相互作用 相关进程与无关进程 相关进程：在逻辑上具有某种联系的进程。\n无关进程：在逻辑上没有任何联系的进程。\n如果一个进程的执行不影响其他进程的执行，且与其他进程的进展情况无关，即它们是各自独立的，则说这些并发进程的相互之间是无关的。无关的并发进程一定没有共享的变量。\n如果一个进程的执行依赖其他进程的进展情况，或者说，一个进程的执行可能影响其他进程的执行结果，则说这些并发进程是相关的。\n与时间有关的错误 京城执行的速度是不能由进程自身控制的。对于相关进程来说，可能有若干并发进程同时使用共享资源，即一个进程一次使用未结束，另一个进程也开始使用，形成交替使用共享资源。\n进程同步：值多个进程中发生的事件存在某种时序关系，必须协同动作，相互配合，以共同完成一个任务。\n进程互斥：指由于共享资源所要求的排他性，进程间要相互竞争以使用这些互斥资源。\n进程互斥 解决进程互斥的两种方法：\n由竞争各方平等协商。 引入进程管理者，有管理者来协调竞争各方对互斥资源的使用。 临界资源：计算机系统中的需要互斥使用的硬件或软件资源，如外设、共享代码块、共享数据结构等。对各进程在对临界资源进程进行访问时，特别是进行写入或修改操作时，必须互斥的运行。\n计算机系统中资源共享的程度分为三个层次：互斥、死锁和饥饿。\n互斥：保证资源的互斥使用是指多个进程不能同时使用同一个资源，这是正确使用资源的最基本要求。\n死锁：避免死锁是指多个进程互不相让，避免出现都得不到足够资源的情况，从而保证系统功能的正常运行。\n饥饿：避免饥饿是指避免某些进程一直得不到资源或者得到资源的概率很小，从而保障系统内资源使用的公平性。\n为了保证临界资源的正确使用，可把临界资源的访问过程分为四个部分：\n进入区：为了进入临界区使用临界值资源，在进入区要检查可否进入临界区；如果可以进入临界区，通常设置相应的”正在访问临界区“标志，以阻止其他进程同时进入临界区。 临界区：进程中访问临界资源的一段代码。 退出区：将”正在访问临界区“标识清除。 剩余区：代码中的其他部分。 为了合理使用计算机系系统中的资源，在操作系统中采用的进程同步机制应遵循以下几条：\n空闲则入：任何同步机制都必须保证任何时间嗯最多只有一个进程位于临界区。当有程序位于临界区时，任何其他进程均不能进入临界区。 忙着等待：当以有进程处于其他临界区时，后到达的进程只能在进入区等待。 有限等待：为了避免死锁等现象的出现，等待进入临界区的进程不能无期限的”死等“。 让权等待：因在进入区等待而不能进入临界区的进程，应释放处理机，转换到阻塞状态以使得其他进程有机会得到处理机的使用权。 进程互斥的软件方法 算法1：单标志算法 假设有两个进程Pi和Pj，设立一个公用整理变量turn，描述允许进入临界区的进程标识。每个进程都在进入区循环检查变量turn是否允许本进程进入。即turn为i时，进程Pi可进入，否则循环检查该变量，直到turn为本进程标识，在退出区修改允许进入进程标识，即进程Pi退出时，Pj的标识为j。\n可以保证任何时刻最多只有一个进程在临界区。\n缺点：强制轮流进入临界区，没有考虑进程的实际需要，容易造成资源利用不充分。\n算法2：双标志、先检查算法 修改临界区标志的设置，设立一个标志数组flag[]，描述各进程是否在临界区，初始值均为FALSE.\n在进入区的操作为：先检查，后修改。即在进入区像检查另一个进程是否在临界区，不在时修改本进程在临界区的标志，表示本进程在临界区，在退出区修改本进程在临界区的标志，表示本进程不在临界区。\n算法2的优点是克服了算法1的缺点，两个进程不用交替进入，可连续使用。但由于使用多个标志，算法有产生新的问题，即进程Pi和Pj可能同时进入临界区，从而违反了最左只有多个进程在临界区的要求。\n算法3：双标志、后检查算法 一是保证检查和修改操作间不会出现间隔。 一是修改标志含义。 算法3可防止两个进程同时进入临界区，但它的缺点是Pi和Pj可能都进入不了临界区。在修改本进程标志flag之后和检查对方flag之间有一段时间间隔，这个间隔导致两个进程都想进入临界区，从而在检查对方标志时不通过。\n算法4：先修改、后检查、后修改者等待算法 结合了算法3和1，标志flag[i]表示进程i想进入临界区，标志turn表示同时修改标志时要在进入区等待的进程标识。\n在进入区先修改后检查，通过修改统一标志turn来描述标志修改的先后；检查对方标志flag，如果对方不想进入临界区则自己进入；否则在检查标志turn，由于标志turn中保存的是较晚的一次赋值，则交往修改标志的进程等待，较早的修改标志的进程进入临界区。\n实现了同步机制要求的四条准则中的前两条：空闲则入、忙着等待。\n进程互斥的硬件方法 主要思路：使用一种指令完成读和写的两个操作，因而保证读操作与写操作不被打断，依据采用的指令的不同，硬件方法分成TS指令和Swap指令。\nTS（Test-and-Set）指令 TS指令的功能是读出指定标识后把该标志设置为TRUE。\n每个临界资源设置一个公共布尔变量lock，表示资源两种状态：TURE表示正被占用，FALSE表示空闲，初始值为FALSE。\n有进程在临界区时，重复检查，直到其他进程退出时检查通过，所有要访问临界资源的进程的进入区和退出区代码是相同的。\nSwap指令 利用Swap指令实现的进程互斥算法是，每个临界资源设置一个公共布尔变量lock，初值为FALSE，每个进程设置一个私有布尔变量key，用于与lock间的信息交换。在进入区利用Swap指令交换lock和key的内容，然后检查key的状态，有进程在临界区时，重复交换和检查过程到其他进程推出啊是检查通过。\n优点：\n适用范围广：适用于任意数目的进程，在单处理器和多处理器黄健中完全相同。 简单：硬件方法的标志设置简单，含义明确，容易验证其正确性。 支持多个临界区：在一个进程内有多个临界区是，只需为每个临界区设立一个变量。 缺点：\n进程在等待进入临界区时，要耗费处理机时间，不能实现”让权等待“。 由于进入临界区的进程是从等待进程中随机选择的，有的进程可能一直选不上，从而导致”饥饿“。 信号量 信号量机制所使用的P、V原语就来自荷兰语test和increment。每个信号量s除一个整数值s.count（计数）外，还有一个进程等待队列s.queue，其中存放的是阻塞在该信号量的各个进程的标识。\n信号量只能通过初始化和标准的原语来访问。\nP、V原语的执行，不受进程调度和执行的打断，从而很好地解决了原语操作的整体性。信号量的初始化可指定一个非负整数数值，表示空闲资源总数；若为负值，其绝对值表示当前等待临界区的进程数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 P原语所执行的操作可用下面函数wait（s）来描述。 wait(s){ --s.count; //表示申请一个资源 if(s.count<0){ //表示没有空闲资源 调用进程进入等待队列s.queue; 阻塞调用进程; } } V原语所执行的操作可用下面函数signal(s)描述。 signal(s){ ++s.count; //表示释放一个资源 if(s.count <= 0){ //表示有进程处于阻塞状态 从等待队列s.queue中取出头一个进程P； 进程P进入就绪队列; } } 在使用信号量进行共享资源访问控制时，必须成对使用P和V原语。遗漏P原语则不能保证互斥访问，遗漏V原语则不能在使用临界资源之后将其释放给其他等待的进程。P、V原语的使用不能次序错误、重复或遗漏。\n"><meta name=keywords content="os,introduction"><title>操作系统 并发与同步</title><link rel=canonical href=https://blog.debuginn.com/p/os-concurrent-sync/><link rel=stylesheet href=/scss/style.min.4f69cd3d2cfd5559540daeb82d057bbcb347cfb39c4ffd29f3ab54f194f2b2be.css><meta property='og:title' content="操作系统 并发与同步"><meta property='og:description' content="进程（线程）间相互作用 相关进程与无关进程 相关进程：在逻辑上具有某种联系的进程。\n无关进程：在逻辑上没有任何联系的进程。\n如果一个进程的执行不影响其他进程的执行，且与其他进程的进展情况无关，即它们是各自独立的，则说这些并发进程的相互之间是无关的。无关的并发进程一定没有共享的变量。\n如果一个进程的执行依赖其他进程的进展情况，或者说，一个进程的执行可能影响其他进程的执行结果，则说这些并发进程是相关的。\n与时间有关的错误 京城执行的速度是不能由进程自身控制的。对于相关进程来说，可能有若干并发进程同时使用共享资源，即一个进程一次使用未结束，另一个进程也开始使用，形成交替使用共享资源。\n进程同步：值多个进程中发生的事件存在某种时序关系，必须协同动作，相互配合，以共同完成一个任务。\n进程互斥：指由于共享资源所要求的排他性，进程间要相互竞争以使用这些互斥资源。\n进程互斥 解决进程互斥的两种方法：\n由竞争各方平等协商。 引入进程管理者，有管理者来协调竞争各方对互斥资源的使用。 临界资源：计算机系统中的需要互斥使用的硬件或软件资源，如外设、共享代码块、共享数据结构等。对各进程在对临界资源进程进行访问时，特别是进行写入或修改操作时，必须互斥的运行。\n计算机系统中资源共享的程度分为三个层次：互斥、死锁和饥饿。\n互斥：保证资源的互斥使用是指多个进程不能同时使用同一个资源，这是正确使用资源的最基本要求。\n死锁：避免死锁是指多个进程互不相让，避免出现都得不到足够资源的情况，从而保证系统功能的正常运行。\n饥饿：避免饥饿是指避免某些进程一直得不到资源或者得到资源的概率很小，从而保障系统内资源使用的公平性。\n为了保证临界资源的正确使用，可把临界资源的访问过程分为四个部分：\n进入区：为了进入临界区使用临界值资源，在进入区要检查可否进入临界区；如果可以进入临界区，通常设置相应的”正在访问临界区“标志，以阻止其他进程同时进入临界区。 临界区：进程中访问临界资源的一段代码。 退出区：将”正在访问临界区“标识清除。 剩余区：代码中的其他部分。 为了合理使用计算机系系统中的资源，在操作系统中采用的进程同步机制应遵循以下几条：\n空闲则入：任何同步机制都必须保证任何时间嗯最多只有一个进程位于临界区。当有程序位于临界区时，任何其他进程均不能进入临界区。 忙着等待：当以有进程处于其他临界区时，后到达的进程只能在进入区等待。 有限等待：为了避免死锁等现象的出现，等待进入临界区的进程不能无期限的”死等“。 让权等待：因在进入区等待而不能进入临界区的进程，应释放处理机，转换到阻塞状态以使得其他进程有机会得到处理机的使用权。 进程互斥的软件方法 算法1：单标志算法 假设有两个进程Pi和Pj，设立一个公用整理变量turn，描述允许进入临界区的进程标识。每个进程都在进入区循环检查变量turn是否允许本进程进入。即turn为i时，进程Pi可进入，否则循环检查该变量，直到turn为本进程标识，在退出区修改允许进入进程标识，即进程Pi退出时，Pj的标识为j。\n可以保证任何时刻最多只有一个进程在临界区。\n缺点：强制轮流进入临界区，没有考虑进程的实际需要，容易造成资源利用不充分。\n算法2：双标志、先检查算法 修改临界区标志的设置，设立一个标志数组flag[]，描述各进程是否在临界区，初始值均为FALSE.\n在进入区的操作为：先检查，后修改。即在进入区像检查另一个进程是否在临界区，不在时修改本进程在临界区的标志，表示本进程在临界区，在退出区修改本进程在临界区的标志，表示本进程不在临界区。\n算法2的优点是克服了算法1的缺点，两个进程不用交替进入，可连续使用。但由于使用多个标志，算法有产生新的问题，即进程Pi和Pj可能同时进入临界区，从而违反了最左只有多个进程在临界区的要求。\n算法3：双标志、后检查算法 一是保证检查和修改操作间不会出现间隔。 一是修改标志含义。 算法3可防止两个进程同时进入临界区，但它的缺点是Pi和Pj可能都进入不了临界区。在修改本进程标志flag之后和检查对方flag之间有一段时间间隔，这个间隔导致两个进程都想进入临界区，从而在检查对方标志时不通过。\n算法4：先修改、后检查、后修改者等待算法 结合了算法3和1，标志flag[i]表示进程i想进入临界区，标志turn表示同时修改标志时要在进入区等待的进程标识。\n在进入区先修改后检查，通过修改统一标志turn来描述标志修改的先后；检查对方标志flag，如果对方不想进入临界区则自己进入；否则在检查标志turn，由于标志turn中保存的是较晚的一次赋值，则交往修改标志的进程等待，较早的修改标志的进程进入临界区。\n实现了同步机制要求的四条准则中的前两条：空闲则入、忙着等待。\n进程互斥的硬件方法 主要思路：使用一种指令完成读和写的两个操作，因而保证读操作与写操作不被打断，依据采用的指令的不同，硬件方法分成TS指令和Swap指令。\nTS（Test-and-Set）指令 TS指令的功能是读出指定标识后把该标志设置为TRUE。\n每个临界资源设置一个公共布尔变量lock，表示资源两种状态：TURE表示正被占用，FALSE表示空闲，初始值为FALSE。\n有进程在临界区时，重复检查，直到其他进程退出时检查通过，所有要访问临界资源的进程的进入区和退出区代码是相同的。\nSwap指令 利用Swap指令实现的进程互斥算法是，每个临界资源设置一个公共布尔变量lock，初值为FALSE，每个进程设置一个私有布尔变量key，用于与lock间的信息交换。在进入区利用Swap指令交换lock和key的内容，然后检查key的状态，有进程在临界区时，重复交换和检查过程到其他进程推出啊是检查通过。\n优点：\n适用范围广：适用于任意数目的进程，在单处理器和多处理器黄健中完全相同。 简单：硬件方法的标志设置简单，含义明确，容易验证其正确性。 支持多个临界区：在一个进程内有多个临界区是，只需为每个临界区设立一个变量。 缺点：\n进程在等待进入临界区时，要耗费处理机时间，不能实现”让权等待“。 由于进入临界区的进程是从等待进程中随机选择的，有的进程可能一直选不上，从而导致”饥饿“。 信号量 信号量机制所使用的P、V原语就来自荷兰语test和increment。每个信号量s除一个整数值s.count（计数）外，还有一个进程等待队列s.queue，其中存放的是阻塞在该信号量的各个进程的标识。\n信号量只能通过初始化和标准的原语来访问。\nP、V原语的执行，不受进程调度和执行的打断，从而很好地解决了原语操作的整体性。信号量的初始化可指定一个非负整数数值，表示空闲资源总数；若为负值，其绝对值表示当前等待临界区的进程数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 P原语所执行的操作可用下面函数wait（s）来描述。 wait(s){ --s.count; //表示申请一个资源 if(s.count<0){ //表示没有空闲资源 调用进程进入等待队列s.queue; 阻塞调用进程; } } V原语所执行的操作可用下面函数signal(s)描述。 signal(s){ ++s.count; //表示释放一个资源 if(s.count <= 0){ //表示有进程处于阻塞状态 从等待队列s.queue中取出头一个进程P； 进程P进入就绪队列; } } 在使用信号量进行共享资源访问控制时，必须成对使用P和V原语。遗漏P原语则不能保证互斥访问，遗漏V原语则不能在使用临界资源之后将其释放给其他等待的进程。P、V原语的使用不能次序错误、重复或遗漏。\n"><meta property='og:url' content='https://blog.debuginn.com/p/os-concurrent-sync/'><meta property='og:site_name' content='Debug客栈'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='os'><meta property='article:tag' content='system'><meta property='article:published_time' content='2017-12-16T22:37:30+08:00'><meta property='article:modified_time' content='2017-12-16T22:37:30+08:00'><meta property='og:image' content='https://webp.debuginn.com/202302221853276.jpg'><meta name=twitter:site content="@idebuginn"><meta name=twitter:creator content="@idebuginn"><meta name=twitter:title content="操作系统 并发与同步"><meta name=twitter:description content="进程（线程）间相互作用 相关进程与无关进程 相关进程：在逻辑上具有某种联系的进程。\n无关进程：在逻辑上没有任何联系的进程。\n如果一个进程的执行不影响其他进程的执行，且与其他进程的进展情况无关，即它们是各自独立的，则说这些并发进程的相互之间是无关的。无关的并发进程一定没有共享的变量。\n如果一个进程的执行依赖其他进程的进展情况，或者说，一个进程的执行可能影响其他进程的执行结果，则说这些并发进程是相关的。\n与时间有关的错误 京城执行的速度是不能由进程自身控制的。对于相关进程来说，可能有若干并发进程同时使用共享资源，即一个进程一次使用未结束，另一个进程也开始使用，形成交替使用共享资源。\n进程同步：值多个进程中发生的事件存在某种时序关系，必须协同动作，相互配合，以共同完成一个任务。\n进程互斥：指由于共享资源所要求的排他性，进程间要相互竞争以使用这些互斥资源。\n进程互斥 解决进程互斥的两种方法：\n由竞争各方平等协商。 引入进程管理者，有管理者来协调竞争各方对互斥资源的使用。 临界资源：计算机系统中的需要互斥使用的硬件或软件资源，如外设、共享代码块、共享数据结构等。对各进程在对临界资源进程进行访问时，特别是进行写入或修改操作时，必须互斥的运行。\n计算机系统中资源共享的程度分为三个层次：互斥、死锁和饥饿。\n互斥：保证资源的互斥使用是指多个进程不能同时使用同一个资源，这是正确使用资源的最基本要求。\n死锁：避免死锁是指多个进程互不相让，避免出现都得不到足够资源的情况，从而保证系统功能的正常运行。\n饥饿：避免饥饿是指避免某些进程一直得不到资源或者得到资源的概率很小，从而保障系统内资源使用的公平性。\n为了保证临界资源的正确使用，可把临界资源的访问过程分为四个部分：\n进入区：为了进入临界区使用临界值资源，在进入区要检查可否进入临界区；如果可以进入临界区，通常设置相应的”正在访问临界区“标志，以阻止其他进程同时进入临界区。 临界区：进程中访问临界资源的一段代码。 退出区：将”正在访问临界区“标识清除。 剩余区：代码中的其他部分。 为了合理使用计算机系系统中的资源，在操作系统中采用的进程同步机制应遵循以下几条：\n空闲则入：任何同步机制都必须保证任何时间嗯最多只有一个进程位于临界区。当有程序位于临界区时，任何其他进程均不能进入临界区。 忙着等待：当以有进程处于其他临界区时，后到达的进程只能在进入区等待。 有限等待：为了避免死锁等现象的出现，等待进入临界区的进程不能无期限的”死等“。 让权等待：因在进入区等待而不能进入临界区的进程，应释放处理机，转换到阻塞状态以使得其他进程有机会得到处理机的使用权。 进程互斥的软件方法 算法1：单标志算法 假设有两个进程Pi和Pj，设立一个公用整理变量turn，描述允许进入临界区的进程标识。每个进程都在进入区循环检查变量turn是否允许本进程进入。即turn为i时，进程Pi可进入，否则循环检查该变量，直到turn为本进程标识，在退出区修改允许进入进程标识，即进程Pi退出时，Pj的标识为j。\n可以保证任何时刻最多只有一个进程在临界区。\n缺点：强制轮流进入临界区，没有考虑进程的实际需要，容易造成资源利用不充分。\n算法2：双标志、先检查算法 修改临界区标志的设置，设立一个标志数组flag[]，描述各进程是否在临界区，初始值均为FALSE.\n在进入区的操作为：先检查，后修改。即在进入区像检查另一个进程是否在临界区，不在时修改本进程在临界区的标志，表示本进程在临界区，在退出区修改本进程在临界区的标志，表示本进程不在临界区。\n算法2的优点是克服了算法1的缺点，两个进程不用交替进入，可连续使用。但由于使用多个标志，算法有产生新的问题，即进程Pi和Pj可能同时进入临界区，从而违反了最左只有多个进程在临界区的要求。\n算法3：双标志、后检查算法 一是保证检查和修改操作间不会出现间隔。 一是修改标志含义。 算法3可防止两个进程同时进入临界区，但它的缺点是Pi和Pj可能都进入不了临界区。在修改本进程标志flag之后和检查对方flag之间有一段时间间隔，这个间隔导致两个进程都想进入临界区，从而在检查对方标志时不通过。\n算法4：先修改、后检查、后修改者等待算法 结合了算法3和1，标志flag[i]表示进程i想进入临界区，标志turn表示同时修改标志时要在进入区等待的进程标识。\n在进入区先修改后检查，通过修改统一标志turn来描述标志修改的先后；检查对方标志flag，如果对方不想进入临界区则自己进入；否则在检查标志turn，由于标志turn中保存的是较晚的一次赋值，则交往修改标志的进程等待，较早的修改标志的进程进入临界区。\n实现了同步机制要求的四条准则中的前两条：空闲则入、忙着等待。\n进程互斥的硬件方法 主要思路：使用一种指令完成读和写的两个操作，因而保证读操作与写操作不被打断，依据采用的指令的不同，硬件方法分成TS指令和Swap指令。\nTS（Test-and-Set）指令 TS指令的功能是读出指定标识后把该标志设置为TRUE。\n每个临界资源设置一个公共布尔变量lock，表示资源两种状态：TURE表示正被占用，FALSE表示空闲，初始值为FALSE。\n有进程在临界区时，重复检查，直到其他进程退出时检查通过，所有要访问临界资源的进程的进入区和退出区代码是相同的。\nSwap指令 利用Swap指令实现的进程互斥算法是，每个临界资源设置一个公共布尔变量lock，初值为FALSE，每个进程设置一个私有布尔变量key，用于与lock间的信息交换。在进入区利用Swap指令交换lock和key的内容，然后检查key的状态，有进程在临界区时，重复交换和检查过程到其他进程推出啊是检查通过。\n优点：\n适用范围广：适用于任意数目的进程，在单处理器和多处理器黄健中完全相同。 简单：硬件方法的标志设置简单，含义明确，容易验证其正确性。 支持多个临界区：在一个进程内有多个临界区是，只需为每个临界区设立一个变量。 缺点：\n进程在等待进入临界区时，要耗费处理机时间，不能实现”让权等待“。 由于进入临界区的进程是从等待进程中随机选择的，有的进程可能一直选不上，从而导致”饥饿“。 信号量 信号量机制所使用的P、V原语就来自荷兰语test和increment。每个信号量s除一个整数值s.count（计数）外，还有一个进程等待队列s.queue，其中存放的是阻塞在该信号量的各个进程的标识。\n信号量只能通过初始化和标准的原语来访问。\nP、V原语的执行，不受进程调度和执行的打断，从而很好地解决了原语操作的整体性。信号量的初始化可指定一个非负整数数值，表示空闲资源总数；若为负值，其绝对值表示当前等待临界区的进程数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 P原语所执行的操作可用下面函数wait（s）来描述。 wait(s){ --s.count; //表示申请一个资源 if(s.count<0){ //表示没有空闲资源 调用进程进入等待队列s.queue; 阻塞调用进程; } } V原语所执行的操作可用下面函数signal(s)描述。 signal(s){ ++s.count; //表示释放一个资源 if(s.count <= 0){ //表示有进程处于阻塞状态 从等待队列s.queue中取出头一个进程P； 进程P进入就绪队列; } } 在使用信号量进行共享资源访问控制时，必须成对使用P和V原语。遗漏P原语则不能保证互斥访问，遗漏V原语则不能在使用临界资源之后将其释放给其他等待的进程。P、V原语的使用不能次序错误、重复或遗漏。\n"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://webp.debuginn.com/202302221853276.jpg'><script async src="https://www.googletagmanager.com/gtag/js?id=G-B1XEJXPQPW"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-B1XEJXPQPW")}</script><meta name=360-site-verification content="6fea9fbe8bbd97a153c554293a3df3c3"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=https://webp.debuginn.com/20250929bC0ReU.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🌏</span></figure><div class=site-meta><h1 class=site-name><a href=/>Debug客栈</a></h1><h2 class=site-description>永远相信美好的事情即将发生</h2></div></header><ol class=menu-social><li><a href=https://github.com/debuginn target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://x.com/idebuginn target=_blank title=x rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-x"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4l11.733 16H20L8.267 4z"/><path d="M4 20l6.768-6.768m2.46-2.46L20 4"/></svg></a></li><li><a href=https://www.zhihu.com/people/debuginn/posts target=_blank title=Zhihu rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-zhihu"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14 6h6v12h-2l-2 2-1-2h-1z"/><path d="M4 12h6.5"/><path d="M10.5 6h-5"/><path d="M6 4c-.5 2.5-1.5 3.5-2.5 4.5"/><path d="M8 6v7c0 4.5-2 5.5-4 7"/><path d="M11 18l-3-5"/></svg></a></li><li><a href=https://blog.debuginn.com/index.xml target=_blank title=Rss rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 102 0 1 1 0 10-2 0"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/subscribe><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-bell-ringing"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 5a2 2 0 014 0 7 7 0 014 6v3a4 4 0 002 3H4a4 4 0 002-3v-3a7 7 0 014-6"/><path d="M9 17v1a3 3 0 006 0v-1"/><path d="M21 6.727A11.05 11.05.0 0018.206 3"/><path d="M3 6.727A11.05 11.05.0 015.792 3"/></svg>
<span>订阅本站</span></a></li><li><a href=/archives><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>文章归档</span></a></li><li><a href=/project><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-git-branch"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 18m-2 0a2 2 0 104 0 2 2 0 10-4 0"/><path d="M7 6M5 6a2 2 0 104 0A2 2 0 105 6"/><path d="M17 6m-2 0a2 2 0 104 0 2 2 0 10-4 0"/><path d="M7 8v8"/><path d="M9 18h6a2 2 0 002-2v-5"/><path d="M14 14l3-3 3 3"/></svg>
<span>我的项目</span></a></li><li><a href=/links><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-link"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 15l6-6"/><path d="M11 6l.463-.536a5 5 0 017.071 7.072L18 13"/><path d="M13 18l-.397.534a5.068 5.068.0 01-7.127.0 4.972 4.972.0 010-7.071L6 11"/></svg>
<span>友情链接</span></a></li><li><a href=/use><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-user-cog"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h2.5"/><path d="M19.001 19m-2 0a2 2 0 104 0 2 2 0 10-4 0"/><path d="M19.001 15.5V17"/><path d="M19.001 21v1.5"/><path d="M22.032 17.25l-1.299.75"/><path d="M17.27 20l-1.3.75"/><path d="M15.97 17.25l1.3.75"/><path d="M20.733 20l1.3.75"/></svg>
<span>我的使用</span></a></li><li><a href=https://photo.debuginn.com target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-photo"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M15 8h.01"/><path d="M3 6a3 3 0 013-3h12a3 3 0 013 3v12a3 3 0 01-3 3H6a3 3 0 01-3-3V6z"/><path d="M3 16l5-5c.928-.893 2.072-.893 3 0l5 5"/><path d="M14 14l1-1c.928-.893 2.072-.893 3 0l3 3"/></svg>
<span>摄影展集</span></a></li><li><a href=https://debuginn.com target=_blank><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-home-star"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M19.258 10.258 12 3l-9 9h2v7a2 2 0 002 2h4"/><path d="M9 21v-6a2 2 0 012-2h1.5"/><path d="M17.8 20.817l-2.172 1.138a.392.392.0 01-.568-.41l.415-2.411-1.757-1.707a.389.389.0 01.217-.665l2.428-.352 1.086-2.193a.392.392.0 01.702.0l1.086 2.193 2.428.352a.39.39.0 01.217.665l-1.757 1.707.414 2.41a.39.39.0 01-.567.411L17.8 20.817z"/></svg>
<span>我的主页</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><form action=/search/ class="search-form widget"><p><label>搜索</label>
<input name=keyword required placeholder=输入关键词...>
<button title=搜索>
<svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg></button></p></form><section class=widget><img src=https://static.debuginn.com/20241111FZS0zY.png alt=WeChat style=border-radius:10px;width:100%></section><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#进程线程间相互作用>进程（线程）间相互作用</a><ol><li><a href=#相关进程与无关进程>相关进程与无关进程</a></li><li><a href=#与时间有关的错误>与时间有关的错误</a></li><li><a href=#进程互斥>进程互斥</a></li></ol></li><li><a href=#进程互斥的软件方法>进程互斥的软件方法</a><ol><li><a href=#算法1单标志算法>算法1：单标志算法</a></li><li><a href=#算法2双标志先检查算法>算法2：双标志、先检查算法</a></li><li><a href=#算法3双标志后检查算法>算法3：双标志、后检查算法</a></li><li><a href=#算法4先修改后检查后修改者等待算法>算法4：先修改、后检查、后修改者等待算法</a></li></ol></li><li><a href=#进程互斥的硬件方法>进程互斥的硬件方法</a><ol><li><a href=#tstest-and-set指令>TS（Test-and-Set）指令</a></li><li><a href=#swap指令>Swap指令</a></li><li><a href=#信号量>信号量</a></li></ol></li><li><a href=#经典的进程同步问题>经典的进程同步问题</a><ol><li><a href=#简单生产者-消费者问题>简单生产者-消费者问题</a></li><li><a href=#多个生产者-消费者问题>多个生产者-消费者问题</a></li><li><a href=#读者-写者问题>读者-写者问题</a></li></ol></li><li><a href=#同步与互斥的综合应用>同步与互斥的综合应用</a><ol><li><a href=#例1-路口单双号交通管制>例1 路口单双号交通管制</a></li><li><a href=#例2-物流系统中的物品分拣问题>例2 物流系统中的物品分拣问题</a><ol><li><a href=#问题>问题</a></li><li><a href=#分析>分析</a></li><li><a href=#说明>说明</a></li></ol></li></ol></li><li><a href=#管程>管程</a><ol><li><a href=#管程的提出>管程的提出</a></li><li><a href=#管程的概念及组成>管程的概念及组成</a></li><li><a href=#管程中的条件变量>管程中的条件变量</a></li></ol></li><li><a href=#用管程解决生产者-消费则问题>用管程解决生产者-消费则问题</a><ol><li><a href=#pthread中的互斥与同步>Pthread中的互斥与同步</a></li><li><a href=#互斥量及相关函数>互斥量及相关函数</a></li><li><a href=#条件变量及相关函数>条件变量及相关函数</a></li></ol></li><li><a href=#通信进程>通信进程</a><ol><li><a href=#共享内存>共享内存</a></li><li><a href=#消息机制>消息机制</a></li><li><a href=#信息缓冲通信>信息缓冲通信</a></li><li><a href=#信箱通信>信箱通信</a></li><li><a href=#管道通信>管道通信</a></li></ol></li></ol></nav></div></section><section class="widget email"><div class=widget-icon><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-mail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></div><h2 class="widget-title section-title">订阅</h2><div class=stack-widget-email-card><div class=stack-widget-email-section><form id=email-subscribe-form class=stack-widget-email-form novalidate><input type=email id=email-input name=EMAIL placeholder=输入邮箱，获取最新文章推送 class=stack-widget-email-input required>
<button type=submit class=stack-widget-email-submit id=subscribe-btn>
订阅</button></form></div></div></section><div id=stack-widget-email-toast class=stack-widget-email-toast></div><script>document.addEventListener("DOMContentLoaded",function(){const s=document.getElementById("email-subscribe-form"),n=document.getElementById("email-input"),e=document.getElementById("subscribe-btn"),o="https://us3.list-manage.com/subscribe/post-json";function i(e,t="info",n=3e3){const s=document.getElementById("stack-widget-email-toast");s.textContent=e,s.className=`stack-widget-email-toast stack-widget-email-toast-${t} stack-widget-email-toast-show`,setTimeout(()=>{s.className="stack-widget-email-toast"},n)}function t(e,t="info"){i(e,t,5e3)}function a(e){const t=/^[^\s@]+@[^\s@]+\.[^\s@]+$/;return t.test(e)}s.addEventListener("submit",function(s){s.preventDefault();const c=n.value.trim();if(!c){t("请输入邮箱地址","error");return}if(!a(c)){t("请输入有效的邮箱地址","error");return}e.disabled=!0,e.textContent="订阅中...";const i=document.createElement("script"),r="mailchimpCallback_"+Date.now();window[r]=function(s){if(document.head.removeChild(i),delete window[r],e.disabled=!1,e.textContent="订阅",s.result==="success")t("订阅成功！感谢您的订阅！","success"),n.value="";else{let e="订阅失败，请稍后重试";s.msg&&(s.msg.includes("already subscribed")?e="该邮箱已经订阅过了":s.msg.includes("invalid")?e="邮箱地址无效":e=s.msg.replace(/\d+ - /,"")),t(e,"error")}};const l=new URLSearchParams({u:"397828d3cf4dbe2593b9da8e3",id:"b7404a6937",EMAIL:c,c:r});i.src=`${o}?${l.toString()}`,i.onerror=function(){document.head.removeChild(i),delete window[r],e.disabled=!1,e.textContent="订阅",t("网络错误，请稍后重试","error")},document.head.appendChild(i)}),n.addEventListener("keypress",function(e){e.key==="Enter"&&s.dispatchEvent(new Event("submit"))})})</script><section class="widget donation"><div class=widget-icon><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-currency-ethereum"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 12l6-9 6 9-6 9z"/><path d="M6 12l6-3 6 3-6 2z"/></svg></div><h2 class="widget-title section-title">赞赏</h2><div class=stack-widget-donation-card><div class=stack-widget-donation-section><div class=stack-widget-donation-item data-crypto=eth><div class=stack-widget-donation-item-bg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-currency-ethereum"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 12l6-9 6 9-6 9z"/><path d="M6 12l6-3 6 3-6 2z"/></svg></div><span class=stack-widget-donation-label>ETH</span><div class=stack-widget-donation-address><code>0xd06a56704ecb1eee65abcaa3101d88e2a8225a4e</code></div><button class=stack-widget-donation-btn-copy data-clipboard-text=0xd06a56704ecb1eee65abcaa3101d88e2a8225a4e title=Copy>
Copy
</button>
<input type=number class=stack-widget-donation-amount-input value=0.001 step=0.001 min=0 style=display:none>
<button class=stack-widget-donate-btn-donate title=Donate onclick=toggleDonateMode(this) data-address=0xd06a56704ecb1eee65abcaa3101d88e2a8225a4e>
Donate</button></div><div class=stack-widget-donation-item data-crypto=sol><div class=stack-widget-donation-item-bg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-currency-solana"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 18h12l4-4H8z"/><path d="M8 14l-4-4h12l4 4"/><path d="M16 10l4-4H8l-4 4"/></svg></div><span class=stack-widget-donation-label>SOL</span><div class=stack-widget-donation-address><code>5LupLo8NuTfC411zAPo6UZTuasoTHaueuptVyGKmsdBV</code></div><button class=stack-widget-donation-btn-copy data-clipboard-text=5LupLo8NuTfC411zAPo6UZTuasoTHaueuptVyGKmsdBV title=Copy>
Copy
</button>
<input type=number class=stack-widget-donation-amount-input value=1 step=0.001 min=0 style=display:none></div></div><div class=stack-widget-donation-card><a href=/reward/ target=_self rel="noopener noreferrer"><img src=https://static.debuginn.com/20250807C6FEAA.png alt=donation class=stack-widget-donation-qr></a></div></div></section><div id=stack-widget-donation-toast class=stack-widget-donation-toast></div><script>function showToast(e,t="info",n=3e3){const s=document.getElementById("stack-widget-donation-toast");s.textContent=e,s.className=`stack-widget-donation-toast stack-widget-donation-toast-${t} stack-widget-donation-toast-show`,setTimeout(()=>{s.className="stack-widget-donation-toast"},n)}async function toggleDonateMode(e){const n=e.closest(".stack-widget-donation-item"),t=n.querySelector(".stack-widget-donation-amount-input"),o=e.getAttribute("data-address"),i=n.querySelector(".stack-widget-donation-label").textContent.trim(),s=e.textContent.trim();if(s==="Donate")e.classList.add("active"),e.textContent="Pay",t.style.display="block",t.focus();else if(s==="Pay"){const n=t.value;if(!n||n<=0){showToast("请输入有效的捐赠金额","warning");return}const s=parseFloat(n);e.disabled=!0,e.textContent="Paying";try{await payWithWallet(o,s,i),resetDonateButton(e,t)}catch(t){console.error("支付失败:",t),showToast("支付失败: "+t.message,"error"),e.textContent="Pay"}finally{e.disabled=!1}}else resetDonateButton(e,t)}function resetDonateButton(e,t){e.classList.remove("active"),e.textContent="Donate",e.disabled=!1,t.style.display="none";const n=e.closest(".stack-widget-donation-item"),s=n.querySelector(".stack-widget-donation-amount-input").getAttribute("value"),o=parseFloat(s);t.value=o}function getTokenConfig(e){const t={ETH:{symbol:"ETH",decimals:18,contractAddress:null,chainId:"0x1",network:"ethereum"}};for(const[n,s]of Object.entries(t))if(e.toUpperCase().includes(n))return s;return t.ETH}async function payWithWallet(e,t,n){const s=getTokenConfig(n);if(s.error)throw showToast(s.error,"error"),new Error(s.error);return await payWithEthereum(e,t,s)}async function payWithEthereum(e,t,n){if(typeof window.ethereum=="undefined")throw showToast("请先安装支持以太坊的浏览器钱包（如 MetaMask、Trust Wallet、Coinbase Wallet 等）","warning",4e3),new Error("请先安装支持以太坊的浏览器钱包（如 MetaMask、Trust Wallet、Coinbase Wallet 等）");try{await window.ethereum.request({method:"eth_requestAccounts"});const r=await window.ethereum.request({method:"eth_chainId"});if(r!==n.chainId)try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:n.chainId}]}),showToast("已切换到以太坊主网","success")}catch(e){throw e.code===4902?(showToast("请在钱包中手动添加以太坊主网","warning",4e3),new Error("请在钱包中手动添加以太坊主网")):e.code===4001?(showToast("用户拒绝切换网络","info"),new Error("用户拒绝切换网络")):(showToast(`网络切换失败，请手动切换到以太坊主网 (Chain ID: ${n.chainId})`,"warning",4e3),new Error(`网络切换失败，请手动切换到以太坊主网 (Chain ID: ${n.chainId})`))}const o=await window.ethereum.request({method:"eth_accounts"});if(o.length===0)throw showToast("请先连接钱包账户","warning"),new Error("请先连接钱包账户");const i=o[0];let s;n.contractAddress?s=await sendERC20Token(i,e,t,n):s=await sendETH(i,e,t,n),showToast(`支付成功！交易哈希: ${s.slice(0,10)}...`,"success",5e3);const a=document.querySelector(".donation-amount-input");return a&&(a.style.display="none"),s}catch(e){throw e.code===4001?(showToast("用户取消了交易","info"),new Error("用户取消了交易")):e}}async function sendETH(e,t,n,s){const o="0x"+(parseFloat(n)*10**s.decimals).toString(16),i={to:t,from:e,value:o,gas:"0x5208"};return await window.ethereum.request({method:"eth_sendTransaction",params:[i]})}async function sendERC20Token(e,t,n,s){const o=(parseFloat(n)*10**s.decimals).toString(16),i="0xa9059cbb",a=t.slice(2).padStart(64,"0"),r=o.padStart(64,"0"),c=i+a+r,l={to:s.contractAddress,from:e,data:c,gas:"0x186A0"};return await window.ethereum.request({method:"eth_sendTransaction",params:[l]})}</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll(".stack-widget-donation-btn-copy");e.forEach(function(e){e.addEventListener("click",function(){const n=this.getAttribute("data-clipboard-text"),t=this.textContent;navigator.clipboard.writeText(n).then(function(){e.textContent="Copied!",showToast("地址已复制到剪贴板","success"),setTimeout(function(){e.textContent=t},1500)}).catch(function(){e.textContent="Failed!",showToast("复制失败","error"),setTimeout(function(){e.textContent=t},1500)})})})})</script><section class="widget promote"><div class=widget-icon><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-eye-discount"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 12a2 2 0 104 0 2 2 0 00-4 0"/><path d="M12 18c-3.6.0-6.6-2-9-6 2.4-4 5.4-6 9-6s6.6 2 9 6"/><path d="M16 21l5-5"/><path d="M21 21v.01"/><path d="M16 16v.01"/></svg></div><h2 class="widget-title section-title">推广</h2><div class=stack-widget-promote-card><div class=stack-widget-promote-section><a href=/p/mi-work/ class=stack-widget-promote-item-link><div class=stack-widget-promote-item><span class=stack-widget-promote-label><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-briefcase"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 7m0 2a2 2 0 012-2h14a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><path d="M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M12 12v.01"/><path d="M3 13a20 20 0 0018 0"/></svg></span><div class=stack-widget-promote-text>来小米，一起玩！校招、社招均可内推！</div></div></a><a href="https://www.xflash.live/#/register?code=GZRNxKBh" target=_blank class=stack-widget-promote-item-link><div class=stack-widget-promote-item><span class=stack-widget-promote-label><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-network"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9a6 6 0 1012 0A6 6 0 006 9"/><path d="M12 3c1.333.333 2 2.333 2 6s-.667 5.667-2 6"/><path d="M12 3c-1.333.333-2 2.333-2 6s.667 5.667 2 6"/><path d="M6 9h12"/><path d="M3 20h7"/><path d="M14 20h7"/><path d="M10 20a2 2 0 104 0 2 2 0 00-4 0"/><path d="M12 15v3"/></svg></span><div class=stack-widget-promote-text>XFlash Cloud 稳定好用速度快节点多</div></div></a><a href="https://app.cloudcone.com/?ref=13045" target=_blank class=stack-widget-promote-item-link><div class=stack-widget-promote-item><span class=stack-widget-promote-label><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-cloud-network"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 20h7"/><path d="M14 20h7"/><path d="M10 20a2 2 0 104 0 2 2 0 00-4 0"/><path d="M12 16v2"/><path d="M8 16.004H6.657C4.085 16 2 13.993 2 11.517c0-2.475 2.085-4.482 4.657-4.482.393-1.762 1.794-3.2 3.675-3.773 1.88-.572 3.956-.193 5.444 1 1.488 1.19 2.162 3.007 1.77 4.769h.99c1.913.0 3.464 1.56 3.464 3.486.0 1.927-1.551 3.487-3.465 3.487H16"/></svg></span><div class=stack-widget-promote-text>CloudCone VPS 每月仅需 $1.66</div></div></a></div></div></section><section class="widget popular"><div class=widget-icon><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-flame"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 10.941c2.333-3.308.167-7.823-1-8.941.0 3.395-2.235 5.299-3.667 6.706C5.903 10.114 5 12.327 5 14.294 5 17.998 8.134 21 12 21s7-3.002 7-6.706c0-1.712-1.232-4.403-2.333-5.588-2.084 3.353-3.257 3.353-4.667 2.235"/></svg></div><h2 class="widget-title section-title">热门</h2><div class=stack-widget-popular-card><div class=stack-widget-popular-section><a href=/p/work-5-years/ class=stack-widget-popular-item-link><div class=stack-widget-popular-item><span class=stack-widget-popular-label><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-linkedin"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 10-4 0"/><path d="M3 7a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4H7a4 4 0 01-4-4z"/></svg></span><div class=stack-widget-popular-text>入职 5 周年，我和小米的 5 周年</div><div class=stack-widget-popular-views>2.3k+ 阅读</div></div></a><a href=/tags/follow/ class=stack-widget-popular-item-link><div class=stack-widget-popular-item><span class=stack-widget-popular-label><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 102 0 1 1 0 10-2 0"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></span><div class=stack-widget-popular-text>Follow 下一代的信息浏览器</div><div class=stack-widget-popular-views>1.9k+ 阅读</div></div></a><a href=/p/financial-hongkong-card/ class=stack-widget-popular-item-link><div class=stack-widget-popular-item><span class=stack-widget-popular-label><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-wallet"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M17 8V5a1 1 0 00-1-1H6a2 2 0 000 4h12a1 1 0 011 1v3m0 4v3a1 1 0 01-1 1H6a2 2 0 01-2-2V6"/><path d="M20 12v4h-4a2 2 0 010-4h4"/></svg></span><div class=stack-widget-popular-text>港卡开卡指南</div><div class=stack-widget-popular-views>886+ 阅读</div></div></a><a href=/categories/travel/ class=stack-widget-popular-item-link><div class=stack-widget-popular-item><span class=stack-widget-popular-label><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-building-airport"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3.59 7h8.82a1 1 0 01.902 1.433l-1.44 3a1 1 0 01-.901.567H5.029a1 1 0 01-.901-.567l-1.44-3A1 1 0 013.589 7"/><path d="M6 7l-.78-2.342A.5.5.0 015.693 4h4.612a.5.5.0 01.475.658L10 7"/><path d="M8 2v2"/><path d="M6 12v9h4v-9"/><path d="M3 21h18"/><path d="M22 5h-6l-1-1"/><path d="M18 3l2 2-2 2"/><path d="M10 17h7a2 2 0 012 2v2"/></svg></span><div class=stack-widget-popular-text>游记系列 跟我一起环游中国</div><div class=stack-widget-popular-views>500+ 阅读</div></div></a></div></div></section><section class=widget><div class=widget-icon><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-ad"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 5m0 2a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><path d="M7 15v-4a2 2 0 014 0v4"/><path d="M7 13h4"/><path d="M17 9v6h-1.5a1.5 1.5.0 111.5-1.5"/></svg></div><h2 class="widget-title section-title">广告</h2><div class=stack-widget-ad-card><ins class=adsbygoogle data-ad-client=ca-pub-7167312285165454 data-ad-slot=3692601567 data-ad-format=auto data-full-width-responsive=true></ins></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/os-concurrent-sync/><img src=https://webp.debuginn.com/202302221853276.jpg loading=lazy alt="Featured image of post 操作系统 并发与同步"></a></div><div class=article-details><header class=article-category><a href=/categories/os/>OS</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/os-concurrent-sync/>操作系统 并发与同步</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 16, 2017</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 2 分钟</time></div></footer></div></header><section class=article-content><h2 id=进程线程间相互作用><a href=#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e9%97%b4%e7%9b%b8%e4%ba%92%e4%bd%9c%e7%94%a8 class=header-anchor></a>进程（线程）间相互作用</h2><h3 id=相关进程与无关进程><a href=#%e7%9b%b8%e5%85%b3%e8%bf%9b%e7%a8%8b%e4%b8%8e%e6%97%a0%e5%85%b3%e8%bf%9b%e7%a8%8b class=header-anchor></a>相关进程与无关进程</h3><p>相关进程：在逻辑上具有某种联系的进程。</p><p>无关进程：在逻辑上没有任何联系的进程。</p><p>如果一个进程的执行不影响其他进程的执行，且与其他进程的进展情况无关，即它们是各自独立的，则说这些并发进程的相互之间是无关的。无关的并发进程一定没有共享的变量。</p><p>如果一个进程的执行依赖其他进程的进展情况，或者说，一个进程的执行可能影响其他进程的执行结果，则说这些并发进程是相关的。</p><h3 id=与时间有关的错误><a href=#%e4%b8%8e%e6%97%b6%e9%97%b4%e6%9c%89%e5%85%b3%e7%9a%84%e9%94%99%e8%af%af class=header-anchor></a>与时间有关的错误</h3><p>京城执行的速度是不能由进程自身控制的。对于相关进程来说，可能有若干并发进程同时使用共享资源，即一个进程一次使用未结束，另一个进程也开始使用，形成交替使用共享资源。</p><p>进程同步：值多个进程中发生的事件存在某种时序关系，必须协同动作，相互配合，以共同完成一个任务。</p><p>进程互斥：指由于共享资源所要求的排他性，进程间要相互竞争以使用这些互斥资源。</p><h3 id=进程互斥><a href=#%e8%bf%9b%e7%a8%8b%e4%ba%92%e6%96%a5 class=header-anchor></a>进程互斥</h3><p>解决进程互斥的两种方法：</p><ul><li>由竞争各方平等协商。</li><li>引入进程管理者，有管理者来协调竞争各方对互斥资源的使用。</li></ul><p>临界资源：计算机系统中的需要互斥使用的硬件或软件资源，如外设、共享代码块、共享数据结构等。对各进程在对临界资源进程进行访问时，特别是进行写入或修改操作时，必须互斥的运行。</p><p>计算机系统中资源共享的程度分为三个层次：互斥、死锁和饥饿。</p><p>互斥：保证资源的互斥使用是指多个进程不能同时使用同一个资源，这是正确使用资源的最基本要求。</p><p>死锁：避免死锁是指多个进程互不相让，避免出现都得不到足够资源的情况，从而保证系统功能的正常运行。</p><p>饥饿：避免饥饿是指避免某些进程一直得不到资源或者得到资源的概率很小，从而保障系统内资源使用的公平性。</p><p><img src=https://webp.debuginn.com/202304132239136.png loading=lazy alt=进程互斥></p><p>为了保证临界资源的正确使用，可把临界资源的访问过程分为四个部分：</p><ol><li>进入区：为了进入临界区使用临界值资源，在进入区要检查可否进入临界区；如果可以进入临界区，通常设置相应的”正在访问临界区“标志，以阻止其他进程同时进入临界区。</li><li>临界区：进程中访问临界资源的一段代码。</li><li>退出区：将”正在访问临界区“标识清除。</li><li>剩余区：代码中的其他部分。</li></ol><p>为了合理使用计算机系系统中的资源，在操作系统中采用的进程同步机制应遵循以下几条：</p><ol><li>空闲则入：任何同步机制都必须保证任何时间嗯最多只有一个进程位于临界区。当有程序位于临界区时，任何其他进程均不能进入临界区。</li><li>忙着等待：当以有进程处于其他临界区时，后到达的进程只能在进入区等待。</li><li>有限等待：为了避免死锁等现象的出现，等待进入临界区的进程不能无期限的”死等“。</li><li>让权等待：因在进入区等待而不能进入临界区的进程，应释放处理机，转换到阻塞状态以使得其他进程有机会得到处理机的使用权。</li></ol><h2 id=进程互斥的软件方法><a href=#%e8%bf%9b%e7%a8%8b%e4%ba%92%e6%96%a5%e7%9a%84%e8%bd%af%e4%bb%b6%e6%96%b9%e6%b3%95 class=header-anchor></a>进程互斥的软件方法</h2><h3 id=算法1单标志算法><a href=#%e7%ae%97%e6%b3%951%e5%8d%95%e6%a0%87%e5%bf%97%e7%ae%97%e6%b3%95 class=header-anchor></a>算法1：单标志算法</h3><p>假设有两个进程Pi和Pj，设立一个公用整理变量turn，描述允许进入临界区的进程标识。每个进程都在进入区循环检查变量turn是否允许本进程进入。即turn为i时，进程Pi可进入，否则循环检查该变量，直到turn为本进程标识，在退出区修改允许进入进程标识，即进程Pi退出时，Pj的标识为j。</p><p>可以保证任何时刻最多只有一个进程在临界区。</p><p>缺点：强制轮流进入临界区，没有考虑进程的实际需要，容易造成资源利用不充分。</p><h3 id=算法2双标志先检查算法><a href=#%e7%ae%97%e6%b3%952%e5%8f%8c%e6%a0%87%e5%bf%97%e5%85%88%e6%a3%80%e6%9f%a5%e7%ae%97%e6%b3%95 class=header-anchor></a>算法2：双标志、先检查算法</h3><p>修改临界区标志的设置，设立一个标志数组flag[]，描述各进程是否在临界区，初始值均为FALSE.</p><p>在进入区的操作为：先检查，后修改。即在进入区像检查另一个进程是否在临界区，不在时修改本进程在临界区的标志，表示本进程在临界区，在退出区修改本进程在临界区的标志，表示本进程不在临界区。</p><p>算法2的优点是克服了算法1的缺点，两个进程不用交替进入，可连续使用。但由于使用多个标志，算法有产生新的问题，即进程Pi和Pj可能同时进入临界区，从而违反了最左只有多个进程在临界区的要求。</p><h3 id=算法3双标志后检查算法><a href=#%e7%ae%97%e6%b3%953%e5%8f%8c%e6%a0%87%e5%bf%97%e5%90%8e%e6%a3%80%e6%9f%a5%e7%ae%97%e6%b3%95 class=header-anchor></a>算法3：双标志、后检查算法</h3><p>一是保证检查和修改操作间不会出现间隔。
一是修改标志含义。
算法3可防止两个进程同时进入临界区，但它的缺点是Pi和Pj可能都进入不了临界区。在修改本进程标志flag之后和检查对方flag之间有一段时间间隔，这个间隔导致两个进程都想进入临界区，从而在检查对方标志时不通过。</p><h3 id=算法4先修改后检查后修改者等待算法><a href=#%e7%ae%97%e6%b3%954%e5%85%88%e4%bf%ae%e6%94%b9%e5%90%8e%e6%a3%80%e6%9f%a5%e5%90%8e%e4%bf%ae%e6%94%b9%e8%80%85%e7%ad%89%e5%be%85%e7%ae%97%e6%b3%95 class=header-anchor></a>算法4：先修改、后检查、后修改者等待算法</h3><p>结合了算法3和1，标志<code>flag[i]</code>表示进程i想进入临界区，标志turn表示同时修改标志时要在进入区等待的进程标识。</p><p>在进入区先修改后检查，通过修改统一标志turn来描述标志修改的先后；检查对方标志flag，如果对方不想进入临界区则自己进入；否则在检查标志turn，由于标志turn中保存的是较晚的一次赋值，则交往修改标志的进程等待，较早的修改标志的进程进入临界区。</p><p>实现了同步机制要求的四条准则中的前两条：空闲则入、忙着等待。</p><h2 id=进程互斥的硬件方法><a href=#%e8%bf%9b%e7%a8%8b%e4%ba%92%e6%96%a5%e7%9a%84%e7%a1%ac%e4%bb%b6%e6%96%b9%e6%b3%95 class=header-anchor></a>进程互斥的硬件方法</h2><p>主要思路：使用一种指令完成读和写的两个操作，因而保证读操作与写操作不被打断，依据采用的指令的不同，硬件方法分成TS指令和Swap指令。</p><h3 id=tstest-and-set指令><a href=#tstest-and-set%e6%8c%87%e4%bb%a4 class=header-anchor></a>TS（Test-and-Set）指令</h3><p>TS指令的功能是读出指定标识后把该标志设置为TRUE。</p><p>每个临界资源设置一个公共布尔变量lock，表示资源两种状态：TURE表示正被占用，FALSE表示空闲，初始值为FALSE。</p><p>有进程在临界区时，重复检查，直到其他进程退出时检查通过，所有要访问临界资源的进程的进入区和退出区代码是相同的。</p><h3 id=swap指令><a href=#swap%e6%8c%87%e4%bb%a4 class=header-anchor></a>Swap指令</h3><p>利用Swap指令实现的进程互斥算法是，每个临界资源设置一个公共布尔变量lock，初值为FALSE，每个进程设置一个私有布尔变量key，用于与lock间的信息交换。在进入区利用Swap指令交换lock和key的内容，然后检查key的状态，有进程在临界区时，重复交换和检查过程到其他进程推出啊是检查通过。</p><p><strong>优点：</strong></p><ol><li>适用范围广：适用于任意数目的进程，在单处理器和多处理器黄健中完全相同。</li><li>简单：硬件方法的标志设置简单，含义明确，容易验证其正确性。</li><li>支持多个临界区：在一个进程内有多个临界区是，只需为每个临界区设立一个变量。</li></ol><p><strong>缺点：</strong></p><ol><li>进程在等待进入临界区时，要耗费处理机时间，不能实现”让权等待“。</li><li>由于进入临界区的进程是从等待进程中随机选择的，有的进程可能一直选不上，从而导致”饥饿“。</li></ol><h3 id=信号量><a href=#%e4%bf%a1%e5%8f%b7%e9%87%8f class=header-anchor></a>信号量</h3><p>信号量机制所使用的P、V原语就来自荷兰语test和increment。每个信号量s除一个整数值s.count（计数）外，还有一个进程等待队列s.queue，其中存放的是阻塞在该信号量的各个进程的标识。</p><p>信号量只能通过初始化和标准的原语来访问。</p><p>P、V原语的执行，不受进程调度和执行的打断，从而很好地解决了原语操作的整体性。信号量的初始化可指定一个非负整数数值，表示空闲资源总数；若为负值，其绝对值表示当前等待临界区的进程数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>P原语所执行的操作可用下面函数wait</span><span class=err>（</span><span class=n>s</span><span class=err>）来描述。</span>
</span></span><span class=line><span class=cl><span class=nf>wait</span><span class=p>(</span><span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=o>--</span><span class=n>s</span><span class=p>.</span><span class=n>count</span><span class=p>;</span>              <span class=c1>//表示申请一个资源
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>count</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>){</span>      <span class=c1>//表示没有空闲资源
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=err>调用进程进入等待队列</span><span class=n>s</span><span class=p>.</span><span class=n>queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=err>阻塞调用进程</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>V原语所执行的操作可用下面函数signal</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=err>描述。</span>
</span></span><span class=line><span class=cl><span class=nf>signal</span><span class=p>(</span><span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>s</span><span class=p>.</span><span class=n>count</span><span class=p>;</span>              <span class=c1>//表示释放一个资源
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>count</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>){</span>   <span class=c1>//表示有进程处于阻塞状态
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=err>从等待队列</span><span class=n>s</span><span class=p>.</span><span class=n>queue中取出头一个进程P</span><span class=err>；</span>
</span></span><span class=line><span class=cl>        <span class=err>进程</span><span class=n>P进入就绪队列</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在使用信号量进行共享资源访问控制时，必须成对使用P和V原语。遗漏P原语则不能保证互斥访问，遗漏V原语则不能在使用临界资源之后将其释放给其他等待的进程。P、V原语的使用不能次序错误、重复或遗漏。</p><p>利用操作系统提供的信号量机制可实现进程间的同步，即所谓的前驱关系。</p><p>前趋关系是指并发执行的进程P1和P2中，分别有代码C1和C2，要求C1在C2开始前完成执行。可为每个前趋关系设置一个互斥信号量S12，其初值为0.这样，只有在P1执行到V（S12）后，P2才会结束P（S12）的执行。</p><p><img src=https://webp.debuginn.com/202304132242990.png loading=lazy alt=前趋关系></p><h2 id=经典的进程同步问题><a href=#%e7%bb%8f%e5%85%b8%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%90%8c%e6%ad%a5%e9%97%ae%e9%a2%98 class=header-anchor></a>经典的进程同步问题</h2><p>Dijkstra将同步问题抽象成一种“生产者-消费者关系”。</p><h3 id=简单生产者-消费者问题><a href=#%e7%ae%80%e5%8d%95%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98 class=header-anchor></a>简单生产者-消费者问题</h3><p><img src=https://webp.debuginn.com/202304132243264.png loading=lazy alt=简单生产者-消费者问题></p><p>设有一个生产者进程P，一个消费者进程Q，他们通过一个缓冲区联系起来。缓冲区只能容纳一个产品，生产者不断的生产产品；而消费者则不断从缓冲区中取出产品，并消费掉。
生产者-消费者同步问题的解决方案如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>生产者进程</span><span class=nl>P</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>生产一个产品</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>送产品到缓冲区</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=err>消费者进程</span><span class=n>Q</span><span class=err>：</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>从缓冲区去产品</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>消费产品</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>产品生产出来之后立即往缓冲区中存放产品，因为刚开始时缓冲区是空的，一定可以存放一个产品。</p><h3 id=多个生产者-消费者问题><a href=#%e5%a4%9a%e4%b8%aa%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98 class=header-anchor></a>多个生产者-消费者问题</h3><p>设有多个生产者进程P1，P2，……, Pn，若干个消费者进程Q1，Q2，Q3，……，Qm，他们通过一个唤醒缓冲池联系起来，该环形缓冲池由K个大小相等的缓冲区组成，每个缓冲区能容纳一个产品，生产者每次往空缓冲区送一个产品；消费者每次从缓冲区取出一个产品。生产者进程不断地生产产品并把他们放给缓冲池内，消费者进程不断的从缓冲池内取出产品并消费之。</p><p><img src=https://webp.debuginn.com/202304132244539.png loading=lazy alt=多个生产者></p><p>当整个缓冲池全满时，出现供大于求的现象。当整个缓冲池全空时，出现供不应求的现象。</p><p>环形缓冲池是临界资源，因为生产者和消费者都需要使用它。</p><ol><li>同步问题：P进程不能往“满”的缓冲区中放产品，设置信号量empty，初值为k，用于指示缓冲池中空缓冲区数目。Q进程不能从“空”的缓冲区中取产品，设置信号量full，初值为0，用于指示缓冲池中满缓冲区数目。</li><li>互斥问题：设置信号量mutex，初值为1，用于实现临界区（环形缓冲区）的互斥。</li></ol><p>算法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>P1</span><span class=err>，</span><span class=n>P2</span><span class=err>，</span><span class=p>......,</span><span class=n>Pn</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>i</span><span class=p>:</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=err>生产产品</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>往</span><span class=n>Buffer</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=err>中放产品</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nl>i</span><span class=p>:</span><span class=o>=</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=n>mod</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Q1</span><span class=p>,</span><span class=n>Q2</span><span class=p>,......,</span><span class=n>Qm</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>j</span><span class=p>:</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>P</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>从</span><span class=n>Buffer</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=err>中存放产品</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nl>j</span><span class=p>:</span><span class=o>=</span><span class=p>(</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=n>mod</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>V</span><span class=p>(</span><span class=n>empty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=err>消费产品</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=读者-写者问题><a href=#%e8%af%bb%e8%80%85-%e5%86%99%e8%80%85%e9%97%ae%e9%a2%98 class=header-anchor></a>读者-写者问题</h3><p>假定有某个共享文件F，系统允许若干个进程对文件F进行读或写，这里要把读文件的进程称为读者，要把写文件的进程称为写者.</p><p>多个进程可以同时读文件F；</p><ol><li>任一个进程在对文件F进行写时，按规定每次只允许一个进程执行写操作；</li><li>当有进程正在读文件时不允许任何进程去写文件。</li><li>当有多个读者与写者都需要读写文件时，按规定每次只允许一个进程执行写操作，且在有进程执行写的时候不允许进程读文件。</li></ol><h2 id=同步与互斥的综合应用><a href=#%e5%90%8c%e6%ad%a5%e4%b8%8e%e4%ba%92%e6%96%a5%e7%9a%84%e7%bb%bc%e5%90%88%e5%ba%94%e7%94%a8 class=header-anchor></a>同步与互斥的综合应用</h2><h3 id=例1-路口单双号交通管制><a href=#%e4%be%8b1-%e8%b7%af%e5%8f%a3%e5%8d%95%e5%8f%8c%e5%8f%b7%e4%ba%a4%e9%80%9a%e7%ae%a1%e5%88%b6 class=header-anchor></a>例1 路口单双号交通管制</h3><p><img src=https://webp.debuginn.com/202304132246349.png loading=lazy alt=路口单双号交通管制></p><p>Check：指示可否在车辆号码识别区中进入一辆汽车，由于只能进入一辆，其初值为1.</p><p>Ddd：指示汽车号码是否为奇数，其初值为0，表是不是奇数。</p><p>Lven：指示汽车号码是否为偶数，其初值为0，表示不是偶数。</p><h3 id=例2-物流系统中的物品分拣问题><a href=#%e4%be%8b2-%e7%89%a9%e6%b5%81%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e7%89%a9%e5%93%81%e5%88%86%e6%8b%a3%e9%97%ae%e9%a2%98 class=header-anchor></a>例2 物流系统中的物品分拣问题</h3><h4 id=问题><a href=#%e9%97%ae%e9%a2%98 class=header-anchor></a>问题</h4><p>从沿长江一线进入枢纽的集装箱，要从这里直接吊装到上海至旧金山的定期集装箱班轮上。</p><p>而从沪杭高速公路上进入枢纽的集装箱，要从这里还转到专门在京沪高速公路上行驶的集装箱运输箱上。</p><p>该中转枢纽的场地每次只能接受一个方向来的同一批次的集装箱。</p><h4 id=分析><a href=#%e5%88%86%e6%9e%90 class=header-anchor></a>分析</h4><p>长江一线进入的集装箱卸货是一个生产者，从沪杭高速公路上进入的集装箱卸货是第二个生产者。</p><p>这两个生产者都要使用中转枢纽的场地，由于该场地每次只能接受一个方向来的同一批次的集装箱，所以长江一线生产者和沪杭高速公路生产者必须互斥。</p><p>Site：指示能否在中转的枢纽的场地上卸下集装箱。</p><p>Arrive_Y:指示场地上的集装箱是否来自长江。</p><p>Arrive_H:指示场地上的集装箱是否来自沪杭。</p><h4 id=说明><a href=#%e8%af%b4%e6%98%8e class=header-anchor></a>说明</h4><p>由于Site初值为1，P(Site)起到互斥作用，无论谁先卸下了集装箱，另一个物流方向上不能在卸货，只能等待.</p><p>进程“旧金山班轮装货”和“北京运输车装货”在装完集装箱之后，都调用V(Site),发出可以接受新集装箱的消息。</p><p>Site信号量既作为互斥的信号量，又起着同步信号量的作用。</p><h2 id=管程><a href=#%e7%ae%a1%e7%a8%8b class=header-anchor></a>管程</h2><h3 id=管程的提出><a href=#%e7%ae%a1%e7%a8%8b%e7%9a%84%e6%8f%90%e5%87%ba class=header-anchor></a>管程的提出</h3><p>采用P、V同步机制来编写并发程序，对于共享变量及信号量的操作将被分散于各个进程中。</p><p>缺点：</p><ol><li>对于一组共享变量及信号量的操作是否正确，则必须通读整个系统或者并发程序。</li><li>程序不利于修改和维护，局部性很差，所以任意一组变量或一段代码的修改都可能影响全局。</li><li>正确性难以保证，保证一个复杂系统没有逻辑错误是很难的。</li></ol><h3 id=管程的概念及组成><a href=#%e7%ae%a1%e7%a8%8b%e7%9a%84%e6%a6%82%e5%bf%b5%e5%8f%8a%e7%bb%84%e6%88%90 class=header-anchor></a>管程的概念及组成</h3><p>一个管程是一个由过程、变量及数据结构等组成的集合，他们组成一个特殊的模块或软件包。进程可在任何需要的时候调用管程中的过程，但他们不能在管程之外声明的过程中直接访问管程内的数据结构。</p><p>一个管程由四个部分组成：管程名称、共享数据的说明，对数据进行操作的一组过程和对共享数据赋初值的语句。</p><p>管程能保障共享资源的互斥执行，即一次只能有一个进程可以在管程内活动。</p><p>三个特性：</p><ol><li>模块化： 一个基本程序单位，可以单独编译。</li><li>抽象数据类型： 管程是一种特殊的数据类型，其中不仅有数据，而且还有对数据进行操作的代码。</li><li>信息隐蔽： 管程是半透明的，管程中的外部过程（函数）实现了某些功能，至于这些功能怎么样实现的，其外部则是不可见的。</li></ol><p>管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接的访问管程中的共享变量，为了保证管程共享变量的数据完整性，规定管程互斥进入；管程通常是用来管理资源的，因而在管程中应当设有进程等待队以及相应的等待及唤醒操作。</p><p>任意时刻管程中只能有一个活跃进程，这个特性使管程能有效地完成互斥。当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程，如果有，调用进程将被挂起，直到另一个进程离开管程将其唤醒，如果没有活跃进程在使用管程，则该调用进程可以进入。</p><h3 id=管程中的条件变量><a href=#%e7%ae%a1%e7%a8%8b%e4%b8%ad%e7%9a%84%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f class=header-anchor></a>管程中的条件变量</h3><p>解决方法是引入条件变量以及相关的两个操作：wait和signal，当一个管程过程发现它无法继续运行时（例如：生产者发现缓冲区满），他会在某个条件变量（如full）上执行wait操作，该操作导致调用进程自身阻塞，并且还将另一个以前等在管程之外的进程调入管程，另一个进程，比如消费者，可以唤醒正在睡眠的伙伴进程，这可以通过对其伙伴正在等待的一个条件变量执行signal完成。</p><p>wait操作必须在signal之前，这条规则使得实现简单了许多，实际上这不是一个问题，因为需要时，用变量很容易跟踪每个进程的状态。</p><p>当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权每当一个进入管程的进程执行唤醒操作（如P唤醒Q）时，管程中便存在两个同时处于活动状态的进程。</p><p>处理方法：</p><ol><li>P等待Q继续，直到Q退出或等待（Hoare提出）。</li><li>Q等待P继续，直到P等待或退出。</li><li>规定唤醒为管程中最后一个可执行的操作。</li></ol><p>当一个进程试图进入一个已被占用的管程时它应当在管程的入口处等待，因而在管程的入口处应当由一个进程等待队列。在管程内部，由于执行唤醒操作，可能会出现多个进程等待队列，因而还需要有一个进程等待队列，这个等待队列被称为紧急等待队列，它的优先级应当高于入口等待队列的优先级signal(c)；如果c链为空，则相当于空操作，执行此操作的进程继续；否者幻想第一个等待者，执行此操作的进程的PCB入紧急等待队列的尾部。</p><h2 id=用管程解决生产者-消费则问题><a href=#%e7%94%a8%e7%ae%a1%e7%a8%8b%e8%a7%a3%e5%86%b3%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e5%88%99%e9%97%ae%e9%a2%98 class=header-anchor></a>用管程解决生产者-消费则问题</h2><h3 id=pthread中的互斥与同步><a href=#pthread%e4%b8%ad%e7%9a%84%e4%ba%92%e6%96%a5%e4%b8%8e%e5%90%8c%e6%ad%a5 class=header-anchor></a>Pthread中的互斥与同步</h3><p>Pthread提供了可用于线程同步与互斥的机制，他们是互斥量和条件变量，两者结合起来使用已达到管程的效果。</p><h3 id=互斥量及相关函数><a href=#%e4%ba%92%e6%96%a5%e9%87%8f%e5%8f%8a%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0 class=header-anchor></a>互斥量及相关函数</h3><p>解决线程互斥问题的基本思想是使用一个可以加锁和解锁的互斥量来保护临界区。一个进程如果想要进入临界区，他首先尝试锁住相关的互斥量。如果互斥量没有加锁，那么这个线程可以立即进入，并且该互斥量被自动锁定以防止其他进程进入。如果互斥量已经被加锁，则调用线程被阻塞，直到该互斥量被解锁。如果多个线程在等待同一个互斥量，当它被解锁时，这些等待的线程中只有一个得到互斥量并将其锁定。</p><h3 id=条件变量及相关函数><a href=#%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f%e5%8f%8a%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0 class=header-anchor></a>条件变量及相关函数</h3><p>除互斥量之外，Pthread提供了一种同步机制：条件变量，它允许线程由于一些为满足的条件而被阻塞。</p><p>让一个线程锁住一个互斥量，如果该线程不能获得它期望的结果时，则等待一个条件变量；最后另一个线程会向它发出信号，使它可以继续执行。</p><h2 id=通信进程><a href=#%e9%80%9a%e4%bf%a1%e8%bf%9b%e7%a8%8b class=header-anchor></a>通信进程</h2><p>P、V操作是一类低级通信原语，不能承担进程间大量信息的交换任务。</p><p>解决进程之间的大量信息通信问题有三个方案：共享内存、消息机制以及通过共享文件进行通信，即管道通信。他们不仅要保证相互制约的进程之间的正确关系，还要同时实现进程之间的信息交换。</p><h3 id=共享内存><a href=#%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98 class=header-anchor></a>共享内存</h3><p>在相互通信的进程之间设有一个公共内存区，一组进程向该公共内存中写，另一组进程中的读写互斥问题。操作系统一般只提供要共享的内存空间，而处理进程间在公共内存中的互斥关系则是程序开发人员的责任。</p><h3 id=消息机制><a href=#%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6 class=header-anchor></a>消息机制</h3><p>消息机制是用于进程间同行的高级通信原语之一。进程在运行过程中可能需要与其他的进程进行信息交流，于是进程通过某种手段发出自己的信息或接收其他进程发来的消息。这种方式类似于人们通过邮政局收发邮件来实现交换信息的目的。</p><h3 id=信息缓冲通信><a href=#%e4%bf%a1%e6%81%af%e7%bc%93%e5%86%b2%e9%80%9a%e4%bf%a1 class=header-anchor></a>信息缓冲通信</h3><p>基本思想：根据“生产者-消费者”原理，利用内存中共用消息缓冲区实现进程之间的信息交换。
内存中开辟了若干信息缓冲区，用于存放消息。</p><p>一个进程可以给若干个进程发送消息，反之，一个进程可以接受不同进程发来的消息，显然，进程中关于消息队列的操作是临界区，当发送进程正往接收进程的消息队列中添加一条消息时，接收进程不能同时从该消息队列中取出信息；反之也一样。</p><p>消息缓冲区通信机制包括以下几个内容：</p><ol><li>消息缓冲区：这是一个由消息长度、消息正文、发送者、消息队列指针组成的数据结构。</li><li>消息队列首指针：m_q,一般存在PCB中。</li><li>互斥信号量m_mutex,初始值为1.</li><li>同步信号量m_syn,初始值为0.</li><li>发送消息原语send(receiver, a)。</li><li>接收信息原语receive(a).</li></ol><h3 id=信箱通信><a href=#%e4%bf%a1%e7%ae%b1%e9%80%9a%e4%bf%a1 class=header-anchor></a>信箱通信</h3><p>以发送信件以及接收回答新建为进程间通信的基本方式。</p><p>当一个进程希望与另一个进程通信时，就创建一个链接两个进程的信箱，发送进程把信件投入信箱，而接收进程可以在任何时刻取走信件。</p><p>一个新鲜的结构可有“信箱说明”和“信箱体”两部分组成。</p><p>有如下的数据结构：</p><ul><li>可存信件数 是在设立信箱时预先确定的，表明信箱的容量大小。</li><li>已有信件数 指出信箱中已有信件的数量。</li><li>可存信件的指针 指示当前可存入一封信的位置。该指针的初始值为指向可存第一封信的位置。</li></ul><p>为了实现信箱通信，必须提供相应的原语，如创建信箱原语、撤销信箱原语、发送信箱原语和接收信箱原语等。</p><p><img src=https://webp.debuginn.com/202304132249819.png loading=lazy alt=信箱通信></p><p>表示的是一个发送者和一个接收者单向通信的例子，在进程A发送信件之间，信箱中至少应该有空位置，可以存放信件，同样，在进程B接收信件之前，信箱中应该有信件，否则进程应该等待。</p><p>好处：发送方和接收方不必直接建立联系，没有处理时间上的限制。发送方可以在任何时间发信，接收方可以在任何时间收信。</p><p>由于发送方和接收方都是独立工作的，如果发的快而接受的慢，则信箱会溢出。相反，如果发的慢而收的快，则信箱会变空。</p><p>规则：</p><ol><li>若发送信件时信箱已经满了，则发送进程应被置为“等信箱”状态，直到信箱有空时才被释放。</li><li>若取信件时信箱中无信，则接收进程应被置成“等信件”状态，直到有信件时才被释放。</li></ol><h3 id=管道通信><a href=#%e7%ae%a1%e9%81%93%e9%80%9a%e4%bf%a1 class=header-anchor></a>管道通信</h3><p>管道通信首先出现在UNIX操作系统中。</p><p>管道：就是连接在两个进程之间的一个打开的共享文件，专用于进程之间进行数据通信。发送进程可以源源不断的从管道一端写入数据流，每次写入的信息长度是可变的，接受进程在需要时可以从管道的另一端读出数据，读出单位长度也是可变的。管道通信的基础是文件系统。</p><p>在对管道文件进行读写操作的过程中，发送进程和接收进程都要实施正确的同步和互斥，以确保通信的正确性，管道通信机制中的同步与互斥都由操作系统自动进行，对用户是透明的。</p><p>具有传送数据量大的优点，但是通信速度比较慢。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/os/>Os</a>
<a href=/tags/system/>System</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>本作品采用知识共享署名 - 非商业性使用 - 相同方式共享 4.0 许可协议进行许可，商业转载请联系授权。</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/os-file-manage-files/><div class=article-image><img src=https://webp.debuginn.com/202302221853276.jpg loading=lazy data-key data-hash=https://webp.debuginn.com/202302221853276.jpg></div><div class=article-details><h2 class=article-title>操作系统 文件管理 文件的结构</h2></div></a></article><article class=has-image><a href=/p/os-file-manage/><div class=article-image><img src=https://webp.debuginn.com/202302221853276.jpg loading=lazy data-key data-hash=https://webp.debuginn.com/202302221853276.jpg></div><div class=article-details><h2 class=article-title>操作系统 文件管理 概述</h2></div></a></article><article class=has-image><a href=/p/os-memory-manage-virtual-storage/><div class=article-image><img src=https://webp.debuginn.com/202302221853276.jpg loading=lazy data-key data-hash=https://webp.debuginn.com/202302221853276.jpg></div><div class=article-details><h2 class=article-title>操作系统 内存管理 虚拟存储技术与虚拟页式存储管理方案的实现</h2></div></a></article><article class=has-image><a href=/p/os-memory-manage-page-storage/><div class=article-image><img src=https://webp.debuginn.com/202302221853276.jpg loading=lazy data-key data-hash=https://webp.debuginn.com/202302221853276.jpg></div><div class=article-details><h2 class=article-title>操作系统 内存管理 页式存储管理方案</h2></div></a></article><article class=has-image><a href=/p/os-memory-manage-cover-switch/><div class=article-image><img src=https://webp.debuginn.com/202302221853276.jpg loading=lazy data-key data-hash=https://webp.debuginn.com/202302221853276.jpg></div><div class=article-details><h2 class=article-title>操作系统 内存管理 覆盖与交换技术</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=debuginn/blog data-repo-id=R_kgDOI_rNgg data-category=General data-category-id=DIC_kwDOI_rNgs4CUT4j data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark")}})()</script><footer class=site-footer><section class=copyright>&copy;
2017 -
2025 Debug客栈</section><section class=powerby><a href=https://debuginn.com>主页</a>&nbsp;·&nbsp<a href=https://blog.debuginn.com/>博客</a>&nbsp;·&nbsp<a href=https://photo.debuginn.com>摄影</a>&nbsp;·&nbsp<a href=/subscribe/>订阅</a>&nbsp;·&nbsp<a href=/project/>项目</a>&nbsp;·&nbsp<a href=/use/>使用</a>&nbsp;·&nbsp<a href=/reward/>赞赏</a>&nbsp;·&nbsp<a href=/about/>关于</a><br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.31.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script defer src=https://cloud.umami.is/script.js data-website-id=fe36cfb2-8a2b-4457-a3e9-961f7d732026></script><script>(function(){var e=document.createElement("script");e.async=!0,e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7167312285165454",e.crossOrigin="anonymous",e.onload=function(){(adsbygoogle=window.adsbygoogle||[]).push({})},e.onTimeout=function(){console.error("Google AdSense脚本加载超时")},e.onerror=function(){console.error("Google AdSense脚本加载失败")},document.head.appendChild(e)})()</script></body></html>