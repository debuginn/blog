<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Restful Api on Debug客栈</title><link>https://blog.debuginn.com/tags/restful-api/</link><follow_challenge><feedId>41458948890269701</feedId><userId>55093859933428736</userId></follow_challenge><description>Recent content in Restful Api on Debug客栈</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 13 Mar 2022 21:35:12 +0800</lastBuildDate><atom:link href="https://blog.debuginn.com/tags/restful-api/index.xml" rel="self" type="application/rss+xml"/><item><title>Restful API 设计指北</title><link>https://blog.debuginn.com/p/design-restful-api/</link><pubDate>Sun, 13 Mar 2022 21:35:12 +0800</pubDate><guid>https://blog.debuginn.com/p/design-restful-api/</guid><description>&lt;img src="https://webp.debuginn.com/202303132137265.jpg" alt="Featured image of post Restful API 设计指北" /&gt;&lt;p&gt;近期学习了 Go 语言，跟着七米在学习，学习过程中了解到了 API 的一个设计规范，也就是本文要讲的 Restful API 设计模式，现在互联网处在前后端分离的阶段，API 的书写及规范化是非常重要的，针对于 API 中 Restful API 中设计比较规范的是 Github API，可以直接访问他们的 &lt;a class="link" href="https://api.github.com" target="_blank" rel="noopener"
&gt;https://api.github.com&lt;/a&gt; 直接查看 Github 针对与公共接口的链接及使用方法。&lt;/p&gt;
&lt;p&gt;此篇文章也是针对于这几天学习 Restful API 做了一个笔记或小结，若有不足之处还望批评指正，谢谢。&lt;/p&gt;
&lt;h2 id="使用-https-协议"&gt;&lt;a href="#%e4%bd%bf%e7%94%a8-https-%e5%8d%8f%e8%ae%ae" class="header-anchor"&gt;&lt;/a&gt;使用 HTTPS 协议
&lt;/h2&gt;&lt;p&gt;这个协议使用本身与这个 API 设计标准没有什么直接联系，使用 HTTPS 协议主要目的是将用户客户端与 API 服务器连接过程中保证其数据的安全性。&lt;/p&gt;
&lt;p&gt;注意：由于 API 接口使用 HTTPS 协议，&lt;strong&gt;不要让非 SSL 的链接访问重定向到 SSL 的链接&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="api-地址和版本问题"&gt;&lt;a href="#api-%e5%9c%b0%e5%9d%80%e5%92%8c%e7%89%88%e6%9c%ac%e9%97%ae%e9%a2%98" class="header-anchor"&gt;&lt;/a&gt;API 地址和版本问题
&lt;/h2&gt;&lt;p&gt;为 API 使用专门子域名比较友好，例如使用如下链接使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;https://api.debuginn.com
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;也可以将 API 放在主域名下，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;https://debuginn.com/api/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然，针对于 API 版本问题针对以上两种方法可以分别使用如下例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 针对于 API 子域名方式 api.domain/v1/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;https://api.debuginn.com/v1/
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 针对于 主域名目录方式 domain/api/v1/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;https://debuginn.com/api/v1/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="schema-响应数据模式"&gt;&lt;a href="#schema-%e5%93%8d%e5%ba%94%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%bc%8f" class="header-anchor"&gt;&lt;/a&gt;Schema 响应数据模式
&lt;/h2&gt;&lt;p&gt;现在前后端分离项目使用的数据响应模式大部分采用的是 JSON 格式数据，也有一些项目采用 XML 格式的数据。&lt;/p&gt;
&lt;p&gt;针对于用户客户端请求，服务器响应尽量有 状态码 Status Code 及详细解释。&lt;/p&gt;
&lt;h2 id="使用正确的-method"&gt;&lt;a href="#%e4%bd%bf%e7%94%a8%e6%ad%a3%e7%a1%ae%e7%9a%84-method" class="header-anchor"&gt;&lt;/a&gt;使用正确的 Method
&lt;/h2&gt;&lt;p&gt;使用正确的 Method 也就是使用正确的 HTTP 请求动词，即 HTTP 协议规定的常常使用的六种请求动词，并针对请求 SQL 语句辅助理解：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;GET 请求 =&amp;gt; SELECT 从服务端获取数据
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;POST 请求 =&amp;gt; CREATE 从服务端创建数据
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;PUT 请求 =&amp;gt; UPDATE 从服务端更新数据（将所有数据元素全部替换掉）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;PATCH 请求 =&amp;gt; UPDATE 从服务端更新数据（将部分数据元素替换掉）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;DELETE请求 =&amp;gt; DELETE 从服务端删除数据
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;还有两个不常使用的请求：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;HEAD 获取资源的元数据。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;OPTIONS 获取信息，关于资源的哪些属性是客户端可以改变的。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;注意：更新和创建操作应该返回最新的资源，来通知用户资源的情况；删除资源一般不会返回内容。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="过滤信息"&gt;&lt;a href="#%e8%bf%87%e6%bb%a4%e4%bf%a1%e6%81%af" class="header-anchor"&gt;&lt;/a&gt;过滤信息
&lt;/h2&gt;&lt;p&gt;针对用户端查询数据，需要服务端查询对应数据，包括了筛选、分页等操作。&lt;/p&gt;
&lt;h3 id="筛选操作"&gt;&lt;a href="#%e7%ad%9b%e9%80%89%e6%93%8d%e4%bd%9c" class="header-anchor"&gt;&lt;/a&gt;筛选操作
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;api.domain/user/limit/10 指定返回记录的数量;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;api.domain/user/offset/10 指定返回记录的开始位置;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;api.domain/user/animal_type_id/1 指定筛选条件
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;api.domain/user/page/2/per_page/100 指定第几页，以及每页的记录数;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;api.domain/user/sortby/name/order/asc 指定返回结果按照哪个属性排序，以及排序顺序
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="分页操作"&gt;&lt;a href="#%e5%88%86%e9%a1%b5%e6%93%8d%e4%bd%9c" class="header-anchor"&gt;&lt;/a&gt;分页操作
&lt;/h3&gt;&lt;p&gt;当返回某个资源的列表时，如果要返回的数目特别多，比如 github 的 &lt;code&gt;/users&lt;/code&gt;，就需要使用分页分批次按照需要来返回特定数量的结果。&lt;/p&gt;
&lt;p&gt;分页的实现会用到上面提到的 url query，通过两个参数来控制要返回的资源结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;per_page：每页返回多少资源，如果没提供会使用预设的默认值；这个数量也是有一个最大值，不然用户把它设置成一个非常大的值（比如99999999）也失去了设计的初衷。&lt;/li&gt;
&lt;li&gt;page：要获取哪一页的资源，默认是第一页。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="状态码-status-code"&gt;&lt;a href="#%e7%8a%b6%e6%80%81%e7%a0%81-status-code" class="header-anchor"&gt;&lt;/a&gt;状态码 Status Code
&lt;/h2&gt;&lt;p&gt;HTTP 应答中，需要带一个很重要的字段：status code。它说明了请求的大致情况，是否正常完成、需要进一步处理、出现了什么错误，对于客户端非常重要。状态码都是三位的整数，大概分成了几个区间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2XX：请求正常处理并返回&lt;/li&gt;
&lt;li&gt;3XX：重定向，请求的资源位置发生变化&lt;/li&gt;
&lt;li&gt;4XX：客户端发送的请求有错误&lt;/li&gt;
&lt;li&gt;5XX：服务器端错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 HTTP API 设计中，经常用到的状态码以及它们的意义如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态码&lt;/th&gt;
&lt;th&gt;LABEL&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;请求成功接收并处理，一般响应中都会有 body&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;201&lt;/td&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;请求已完成，并导致了一个或者多个资源被创建，最常用在 POST 创建资源的时候&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;202&lt;/td&gt;
&lt;td&gt;Accepted&lt;/td&gt;
&lt;td&gt;请求已经接收并开始处理，但是处理还没有完成。一般用在异步处理的情况，响应 body 中应该告诉客户端去哪里查看任务的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;204&lt;/td&gt;
&lt;td&gt;No Content&lt;/td&gt;
&lt;td&gt;请求已经处理完成，但是没有信息要返回，经常用在 PUT 更新资源的时候（客户端提供资源的所有属性，因此不需要服务端返回）。如果有重要的 metadata，可以放到头部返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;Moved Permanently&lt;/td&gt;
&lt;td&gt;请求的资源已经永久性地移动到另外一个地方，后续所有的请求都应该直接访问新地址。服务端会把新地址写在 &lt;code&gt;Location&lt;/code&gt; 头部字段，方便客户端使用。允许客户端把 POST 请求修改为 GET。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;Not Modified&lt;/td&gt;
&lt;td&gt;请求的资源和之前的版本一样，没有发生改变。用来缓存资源，和条件性请求（conditional request）一起出现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;307&lt;/td&gt;
&lt;td&gt;Temporary Redirect&lt;/td&gt;
&lt;td&gt;目标资源暂时性地移动到新的地址，客户端需要去新地址进行操作，但是不能修改请求的方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;308&lt;/td&gt;
&lt;td&gt;Permanent Redirect&lt;/td&gt;
&lt;td&gt;和 301 类似，除了客户端不能修改原请求的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;Bad Request&lt;/td&gt;
&lt;td&gt;客户端发送的请求有错误（请求语法错误，body 数据格式有误，body 缺少必须的字段等），导致服务端无法处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;Forbidden&lt;/td&gt;
&lt;td&gt;服务器端接收到并理解客户端的请求，但是客户端的权限不足。比如，普通用户想操作只有管理员才有权限的资源。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not Found&lt;/td&gt;
&lt;td&gt;客户端要访问的资源不存在，链接失效或者客户端伪造 URL 的时候会遇到这个情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;405&lt;/td&gt;
&lt;td&gt;Method Not Allowed&lt;/td&gt;
&lt;td&gt;服务端接收到了请求，而且要访问的资源也存在，但是不支持对应的方法。服务端必须返回&lt;code&gt;Allow&lt;/code&gt;头部，告诉客户端哪些方法是允许的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;415&lt;/td&gt;
&lt;td&gt;Unsupported Media Type&lt;/td&gt;
&lt;td&gt;服务端不支持客户端请求的资源格式，一般是因为客户端在&lt;code&gt;Content-Type&lt;/code&gt;或者&lt;code&gt;Content-Encoding&lt;/code&gt;中申明了希望的返回格式，但是服务端没有实现。比如，客户端希望收到xml返回，但是服务端支持Json&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;429&lt;/td&gt;
&lt;td&gt;Too Many Requests&lt;/td&gt;
&lt;td&gt;客户端在规定的时间里发送了太多请求，在进行限流的时候会用到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internal Server Error&lt;/td&gt;
&lt;td&gt;服务器内部错误，导致无法完成请求的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;503&lt;/td&gt;
&lt;td&gt;Service Unavailable&lt;/td&gt;
&lt;td&gt;服务器因为负载过高或者维护，暂时无法提供服务。服务器端应该返回 Retry-After 头部，告诉客户端过一段时间再来重试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;针对于状态码，请看此文章：&lt;a class="link" href="https://blog.debuginn.com/p/http-status-code/" target="_blank" rel="noopener"
&gt;HTTP常见状态码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="错误处理"&gt;&lt;a href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" class="header-anchor"&gt;&lt;/a&gt;错误处理
&lt;/h2&gt;&lt;p&gt;如果出错的话，在 response body 中通过 &lt;code&gt;message&lt;/code&gt; 给出明确的信息。&lt;/p&gt;
&lt;p&gt;比如客户端发送的请求有错误，一般会返回4XX Bad Request结果。这个结果很模糊，给出错误 message 的话，能更好地让客户端知道具体哪里有问题，进行快速修改。&lt;/p&gt;
&lt;p&gt;如果请求的 JSON 数据无法解析，会返回Problems parsing JSON；&lt;/p&gt;
&lt;p&gt;如果缺少必要的 filed，会返回422 Unprocessable Entity，除了 message 之外，还通过errors给出了哪些 field 缺少了，能够方便调用方快速排错。&lt;/p&gt;
&lt;p&gt;基本的思路就是尽可能提供更准确的错误信息：比如数据不是正确的 json，缺少必要的字段，字段的值不符合规定…… 而不是直接说“请求错误”之类的信息。&lt;/p&gt;
&lt;h2 id="验证及授权"&gt;&lt;a href="#%e9%aa%8c%e8%af%81%e5%8f%8a%e6%8e%88%e6%9d%83" class="header-anchor"&gt;&lt;/a&gt;验证及授权
&lt;/h2&gt;&lt;p&gt;一般来说，让任何人随意访问公开的 API 是不好的做法。验证和授权是两件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证（Authentication）是为了确定用户是其声明的身份，比如提供账户的密码。不然的话，任何人伪造成其他身份（比如其他用户或者管理员）是非常危险的&lt;/li&gt;
&lt;li&gt;授权（Authorization）是为了保证用户有对请求资源特定操作的权限。比如用户的私人信息只能自己能访问，其他人无法看到；有些特殊的操作只能管理员可以操作，其他用户有只读的权限等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有通过验证（提供的用户名和密码不匹配，token 不正确等），需要返回&lt;code&gt;401 Unauthorized&lt;/code&gt;状态码，并在 body 中说明具体的错误信息；而没有被授权访问的资源操作，需要返回&lt;code&gt;403 Forbidden&lt;/code&gt;状态码，还有详细的错误信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：对某些用户未被授权访问的资源操作返回&lt;code&gt;404 Not Found&lt;/code&gt;，目的是为了防止私有资源的泄露（比如黑客可以自动化试探用户的私有资源，返回 403 的话，就等于告诉黑客用户有这些私有的资源，无异于是给黑客提供了方向）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="hypermedia-api"&gt;&lt;a href="#hypermedia-api" class="header-anchor"&gt;&lt;/a&gt;Hypermedia API
&lt;/h2&gt;&lt;p&gt;RESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。&lt;/p&gt;
&lt;p&gt;比如访问 api.github.com，就可以看到 Github API 支持的资源操作。&lt;/p&gt;
&lt;h2 id="易读的-api-接口文档"&gt;&lt;a href="#%e6%98%93%e8%af%bb%e7%9a%84-api-%e6%8e%a5%e5%8f%a3%e6%96%87%e6%a1%a3" class="header-anchor"&gt;&lt;/a&gt;易读的 API 接口文档
&lt;/h2&gt;&lt;p&gt;API 最终是给人使用的，不管是公司内部，还是公开的 API 都是一样。即使我们遵循了上面提到的所有规范，设计的 API 非常优雅，用户还是不知道怎么使用我们的 API。最后一步，但非常重要的一步是：为你的 API 编写优秀的文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：对每个请求以及返回的参数给出说明，最好给出一个详细而完整的示例。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="参考资料"&gt;&lt;a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="header-anchor"&gt;&lt;/a&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener"
&gt;RESTful API 设计指南 - 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://cizixs.com/2016/12/12/restful-api-design-guide/" target="_blank" rel="noopener"
&gt;跟着 Github 学习 Restful HTTP API 设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://restfulapi.net/" target="_blank" rel="noopener"
&gt;REST API Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener"
&gt;Representational State Transfer (REST) - Roy Fielding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;p&gt;关注微信公众号，第一时间获取最新内容，让我们一起变得更强！&lt;/p&gt;&lt;p&gt;&lt;img src="https://static.debuginn.com/20241111FZS0zY.png" alt="wechat" /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Debug客栈：&lt;/strong&gt;&lt;a href="https://blog.debuginn.com/subscribe"&gt;订阅本站&lt;/a&gt;· &lt;a href="https://blog.debuginn.com/archives"&gt;文章归档&lt;/a&gt;· &lt;a href="https://blog.debuginn.com/project"&gt;我的项目&lt;/a&gt;· &lt;a href="https://blog.debuginn.com/links"&gt;友情链接&lt;/a&gt;· &lt;a href="https://blog.debuginn.com/use"&gt;我的使用&lt;/a&gt;· &lt;a href="https://photo.debuginn.com"&gt;摄影展集&lt;/a&gt;· &lt;a href="https://debuginn.com"&gt;我的主页&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>