[{"categories":["git"],"content":"常规操作 git push origin test 推送本地分支到远程仓库 git rm -r --cached 文件/文件夹名字 取消文件被版本控制 git reflog 获取执行过的命令 git log --graph 查看分支合并图 git merge --no-ff -m '合并描述' 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录 git check-ignore -v 文件名 查看忽略规则 git add -f 文件名 强制将文件提交 ","date":"2023-03-25","objectID":"/git-command/:1:0","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["git"],"content":"git 创建项目仓库 git init 初始化 git remote add origin url 关联远程仓库 git pull git fetch 获取远程仓库中所有的分支到本地 ","date":"2023-03-25","objectID":"/git-command/:1:1","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["git"],"content":"忽略已加入到版本库中的文件 git update-index --assume-unchanged file 忽略单个文件 git rm -r --cached 文件/文件夹名字 (. 忽略全部文件) ","date":"2023-03-25","objectID":"/git-command/:1:2","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["git"],"content":"取消忽略文件 git update-index --no-assume-unchanged file ","date":"2023-03-25","objectID":"/git-command/:1:3","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["git"],"content":"拉取、上传免密码 git config --global credential.helper store ","date":"2023-03-25","objectID":"/git-command/:1:4","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["git"],"content":"分支操作 git branch 创建分支 git branch -b 创建并切换到新建的分支上 git checkout 切换分支 git branch 查看分支列表 git branch -v 查看所有分支的最后一次操作 git branch -vv 查看当前分支 git brabch -b 分支名 origin/分支名 创建远程分支到本地 git branch --merged 查看别的分支和当前分支合并过的分支 git branch --no-merged 查看未与当前分支合并的分支 git branch -d 分支名 删除本地分支 git branch -D 分支名 强行删除分支 git branch origin :分支名 删除远处仓库分支 git merge 分支名 合并分支到当前分支上 ","date":"2023-03-25","objectID":"/git-command/:2:0","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["git"],"content":"暂存操作 git stash 暂存当前修改 git stash apply 恢复最近的一次暂存 git stash pop 恢复暂存并删除暂存记录 git stash list 查看暂存列表 git stash drop 暂存名(例：stash@{0}) 移除某次暂存 git stash clear 清除暂存 ","date":"2023-03-25","objectID":"/git-command/:3:0","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["git"],"content":"回退操作 git reset --hard HEAD^ 回退到上一个版本 git reset --hard ahdhs1(commit_id) 回退到某个版本 git checkout -- file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态) git reset HEAD file 撤回暂存区的文件修改到工作区 ","date":"2023-03-25","objectID":"/git-command/:4:0","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["git"],"content":"标签操作 git tag 标签名 添加标签(默认对当前版本) git tag 标签名 commit_id 对某一提交记录打标签 git tag -a 标签名 -m '描述' 创建新标签并增加备注 git tag 列出所有标签列表 git show 标签名 查看标签信息 git tag -d 标签名 删除本地标签 git push origin 标签名 推送标签到远程仓库 git push origin --tags 推送所有标签到远程仓库 git push origin :refs/tags/标签名 从远程仓库中删除标签 ","date":"2023-03-25","objectID":"/git-command/:5:0","tags":["git"],"title":"Git常用命令汇总","uri":"/git-command/"},{"categories":["pwa"],"content":"简介 PWA是Progressive Web App的简称，是谷歌提出的新型Web技术，并由W3C及谷歌来推广这项技术，其主要目的是为了提升用户对网站原生使用体验，同时又能节省对网站的开启速度。 在我们国内，类似于PWA的技术可以简单地理解为微信主导的小程序，不过小程序的使用需要进行微信小程序前端重构开发，而渐进式Web应用程序开发只需要运用现代Web API以及传统渐进式式策略来构建网站的方式。 ","date":"2023-03-18","objectID":"/web-pwa-program/:1:0","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["pwa"],"content":"特点 由于这项技术是谷歌提出的，目前谷歌系的浏览器都支持PWA， 官方说有三个特点，分别是： 可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现 体验 - 快速响应，并且有平滑的动画响应用户的操作 粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面 而我感觉使用这个技术最大的特点就是将网站缓存下来，开启网站只需要0.3秒之内，使得网站加载速度异常地快，同时对用户非常友好，增添其用户交互性。 ","date":"2023-03-18","objectID":"/web-pwa-program/:2:0","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["pwa"],"content":"应用 近期对网站进行了PWA升级，只是用一个简单的插件就实现了对网站的APP转化，在开启我的网站的同时，在搜索栏会有加号提醒添加至桌面，如下图： 若是对我的网站感兴趣，可以点击按钮安装PWA，不用安装APP即可获取本站服务，若是手机用户可以在出现的将此页面发送至桌面来进行订阅。 ","date":"2023-03-18","objectID":"/web-pwa-program/:3:0","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["pwa"],"content":"功能 ","date":"2023-03-18","objectID":"/web-pwa-program/:4:0","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["pwa"],"content":"离线和缓存 Service Worker 这项技术主要是解决JS单线程问题，为了减少对浏览器网页开启峰值，页面加载问题。 浏览器中的 javaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，我们逐渐在 js 中加了很多耗资源、耗时间的复杂运算过程，这些过程导致的性能问题在 WebApp 的复杂化过程中更加凸显出来。 什么是 Service Worker Service Worker 有以下功能和特性： 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。 一旦被 install，就永远存在，除非被手动 unregister 用到的时候可以直接唤醒，不用的时候自动睡眠 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态） 离线内容开发者可控 能向客户端推送消息 不能直接操作 DOM 必须在 HTTPS 环境下才能工作 异步实现，内部大都是通过 Promise 实现 Web存储 选择正确的存储机制对于本地设备存储和基于云的服务器存储都非常重要。 良好的存储引擎可确保以可靠的方式保存信息，并减少带宽和提升响应能力。正确的存储缓存策略是实现离线移动网页体验的核心构建基块。 存储分类分为：数据模型、持久化、浏览器支持、事务处理、同步/异步。 ","date":"2023-03-18","objectID":"/web-pwa-program/:4:1","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["pwa"],"content":"强黏贴用户 将站点添加至屏幕 为了吸引并留住用户，不仅仅自己网站需要比较高质量的文章，良好的交互，还需要一些营销手段增强网站的曝光度，提升与用户的交互。 如果用户对你的网站比较感兴趣，最好的方式将站点添加到主屏幕，不但可以省去用户开启浏览器的操作，提高其转化率，这样就可以对用户强黏贴了。 消息通知 使用 service worker 的功能之一：通知 (notification)，它允许服务器向用户提示一些信息，并根据用户不同的行为进行一些简单的处理。 ","date":"2023-03-18","objectID":"/web-pwa-program/:4:2","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["pwa"],"content":"用户自动登录 账户是网站必不可少的组成部分。账户体系的存在，可以让网站给用户提供分级服务，同时网站也能够通过收集用户行为实现精准推送。但账号的存在将使得用户不得不多出一步登录的步骤，要知道根据“漏斗模型”理论，从起点到终点，每个环节都会产生用户的流失，依次递减。因此想办法省去烦人的账号密码输入过程，不但能提高用户体验，也能够提高网站转化率。 记住网站传统密码形式； 凭证管理，第三方登陆验证。 ","date":"2023-03-18","objectID":"/web-pwa-program/:4:3","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["pwa"],"content":"网络安全 Web安全； 使用SSL 即 Https； 同源策略； 典型的安全漏洞； CSP（内容安全策略）。 详细内容请移步查看：https://lavas.baidu.com/pwa/web-security/introduction ","date":"2023-03-18","objectID":"/web-pwa-program/:4:4","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["pwa"],"content":"参考文章 什么是PWA | PWA 文档| Lavas 简单介绍一下Progressive Web App(PWA) 渐进式Web 应用（PWA） | MDN 讲讲PWA - 前端学习- SegmentFault 思否 Progressive Web Apps ","date":"2023-03-18","objectID":"/web-pwa-program/:5:0","tags":["web","pwa"],"title":"PWA 渐进式Web应用程序","uri":"/web-pwa-program/"},{"categories":["project"],"content":"🤠 Hi，我是 Meng小羽 ","date":"2023-03-17","objectID":"/pages/project/:1:0","tags":["GO","Go博客","技术博客","Debug客栈","debug客栈","Debuginn","debuginn","project"],"title":"我的项目","uri":"/pages/project/"},{"categories":["project"],"content":"Github Github Status Top languages ","date":"2023-03-17","objectID":"/pages/project/:1:1","tags":["GO","Go博客","技术博客","Debug客栈","debug客栈","Debuginn","debuginn","project"],"title":"我的项目","uri":"/pages/project/"},{"categories":["project"],"content":"项目 ","date":"2023-03-17","objectID":"/pages/project/:1:2","tags":["GO","Go博客","技术博客","Debug客栈","debug客栈","Debuginn","debuginn","project"],"title":"我的项目","uri":"/pages/project/"},{"categories":["mysql"],"content":"在关系型数据库中，悲观锁与乐观锁是解决资源并发场景的解决方案，接下来将详细讲解?一下这两个并发解决方案的实际使用及优缺点。 首先定义一下数据库，做一个最简单的库存表，如下设计： CREATE TABLE `order_stock` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID', `oid` int(50) NOT NULL COMMENT '商品ID', `quantity` int(20) NOT NULL COMMENT '库存', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; quantity代表着不同商品 oid 的库存，接下来 OCC 及 PCC 使用此数据库进行演示。 ","date":"2023-03-16","objectID":"/mysql-lock-occ-pcc/:0:0","tags":["mysql","occ","pcc"],"title":"浅析悲观锁与乐观锁","uri":"/mysql-lock-occ-pcc/"},{"categories":["mysql"],"content":"乐观锁 OCC 它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。 即“乐观锁?”认为拿锁的用户多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。这样就可以避免使用数据库自身定义的行锁，可以避免死锁现象的产生。 UPDATE order_stock SET quantity = quantity - 1 WHERE oid = 1 AND quantity - 1 \u003e 0; 乐观并发控制多数用于数据争用不大、冲突较少的环境中，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。 ","date":"2023-03-16","objectID":"/mysql-lock-occ-pcc/:1:0","tags":["mysql","occ","pcc"],"title":"浅析悲观锁与乐观锁","uri":"/mysql-lock-occ-pcc/"},{"categories":["mysql"],"content":"悲观锁 PCC 它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。 这种设计采用了“一锁二查三更新”模式，就是采用数据库中自带 select ... for update 关键字进行对当前事务添加行级锁? 先将要操作的数据进行锁上，之后执行对应查询数据并执行更新操作。 BEGIN SELECT quantity FROM order_stock WHERE oid = 1 FOR UPDATE; UPDATE order_stock SET quantity = 2 WHERE oid = 1; COMMIT; MySQL还有个问题是select ... for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 ","date":"2023-03-16","objectID":"/mysql-lock-occ-pcc/:2:0","tags":["mysql","occ","pcc"],"title":"浅析悲观锁与乐观锁","uri":"/mysql-lock-occ-pcc/"},{"categories":["mysql"],"content":"OCC 和 PCC 优缺点 ","date":"2023-03-16","objectID":"/mysql-lock-occ-pcc/:3:0","tags":["mysql","occ","pcc"],"title":"浅析悲观锁与乐观锁","uri":"/mysql-lock-occ-pcc/"},{"categories":["mysql"],"content":"OCC 优点及缺点 【优点】 乐观锁相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁； 可以快速响应事务，随着并发量增加，但会出现大量回滚出现； 效率高，但是要控制好锁的力度。 【缺点】 如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题； 随着并发量增加，但会出现大量回滚出现。 ","date":"2023-03-16","objectID":"/mysql-lock-occ-pcc/:3:1","tags":["mysql","occ","pcc"],"title":"浅析悲观锁与乐观锁","uri":"/mysql-lock-occ-pcc/"},{"categories":["mysql"],"content":"PCC 优点及缺点 【优点】 “先取锁再访问”的保守策略，为数据处理的安全提供了保证； 【缺点】 依赖数据库锁，效率低； 处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会； 降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。 ","date":"2023-03-16","objectID":"/mysql-lock-occ-pcc/:4:0","tags":["mysql","occ","pcc"],"title":"浅析悲观锁与乐观锁","uri":"/mysql-lock-occ-pcc/"},{"categories":["mysql"],"content":"References 【MySQL】悲观锁\u0026乐观锁 LearnKu 浅析乐观锁与悲观锁 维基百科 悲观并发控制 \u0026\u0026 乐观并发控制 ","date":"2023-03-16","objectID":"/mysql-lock-occ-pcc/:5:0","tags":["mysql","occ","pcc"],"title":"浅析悲观锁与乐观锁","uri":"/mysql-lock-occ-pcc/"},{"categories":["git"],"content":"Gource 是一款版本控制可视化的工具，使用这个工具可以将自己的 Git 提交的代码包括对 Mercurial，Bazaar 和 SVN 的内置日志生成可视化支持。Gource 还可以解析由多个第三方工具为 CVS 存储库生成的日志。 提交的代码按照时间轴的顺序动态显示出来，可以使你的工作过程以动画的形式显现，并且 Gource 这个工具可以显示出来不同用户对一个代码库进行同一时间内的修改操作。 官方网站：https://gource.io/ ","date":"2023-03-16","objectID":"/linux-tools-gource/:0:0","tags":["git","gource"],"title":"Gource 版本可视化工具 使用手册","uri":"/linux-tools-gource/"},{"categories":["git"],"content":"常用命令 在这里我列举几个经常使用到的命令，PS：你需要先进入到对应项目目录中去，这个很重要，要不然会提示该目录下没有 log 记录。 gource # 使用Gource查看版本历史 gource -f -1280×720 # 设置分辨率大小 gource -s 0.5 # 每天以0.5秒的速度播放 gource -o 1.mp4 # 将版本动画导出到 1.mp4 文件中 gource -s 0.1 -o 2.mp4 # 每天以0.1秒的速度导出到 2.mp4 文件中 gource -f -b red # 将背景设置为红色 gource --title “Gource” # 为gource设置title ","date":"2023-03-16","objectID":"/linux-tools-gource/:1:0","tags":["git","gource"],"title":"Gource 版本可视化工具 使用手册","uri":"/linux-tools-gource/"},{"categories":["git"],"content":"基本命令 ➜ ~ gource -help Gource v0.51 Usage: gource [options] [path] 用法: gource [选项] [路径] Options: -h, --help 帮助 -WIDTHxHEIGHT, --viewport 设定窗口大小 -f, --fullscreen 全屏显示 --screen SCREEN 画面编号 --multi-sampling 启用多重采样 --no-vsync 禁用垂直同步 --start-date 'YYYY-MM-DD hh:mm:ss +tz' 从日期和可选时间开始 --stop-date 'YYYY-MM-DD hh:mm:ss +tz' 停在某个日期和可选时间 -p, --start-position POSITION 从某个位置开始(0.0-1.0 or 'random') --stop-position POSITION 停在某个位置 -t, --stop-at-time SECONDS 在指定的秒数后停止 --stop-at-end 在日志结尾处停止 --dont-stop 在日志结束后继续运行 --loop 在日志末尾循环 -a, --auto-skip-seconds SECONDS 如果没有任何反应，则自动跳至下一个条目 持续几秒钟(default: 3) --disable-auto-skip 禁用自动跳过 -s, --seconds-per-day SECONDS 每天以秒为单位的速度(default: 10) --realtime 实时播放速度 --no-time-travel 如果提交时间是过去的时间请使用上一次提交的时间 -c, --time-scale SCALE 更改模拟时间范围(default: 1.0) -e, --elasticity FLOAT 节点弹性(default: 0.0) --key 显示文件扩展名 --user-image-dir DIRECTORY 包含要用作头像的图像的目录 --default-user-image IMAGE 默认用户图像文件 --colour-images 使用单色图像 -i, --file-idle-time SECONDS 时间文件保持空闲(default: 0) --max-files NUMBER 最大文件数或0（无限制） --max-file-lag SECONDS 提交的最大时间文件可能会出现 --log-command VCS 显示VCS日志命令(git,svn,hg,bzr,cvs2cl) --log-format VCS 指定日志格式(git,svn,hg,bzr,cvs2cl,custom) --load-config CONF_FILE 加载配置文件 --save-config CONF_FILE 使用当前选项保存配置文件 -o, --output-ppm-stream FILE 将PPM流输出到文件 ('-' for STDOUT) -r, --output-framerate FPS 输出帧率(25,30,60) PATH可以是受支持的版本控制目录，日志文件，Gource配置文件或用于读取STDIN的'-'。 如果省略，则gource将尝试从当前目录生成日志。 要查看完整的命令行选项，请使用 “-H” ","date":"2023-03-16","objectID":"/linux-tools-gource/:2:0","tags":["git","gource"],"title":"Gource 版本可视化工具 使用手册","uri":"/linux-tools-gource/"},{"categories":["linux"],"content":"Tree 命令以树状形状列出目录的内容的一个工具，你时常在 Github 中常看到一些开源项目会将自己的项目目录展现出来，这篇文章的背景图就是展现的开源项目 Laravel 中 app 目录的树状图，接下来介绍一下基本使用语法。 ","date":"2023-03-15","objectID":"/linux-tree-command/:0:0","tags":["linux","unix","tree"],"title":"Linux Tree 树状目录显示工具 使用手册","uri":"/linux-tree-command/"},{"categories":["linux"],"content":"基本语法 tree [-aACdDfFgilnNpqstux][-I \u003c范本样式\u003e][-P \u003c范本样式\u003e][目录...] ","date":"2023-03-15","objectID":"/linux-tree-command/:1:0","tags":["linux","unix","tree"],"title":"Linux Tree 树状目录显示工具 使用手册","uri":"/linux-tree-command/"},{"categories":["linux"],"content":"常用命令 tree --help 显示帮助信息 tree -d 只显示目录 tree -L n 只显示第n层目录 tree -l 遵循像目录这样的符号链接 tree -f 打印每个文件的完整路径前缀 tree -x 只保留在当前文件系统上 tree -L 级下降深层级目录 tree -R 达到最大等级时重新运行树 tree -P 模式只列出符合给定模式的文件 tree -I 模式不要列出与给定模式匹配的文件 tree -o 文件名输出到文件而不是标准输出 ","date":"2023-03-15","objectID":"/linux-tree-command/:2:0","tags":["linux","unix","tree"],"title":"Linux Tree 树状目录显示工具 使用手册","uri":"/linux-tree-command/"},{"categories":["linux"],"content":"基本命令 [➜ ~ tree --help usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ] [-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]\u003cf\u003e] [--sort[=]\u003cname\u003e] [--matchdirs] [--ignore-case] [--fromfile] [--] [\u003c目录列表\u003e] ------- 上市选项 ------- -a 列出所有文件。 -d 仅列出目录。 -l 跟随目录等符号链接。 -f 打印每个文件的完整路径前缀。 -x 仅保留在当前文件系统上。 -L 级别仅下降级别级别的目录。 -R 当达到最大目录级别时，重新运行树。 -P 模式仅列出与给定模式匹配的那些文件。 -I 模式不列出与给定模式匹配的文件。 --ignore-case 模式匹配时忽略大小写。 --matchdirs 在-P模式匹配中包括目录名称。 --noreport 在树列表的末尾关闭文件/目录计数。 --charset X 将charset X用于终端/ HTML和缩进线输出。 --filelimit＃ 不要使包含超过＃个文件的dirs下降。 --timefmt \u003cf\u003e根据\u003cf\u003e格式打印和格式化时间。 -o filename 输出到文件而不是stdout。 ------- 文件选项 ------- -q 将不可打印的字符打印为'？'。 -N 按原样打印不可打印的字符。 -Q 引用双引号的文件名。 -p 打印每个文件的保护。 -u 显示文件所有者或UID号。 -g 显示文件组所有者或GID号。 -s 打印每个文件的大小（以字节为单位）。 -h 以更易于理解的方式打印尺寸。 --si 与-h类似，但以SI单位使用（1000的幂）。 -D 打印上次修改或（-c）状态更改的日期。 -F 附加'/'，'='，'*'，'@'，'|'或按ls -F的'\u003e'。 --inodes 打印每个文件的索引节点号。 --device 打印每个文件所属的设备ID号。 ------- 排序选项 ------- -v 按版本字母顺序对文件进行排序。 -t 按上次修改时间对文件排序。 -c 按上次状态更改时间对文件排序。 -U 不排序文件。 -r 颠倒排序顺序。 --dirsfirst 在文件之前列出目录（-U禁用）。 --sort X 选择排序：名称，版本，大小，mtime，ctime。 ------- 图形选项 ------- -i 不打印缩进线。 -A 打印ANSI线图形缩进线。 -S 使用CP437（控制台）图形缩进线打印。 -n 始终关闭着色（-C替代）。 -C 始终打开着色。 ------- XML / HTML / JSON选项 ------- -X 打印树的XML表示形式。 -J 打印树的JSON表示形式。 -H baseHREF打印出以baseHREF作为顶层目录的HTML格式。 -T 字符串用字符串替换默认的HTML标题和H1标头。 --nolinks 关闭HTML输出中的超链接。 ------- 输入选项 ------- --fromfile 从文件中读取路径（。= stdin） ------- 其他选项 ------- --version 打印版本并退出。 --help 打印用法和此帮助消息并退出。 -选项处理终止符。 ","date":"2023-03-15","objectID":"/linux-tree-command/:3:0","tags":["linux","unix","tree"],"title":"Linux Tree 树状目录显示工具 使用手册","uri":"/linux-tree-command/"},{"categories":["linux"],"content":"展示效果 ➜ app tree . ├── Console │ └── Kernel.php ├── Exceptions │ └── Handler.php ├── Http │ ├── Controllers │ │ ├── Auth │ │ │ ├── ForgotPasswordController.php │ │ │ ├── LoginController.php │ │ │ ├── RegisterController.php │ │ │ ├── ResetPasswordController.php │ │ │ └── VerificationController.php │ │ ├── Controller.php │ │ └── IndexController.php │ ├── Kernel.php │ └── Middleware │ ├── Authenticate.php │ ├── CheckForMaintenanceMode.php │ ├── EncryptCookies.php │ ├── RedirectIfAuthenticated.php │ ├── TrimStrings.php │ ├── TrustProxies.php │ └── VerifyCsrfToken.php ├── Providers │ ├── AppServiceProvider.php │ ├── AuthServiceProvider.php │ ├── BroadcastServiceProvider.php │ ├── EventServiceProvider.php │ └── RouteServiceProvider.php └── User.php 7 directories, 23 files ","date":"2023-03-15","objectID":"/linux-tree-command/:4:0","tags":["linux","unix","tree"],"title":"Linux Tree 树状目录显示工具 使用手册","uri":"/linux-tree-command/"},{"categories":["design"],"content":"近期学习了Go语言，跟着七米在学习，学习过程中了解到了 API 的一个设计规范，也就是本文要讲的 Restful API 设计模式，现在互联网处在前后端分离的阶段，API 的书写及规范化是非常重要的，针对于 API 中 Restful API 中设计比较规范的是 Github API，可以直接访问他们的 https://api.github.com 直接查看 Github 针对与公共接口的链接及使用方法。 此篇文章也是针对于这几天学习 Restful API 做了一个笔记或小结，若有不足之处还望批评指正，谢谢。 ","date":"2023-03-13","objectID":"/design-restful-api/:0:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"1 使用 HTTPS 协议 这个协议使用本身与这个 API 设计标准没有什么直接联系，使用 HTTPS 协议主要目的是将用户客户端与 API 服务器链接过程中保证其数据的安全性 ?。 注意：由于 API 接口使用 HTTPS 协议，不要让非 SSL 的链接访问重定向到 SSL 的链接。 ","date":"2023-03-13","objectID":"/design-restful-api/:1:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"2 API 地址和版本问题 为 API 使用专门子域名比较友好，例如使用如下链接使用： https://api.debuginn.cn 也可以将 API 放在主域名下，例如： https://debuginn.cn/api/ 当然，针对于 API 版本问题针对以上两种方法可以分别使用如下例子： # 针对于 API 子域名方式 api.domain/v1/ https://api.debuginn.cn/v1/ # 针对于 主域名目录方式 domain/api/v1/ https://debuginn.cn/api/v1/ ","date":"2023-03-13","objectID":"/design-restful-api/:2:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"3 Schema 响应数据模式 现在前后端分离项目使用的数据响应模式大部分采用的是 JSON 格式数据，也有一些项目采用 XML 格式的数据。 针对于用户客户端请求，服务器响应尽量有 状态码 Status Code 及详细解释。 ","date":"2023-03-13","objectID":"/design-restful-api/:3:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"4 使用正确的 Method 使用正确的 Method 也就是使用正确的 HTTP 请求动词，即 HTTP 协议规定的常常使用的六种请求动词，并针对请求 SQL 语句辅助理解： GET 请求 =\u003e SELECT 从服务端获取数据 POST 请求 =\u003e CREATE 从服务端创建数据 PUT 请求 =\u003e UPDATE 从服务端更新数据（将所有数据元素全部替换掉） PATCH 请求 =\u003e UPDATE 从服务端更新数据（将部分数据元素替换掉） DELETE请求 =\u003e DELETE 从服务端删除数据 还有两个不常使用的请求： HEAD 获取资源的元数据。 OPTIONS 获取信息，关于资源的哪些属性是客户端可以改变的。 注意：更新和创建操作应该返回最新的资源，来通知用户资源的情况；删除资源一般不会返回内容。 ","date":"2023-03-13","objectID":"/design-restful-api/:4:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"5 过滤信息 针对用户端查询数据，需要服务端查询对应数据，包括了筛选、分页等操作。 ","date":"2023-03-13","objectID":"/design-restful-api/:5:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"筛选操作 api.domain/user/limit/10 指定返回记录的数量; api.domain/user/offset/10 指定返回记录的开始位置; api.domain/user/animal_type_id/1 指定筛选条件 api.domain/user/page/2/per_page/100 指定第几页，以及每页的记录数; api.domain/user/sortby/name/order/asc 指定返回结果按照哪个属性排序，以及排序顺序 ","date":"2023-03-13","objectID":"/design-restful-api/:5:1","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"分页操作 当返回某个资源的列表时，如果要返回的数目特别多，比如 github 的 /users，就需要使用分页分批次按照需要来返回特定数量的结果。 分页的实现会用到上面提到的 url query，通过两个参数来控制要返回的资源结果： per_page：每页返回多少资源，如果没提供会使用预设的默认值；这个数量也是有一个最大值，不然用户把它设置成一个非常大的值（比如99999999）也失去了设计的初衷。 page：要获取哪一页的资源，默认是第一页。 ","date":"2023-03-13","objectID":"/design-restful-api/:5:2","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"6 状态码 Status Code HTTP 应答中，需要带一个很重要的字段：status code。它说明了请求的大致情况，是否正常完成、需要进一步处理、出现了什么错误，对于客户端非常重要。状态码都是三位的整数，大概分成了几个区间： 2XX：请求正常处理并返回 3XX：重定向，请求的资源位置发生变化 4XX：客户端发送的请求有错误 5XX：服务器端错误 在 HTTP API 设计中，经常用到的状态码以及它们的意义如下表： 状态码 LABEL 解释 200 OK 请求成功接收并处理，一般响应中都会有 body 201 Created 请求已完成，并导致了一个或者多个资源被创建，最常用在 POST 创建资源的时候 202 Accepted 请求已经接收并开始处理，但是处理还没有完成。一般用在异步处理的情况，响应 body 中应该告诉客户端去哪里查看任务的状态 204 No Content 请求已经处理完成，但是没有信息要返回，经常用在 PUT 更新资源的时候（客户端提供资源的所有属性，因此不需要服务端返回）。如果有重要的 metadata，可以放到头部返回 301 Moved Permanently 请求的资源已经永久性地移动到另外一个地方，后续所有的请求都应该直接访问新地址。服务端会把新地址写在 Location 头部字段，方便客户端使用。允许客户端把 POST 请求修改为 GET。 304 Not Modified 请求的资源和之前的版本一样，没有发生改变。用来缓存资源，和条件性请求（conditional request）一起出现 307 Temporary Redirect 目标资源暂时性地移动到新的地址，客户端需要去新地址进行操作，但是不能修改请求的方法。 308 Permanent Redirect 和 301 类似，除了客户端不能修改原请求的方法 400 Bad Request 客户端发送的请求有错误（请求语法错误，body 数据格式有误，body 缺少必须的字段等），导致服务端无法处理 403 Forbidden 服务器端接收到并理解客户端的请求，但是客户端的权限不足。比如，普通用户想操作只有管理员才有权限的资源。 404 Not Found 客户端要访问的资源不存在，链接失效或者客户端伪造 URL 的时候回遇到这个情况 405 Method Not Allowed 服务端接收到了请求，而且要访问的资源也存在，但是不支持对应的方法。服务端必须返回Allow头部，告诉客户端哪些方法是允许的 415 Unsupported Media Type 服务端不支持客户端请求的资源格式，一般是因为客户端在Content-Type或者Content-Encoding中申明了希望的返回格式，但是服务端没有实现。比如，客户端希望收到xml返回，但是服务端支持Json 429 Too Many Requests 客户端在规定的时间里发送了太多请求，在进行限流的时候会用到 500 Internal Server Error 服务器内部错误，导致无法完成请求的内容 503 Service Unavailable 服务器因为负载过高或者维护，暂时无法提供服务。服务器端应该返回 Retry-After 头部，告诉客户端过一段时间再来重试 针对于状态码，请看此文章：https://www.debuginn.cn/4027.html ","date":"2023-03-13","objectID":"/design-restful-api/:6:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"7 错误处理 如果出错的话，在 response body 中通过 message 给出明确的信息。 比如客户端发送的请求有错误，一般会返回4XX Bad Request结果。这个结果很模糊，给出错误 message 的话，能更好地让客户端知道具体哪里有问题，进行快速修改。 如果请求的 JSON 数据无法解析，会返回Problems parsing JSON； 如果缺少必要的 filed，会返回422 Unprocessable Entity，除了 message 之外，还通过errors给出了哪些 field 缺少了，能够方便调用方快速排错。 基本的思路就是尽可能提供更准确的错误信息：比如数据不是正确的 json，缺少必要的字段，字段的值不符合规定…… 而不是直接说“请求错误”之类的信息。 ","date":"2023-03-13","objectID":"/design-restful-api/:7:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"8 验证及授权 一般来说，让任何人随意访问公开的 API 是不好的做法。验证和授权是两件事情： 验证（Authentication）是为了确定用户是其申明的身份，比如提供账户的密码。不然的话，任何人伪造成其他身份（比如其他用户或者管理员）是非常危险的 授权（Authorization）是为了保证用户有对请求资源特定操作的权限。比如用户的私人信息只能自己能访问，其他人无法看到；有些特殊的操作只能管理员可以操作，其他用户有只读的权限等等 如果没有通过验证（提供的用户名和密码不匹配，token 不正确等），需要返回401 Unauthorized状态码，并在 body 中说明具体的错误信息；而没有被授权访问的资源操作，需要返回403 Forbidden状态码，还有详细的错误信息。 注意：对某些用户未被授权访问的资源操作返回404 Not Found，目的是为了防止私有资源的泄露（比如黑客可以自动化试探用户的私有资源，返回 403 的话，就等于告诉黑客用户有这些私有的资源，无异于是给黑客提供了方向）。 ","date":"2023-03-13","objectID":"/design-restful-api/:8:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"9 Hypermedia API RESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如访问 api.github.com，就可以看到 Github API 支持的资源操作。 ","date":"2023-03-13","objectID":"/design-restful-api/:9:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"10 易读的 API 接口文档 API 最终是给人使用的，不管是公司内部，还是公开的 API 都是一样。即使我们遵循了上面提到的所有规范，设计的 API 非常优雅，用户还是不知道怎么使用我们的 API。最后一步，但非常重要的一步是：为你的 API 编写优秀的文档。 注意：对每个请求以及返回的参数给出说明，最好给出一个详细而完整地示例。 ","date":"2023-03-13","objectID":"/design-restful-api/:10:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["design"],"content":"参考资料 RESTful API 设计指南 - 阮一峰 跟着 Github 学习 Restful HTTP API 设计 REST API Tutorial Representational State Transfer (REST) - Roy Fielding ","date":"2023-03-13","objectID":"/design-restful-api/:11:0","tags":["api","restful api"],"title":"Restful API 设计指北","uri":"/design-restful-api/"},{"categories":["project"],"content":"事情的起因是这样的，前几日在看 idealclover 大佬的博客，不经意间看到了他的豆瓣观影记录，他博客中关于豆瓣观影记录是实时同步的，很好奇是如何实现的，经过查看，他是爬取的豆瓣观影界面来实现的，其实关于豆瓣观影记录，网上也有很多的教程，恰巧自己所学的 Go 语言也可以做简单的爬虫实现其效果，于是开始上手造轮子了，PS：了解到非法爬取网站信息是违法的，之前豆瓣 API 接口，关闭访问，在豆瓣上找了好久，终于在我的主页中找到了对于观影记录的官方提供 RSS 订阅，打开订阅，看到有自己所需要的字段，比较好获取，于是就开始了此项目。 ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:0:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"分析 首先，需要获取豆瓣提供的 XML 文件，在我的主页右下角就可以看到 RSS 订阅链接： 找到了订阅地址，点击查看 XML 结构，可以看到豆瓣提供的结构还是挺理想的： \u003crss xmlns:content=\"http://purl.org/rss/1.0/modules/content/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" version=\"2.0\"\u003e \u003cchannel\u003e \u003ctitle\u003eMeng小羽 的收藏\u003c/title\u003e \u003clink\u003ehttps://www.douban.com/people/debuginn/\u003c/link\u003e \u003cdescription\u003e \u003c![CDATA[ Meng小羽 的收藏：想看、在看和看过的书和电影，想听、在听和听过的音乐 ]]\u003e \u003c/description\u003e \u003clanguage\u003ezh-cn\u003c/language\u003e \u003ccopyright\u003e© 2013, douban.com.\u003c/copyright\u003e \u003cpubDate\u003eSat, 30 May 2020 09:14:08 GMT\u003c/pubDate\u003e \u003citem\u003e \u003ctitle\u003e看过黑衣人：全球追缉\u003c/title\u003e \u003clink\u003ehttp://movie.douban.com/subject/19971676/\u003c/link\u003e \u003cdescription\u003e \u003c![CDATA[ \u003ctable\u003e\u003ctr\u003e \u003ctd width=\"80px\"\u003e\u003ca href=\"https://movie.douban.com/subject/19971676/\" title=\"Men in Black International\"\u003e \u003cimg src=\"https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2558701068.webp\" alt=\"Men in Black International\"\u003e\u003c/a\u003e\u003c/td\u003e \u003ctd\u003e \u003cp\u003e推荐: 力荐\u003c/p\u003e \u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e ]]\u003e \u003c/description\u003e \u003cdc:creator\u003eMeng小羽\u003c/dc:creator\u003e \u003cpubDate\u003eSat, 30 May 2020 09:14:08 GMT\u003c/pubDate\u003e \u003cguid isPermaLink=\"false\"\u003ehttps://www.douban.com/people/debuginn/interests/2402808825\u003c/guid\u003e \u003c/item\u003e ...... \u003cchannel\u003e 其实，我们提取的主要就是 item 标签下对应的电影信息内容： \u003citem\u003e \u003ctitle\u003e看过黑衣人：全球追缉\u003c/title\u003e \u003clink\u003ehttp://movie.douban.com/subject/19971676/\u003c/link\u003e \u003cdescription\u003e \u003c![CDATA[ \u003ctable\u003e\u003ctr\u003e \u003ctd width=\"80px\"\u003e\u003ca href=\"https://movie.douban.com/subject/19971676/\" title=\"Men in Black International\"\u003e \u003cimg src=\"https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2558701068.webp\" alt=\"Men in Black International\"\u003e\u003c/a\u003e\u003c/td\u003e \u003ctd\u003e \u003cp\u003e推荐: 力荐\u003c/p\u003e \u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e ]]\u003e \u003c/description\u003e \u003cdc:creator\u003eMeng小羽\u003c/dc:creator\u003e \u003cpubDate\u003eSat, 30 May 2020 09:14:08 GMT\u003c/pubDate\u003e \u003cguid isPermaLink=\"false\"\u003ehttps://www.douban.com/people/debuginn/interests/2402808825\u003c/guid\u003e \u003c/item\u003e ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:1:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"设计 根据豆瓣官方提供的 XML 标签数据，可以利用 Go 语言中 encoding/xml 包来进行对数据的映射，可以设计成如下结构体： // 豆瓣 xml 描述结构体 type Attributes struct { XMLName xml.Name `xml:\"rss\"` Version string `xml:\"version,attr\"` Channel Channel `xml:\"channel\"` } // XML 主题结构拆分 type Channel struct { Title string `xml:\"title\"` Link string `xml:\"link\"` Description string `xml:\"description\"` Language string `xml:\"language\"` Copyright string `xml:\"copyright\"` Pubdate string `xml:\"pubDate\"` MovieItem []MovieItem `xml:\"item\"` } // 豆瓣 电影列表结构体 type MovieItem struct { Title string `xml:\"title\"` Link string `xml:\"link\"` Description string `xml:\"description\"` Pubdate string `xml:\"pubDate\"` } 可以和 XML 文件对应字段进行匹配，可以从上面的结构体中我们可以看到，最终我们想获取到的数据就是结构体 MovieItem 的数据。 由于是从网上链接获取数据的，在这里首先我们需要将网上豆瓣提供的 XML 文件转换成 []byte 类型的数据： // 获取 xml 文件数据 func getXMLData(url string) (data []byte, err error) { // 读取 xml 文件 client := \u0026http.Client{} req, _ := http.NewRequest(\"GET\", url, nil) // 自定义Header req.Header.Set(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\") resp, err := client.Do(req) if err != nil { return nil, err } defer resp.Body.Close() // 关闭文件 // 读取所有文件内容保存至 []byte data, err = ioutil.ReadAll(resp.Body) if err != nil { return nil, err } return } 上面这个函数实现的就是将 XML 文件保存至 Go 语言的数据结构的操作，现在可以将 XML 文件成功读取出来，接下来就是要进行 XML 字段与上面作出的结构体之间的映射，其实映射至结构体的过程是比较简单的，首先声明 Attributes{} 类型的结构体，之后通过 xml.Unmarshal 来实现映射拷贝，就可以得到对应的结构体类型的数据，由于我们想要的数据是结构体数据中的一部分，即 MovieItem，在得到结构体数据后就可以将想要的这一部分的数据选择抽取出来： v := Attributes{} unMarshalErr := xml.Unmarshal(data, \u0026v) if unMarshalErr != nil { fmt.Printf(\"xml unmarshal failed, err:%v\\n\", err) } movieItem := v.Channel.MovieItem ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:2:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"Map 转换 在这里我们可以得到结构体中嵌套的结构体，在结构体中有一些字段我们是不想要的，需要进行处理，对于 description 这个字段中，官方提供的是一段 HTML 描述串，其中电影的描述文件是我们所需要的，对于 HTML 字符串的拆分，我们可以借助strings.Split 函数来实现截取，使用 \\\" 符号截取，虽然可以获取到我们想要的数据了，但是由于这个是嵌套的结构体，我们需要做一个匹配的 map 来进行存储处理好的数据，可以看代码中我的设计： MoviesMap := make(map[int]interface{}) for i := 0; i \u003c len(movieItem); i++ { movie := make(map[string]string) description := strings.Split(movieItem[i].Description, \"\\\"\") movie[\"Title\"] = string([]rune(movieItem[i].Title)[2:]) movie[\"Link\"] = movieItem[i].Link movie[\"Img\"] = description[7] movie[\"Pubdate\"] = movieItem[i].Pubdate MoviesMap[i] = movie } 外层 map 是采用 map[int]interface{} 类型，在 interface{} 中存储这内层 map map[string]string 类型。 针对于 Img 地址的获取，是现根据特定符号拆分，之后获取制定位置的数据获取的。 0 map[Img:https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2558701068.jpg Link:http://movie.douban.com/subject/19971676/ Pubdate:Sat, 30 May 2020 09:14:08 GMT Title:黑衣人：全球追缉] 1 map[Img:https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2263408369.jpg Link:http://movie.douban.com/subject/1294371/ Pubdate:Thu, 28 May 2020 10:06:23 GMT Title:摩登时代] ...... 最后就是将这个 map 做一下序列化处理，这样就可以返回给前台数据了。 data, _ = json.Marshal(MoviesMap) ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:3:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"服务 处理好数据，做了对应的处理，怎么将数据作为服务端提供给前台，在这里需要使用 Web 服务，Go 中可以使用原生 Web，不过我在这里使用的是之前学过的 Gin 框架，来提供服务的： r := gin.Default() r.GET(\"/doubanmovies\", func(context *gin.Context) { context.JSON(http.StatusOK, MoviesMap) }) _ = r.Run(\":8080\") 启动服务，可以得到对应的 json 数据，你若以为现在就可以实现了，那么你错了，远远没有那么简单…… ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:4:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"前台 由于我知晓我的博客采用的前台 UI 技术是 MDUI， 我利用自身的卡片 UI 迅速设计了一个模块，因为后期需要放在我的博客页面上，前端读取数据采用的是 VUE 和 axios 技术： \u003cdiv class=\"mdui-container-fluid\" id=\"app\"\u003e \u003cdiv class=\"mdui-row\"\u003e \u003cdiv v-for=\"item in info\"\u003e \u003cdiv class=\"mdui-col-xs-6 mdui-col-sm-4 mdui-col-md-3 mdui-col-lg-3 mdui-m-b-1 mdui-m-t-1\"\u003e \u003ca :href=\"item.Link\" target=\"_blank\"\u003e \u003cdiv class=\"mdui-card mdui-hoverable\"\u003e \u003cdiv class=\"mdui-card-media\"\u003e \u003cimg :src=\"item.Img\" style=\"height: 260px;\" /\u003e \u003cdiv class=\"mdui-card-media-covered\"\u003e \u003cdiv class=\"mdui-card-primary\"\u003e \u003cdiv class=\"mdui-card-primary-subtitle\"\u003e{{ item.Title }}\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript src=\"./static/js/mdui.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.staticfile.org/axios/0.18.0/axios.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e new Vue({ el: '#app', data() { return { info: null } }, mounted() { axios .get('http://127.0.0.1:8080/doubanmovies') .then(response =\u003e (this.info = response.data)) .catch(function (error) { // 请求失败处理 console.log(error); }); } }) \u003c/script\u003e 设计好了以后，访问页面，却加载不出来，emmmmmm ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:5:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"CORS 看到了是 CORS 同源策略的原因，接下来就是要解决同源问题了，方法比较简单，就是将 Go 服务端加上 CORS 同源策略就可以了，方法如下： r := gin.Default() r.Use(Cors()) r.GET(\"/doubanmovies\", func(context *gin.Context) { context.JSON(http.StatusOK, MoviesMap) }) _ = r.Run(\":8080\") 在路由访问中添加 Cors() 函数： // 跨域 func Cors() gin.HandlerFunc { return func(c *gin.Context) { method := c.Request.Method //请求方法 origin := c.Request.Header.Get(\"Origin\") //请求头部 var headerKeys []string // 声明请求头keys for k, _ := range c.Request.Header { headerKeys = append(headerKeys, k) } headerStr := strings.Join(headerKeys, \", \") if headerStr != \"\" { headerStr = fmt.Sprintf(\"access-control-allow-origin, access-control-allow-headers, %s\", headerStr) } else { headerStr = \"access-control-allow-origin, access-control-allow-headers\" } if origin != \"\" { c.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\") c.Header(\"Access-Control-Allow-Origin\", \"*\") // 这是允许访问所有域 c.Header(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE,UPDATE\") //服务器支持的所有跨域请求的方法,为了避免浏览次请求的多次'预检'请求 // header的类型 c.Header(\"Access-Control-Allow-Headers\", \"Authorization, Content-Length, X-CSRF-Token, Token,session,X_Requested_With,Accept, Origin, Host, Connection, Accept-Encoding, Accept-Language,DNT, X-CustomHeader, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type, Pragma\") // 允许跨域设置 可以返回其他子段 c.Header(\"Access-Control-Expose-Headers\", \"Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers,Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma,FooBar\") // 跨域关键设置 让浏览器可以解析 c.Header(\"Access-Control-Max-Age\", \"172800\") // 缓存请求信息 单位为秒 c.Header(\"Access-Control-Allow-Credentials\", \"false\") // 跨域请求是否需要带cookie信息 默认设置为true c.Set(\"content-type\", \"application/json\") // 设置返回格式是json } //放行所有OPTIONS方法 if method == \"OPTIONS\" { c.JSON(http.StatusOK, \"Options Request!\") } // 处理请求 c.Next() // 处理请求 } } 这样就可以看到结果了，如下图： 看到结果后，心中窃喜，感觉成功了，接下来就需要将 Go 服务部署到我的服务器中去了，部署步骤比较简单，就不过多解释了，最后访问服务器 IP 及对应单口可以呈现结果，最后将前台代码粘贴到新建的页面中，生成预览，emmmm，啥都没有，浏览器居然报 HTTPS 请求 HTTP 资源是不安全的，吐了一口血，解决吧，唉，经过查询资料，得出如下两个解决方案： Gin 框架服务本身使用 SSL 证书，实现 HTTPS 访问，不过需要配置域名； 使用 Nginx 服务做一下代理，将一个特定链接代理到本身服务中去。 作为学生党的我，没有太多的资金去申请过多的 SSL 证书（省着点用），于是我就在我的 debuginn.cn 子域名下做了一个代理。 ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:6:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"代理 Nginx 代理实现也是比较简单的，就是将前端访问某个接口代理至服务器中某个端口的服务中，表面上看是 Nginx 在做数据处理，实际上是 Nginx 只做了一个代理转发，由于我www.debuginn.cn 子域名本身就是 https 的，所以设置好了代理之后，就可以使用固定的代理链接访问了，配置如下： server{ ..... location /douban_movies { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host:80; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 这样就可以实现 https 资源访问了：https://debuginn.cn/doubanmovies ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:7:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"效果 解决了 HTTPS 访问 HTTP 资源的问题，就解决了所有问题，实现了效果。 具体效果如下： https://www.debuginn.cn/doubanmovies ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:8:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["project"],"content":"开源 针对于此小项目，我已经开源至 Github 中，若是你感兴趣或者有什么建议，可以联系我，我们一起改进，同时希望你可以给我一个 Star，万分感谢！ https://github.com/debuginn/douban-movies ","date":"2023-03-03","objectID":"/douban-movies-to-blog/:9:0","tags":["go","gin","rss","mdui","douban"],"title":"如何将豆瓣观影记录实时同步至博客中","uri":"/douban-movies-to-blog/"},{"categories":["subscribe"],"content":"🤠 Hi，我是 Meng小羽 ","date":"2023-03-02","objectID":"/pages/subscribe/:1:0","tags":["GO","Go博客","技术博客","Debug客栈","debug客栈","Debuginn","debuginn","subscribe"],"title":"订阅本站","uri":"/pages/subscribe/"},{"categories":["subscribe"],"content":"常规订阅 Debug客栈给您提供了四种常规订阅方式，分别是 微信公众号订阅、邮箱订阅、 RSS订阅，当然还有 Github ，请根据您的需求选择性订阅： 邮箱订阅「推荐」 feed「经典」 github PS：您可以点击上方按钮，会弹出一个新的标签页供您操作，谢谢。 ","date":"2023-03-02","objectID":"/pages/subscribe/:2:0","tags":["GO","Go博客","技术博客","Debug客栈","debug客栈","Debuginn","debuginn","subscribe"],"title":"订阅本站","uri":"/pages/subscribe/"},{"categories":["subscribe"],"content":"专栏订阅 当然，您不习惯上方方式订阅，你可以选择你感兴趣的自媒体订阅方式，目前仅支持 知乎文章专栏、腾讯云+社区、思否专栏，我还不时制作视频上传至 哔哩哔哩 网站，请根据您的需求订阅： 知乎 云+社区 思否专栏 ","date":"2023-03-02","objectID":"/pages/subscribe/:3:0","tags":["GO","Go博客","技术博客","Debug客栈","debug客栈","Debuginn","debuginn","subscribe"],"title":"订阅本站","uri":"/pages/subscribe/"},{"categories":null,"content":"debuginn's friends","date":"2023-02-25","objectID":"/pages/friends/","tags":null,"title":"友情链接","uri":"/pages/friends/"},{"categories":null,"content":"申请友联 申请友情链接的话请提交 issue 来申请，或者你也可以增加提交 PR 你的网站。 - nickname: Debug客栈 avatar: https://image.debuginn.cn/202302182238057.JPG url: https://debuginn.cn description: 做一个爱分享的程序猿 ","date":"2023-02-25","objectID":"/pages/friends/:1:0","tags":null,"title":"友情链接","uri":"/pages/friends/"},{"categories":null,"content":"友情提示 Notice 如果您想交换链接，请按上述格式留言。(仅限个人非商业性博客网站)；  网站出现故障、停止维护和不当内容可能会被取消链接！ 那些不尊重他人劳动成果、无源转载、恶意行为的网站，请不要前来交流。 ","date":"2023-02-25","objectID":"/pages/friends/:2:0","tags":null,"title":"友情链接","uri":"/pages/friends/"},{"categories":["faas"],"content":"1 FAAS 是什么 功能即服务 (FAAS) 是一类云计算服务，它提供了一个平台，允许客户开发、运行和管理应用程序功能，而 无需构建和维护通常与开发和启动应用程序相关的基础设施的复杂性。 构建遵循此模型的应用程序是实现“无服务器”体系结构的一种方式，通常在构建微服务应用程序时使用。 FAAS 最初是由 PiCloud 等各种初创企业在2010年左右提供的。 AWS Lambda 是大型公共云供应商提供的第一个 FAAS，随后是 Google Cloud Functions、Microsoft Azure Functions、IBM/Apache 2016年的 OpenWhisk (开源)和 2017 年的 Oracle Cloud FN(开源)。 国内的云厂商近几年也陆续提供 FAAS 产品，有阿里云 Serverless 服务、腾讯云云函数(Serverless Cloud Function，SCF)、华为云函数工作流（FunctionGraph）。 ","date":"2023-02-15","objectID":"/faas-notes/:1:0","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"1.1 FAAS 优点 降低运营成本，开发人员不需要对服务器根据流量做规划，将部署平台的能力外包； 降低开发成本，Serverless 是整个应用程序组件商品化的结果，将功能相似的函数解耦，统一提供服务，减少重复建轮子； 扩展成本，Serverless 的架构就是将部署环境外包，水平扩张是完全自动、有弹性，并且有提供方来支持管理的； 偶尔的请求，一些提供给运营人员的操作很低频； 不一致的流量，函数扩容速度远远大于容器扩容速度，高效响应突发流量带来的扩容问题； 运营管理更轻松 容器的租户管理使得研发人员无需关心部署系统； 降低打包和部署的复杂性； 专注于业务代码，更快的迭代与部署； ","date":"2023-02-15","objectID":"/faas-notes/:1:1","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"1.2 FAAS 缺点 控制权的转移，任何的外包策略，都会将部分的系统控制权移交到维护团队或组织，带来的就是不可控的系统停机、意外限制、成本变化、功能丧失、强制 API 升级等问题； 多租户问题，多个客户（租户）的多个软件在同一个机器上运行； 供应商锁定，一旦选择某个供应商或者维护团队，几乎是无法进行迁移的，代码的迁移大概率只能重构； 安全问题，会增加恶意攻击的剖面，增加攻击成功的可能性； 没有服务器内状态，持久化的数据无法在容器存储，只能借助第三方存储组件实现 cache； 测试问题，没有本地环境可以完全模拟云环境； 调试问题，云环境的调试目前还没有提供优秀的 tools； ","date":"2023-02-15","objectID":"/faas-notes/:1:2","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"2 业内 FAAS 的分支及发展 云服务商 产品 产品介绍 使用场景 客户案例 备注 AWS AWS Lambda AWS Lambda 是一项无服务器事件驱动型计算服务，该服务使您可以运行几乎任何类型的应用程序或后端服务的代码，而无需预置或管理服务器。 文件处理； 流处理；Web 应用程序；IoT 后端；移动后端； 可口可乐 西门子 Netflix Coinbase 阿里云 Serverless 工作流 Serverless 工作流（Serverless Workflow）是用来协调多个分布式任务执行的全托管 Serverless 云服务，简化开发、运行业务流程需要的任务协调、状态管理和错误处理等繁琐工作。用顺序、分支、并行等方式编排分布式任务，服务按照预设顺序协调任务执行，跟踪任务的状态转换，必要时执行用户定义的重试逻辑，确保工作流顺利完成。 多媒体文件处理场景；数据处理流水线场景；自动运维场景；解决运维无法可视化的问题； Serverless 应用引擎 SAE 是一个全托管、免运维、高弹性的通用 PaaS 平台。SAE 支持 Spring Boot、Spring Cloud、Dubbo、HSF、Web 应用和 XXL-JOB、ElasticJob 任务的全托管，零改造迁移、无门槛容器化、并提供了开源侧诸多增强能力和企业级高级特性。 微服务应用托管；弹性阔缩容场景；持续集成与交付； 贵州酒店集团 视野数科 爱奇艺体育 类似 side car ，用来管理应用，承接流量 Serverless 容器服务 ASK 是一款基于阿里云弹性计算基础架构，同时完全兼容 Kubernetes 生态，安全、可靠的容器产品。通过该产品，您无需管理和维护集群即可快速创建 Kubernetes 容器应用，并且根据应用实际使用的 CPU 和内存资源量进行按需付费，从而使您更专注于应用本身，而非运行应用的基础设施。 应用托管；在线业务弹性阔缩容数据计算 低成本支撑CI/CD任务执行 图森未来 越光医疗 腾讯云 云函数（Serverless Cloud Function，SCF） 腾讯云为企业和开发者们提供的无服务器执行环境，帮助您在无需购买和管理服务器的情况下运行代码。您只需使用平台支持的语言编写核心代码并设置代码运行的条件，即可在腾讯云基础设施上弹性、安全地运行代码。云函数是实时文件处理和数据处理等场景下理想的计算平台。 静态网站托管；构建 RESTful API；部署 Serverless 全栈 Web 应用；Serverless 全景录制方案； 腾讯视频 新东方 微信阅 腾讯教育 腾讯相册 百视通 猎豹移动 API网关 腾讯云 API 网关（API Gateway）是腾讯云推出的一种 API 托管服务，能提供 API 的完整生命周期管理，包括创建、维护、发布、运行、下线等。 Serverless HTTP；微服务整合；外部多端统一；业务整合；能力提供及售卖； 人人视频 江娱互动 腾讯视频 英孚教育 3 内部原理 ","date":"2023-02-15","objectID":"/faas-notes/:2:0","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"3.1 FAAS 方向 ","date":"2023-02-15","objectID":"/faas-notes/:3:0","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"3.1.1 运行架构 常规的一个服务在容器中启动的流程 FAAS 调用启动流程 在传统的服务启动或者是容器化的服务进行启动的是否，都是服务跟随者对应的平台（巨石架构的物理机器或者微服务化的 k8s 容器）的启动而启动，整个生命周期在 pod 的启动开始，在 pod 的关机下线操作结束，整个周期是比较长的，同时必须有实例存活（至少一台）来承接响应，研发人员除了需要关注自己的开发 code，还需要关注容器的大小、容量、数量等运维指标； Serverless 中的 FAAS 将研发人员最重要的业务逻辑抽离了出来，除了这部分需要去管理升级，剩下的都交由 FAAS 提供平台来提供服务，托管后的 FAAS 生命周期从 pod 的启动关机简化到了 执行函数 handler 的 init 以及执行函数时间，并且在一些低频的业务中，一些函数实例可以交由 FAAS 提供服务商进行回收，甚至在某些时间不起函数实例，当有事件进来之后在执行函数初始化及执行逻辑（因为函数初始化到可以服务的启动时间在 100ms 左右，当然不同语言以及不同的服务提供方的实现会影响这里的启动时间）； ","date":"2023-02-15","objectID":"/faas-notes/:3:1","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"3.1.2 架构分层 其实理解起来比较简单，可以理解成我们的代码已经是与 PAAS 平台进行强解耦的结果了，我们的代码就是一部电视剧，一个操作系统安装了指定的视频播放器就可以播放我们的电视剧了，同理，我们现在只需要关心我们的函数内业务代码逻辑的定义，只要接口定义的按照封装平台的要求来开发即可，我们不需要关心运行的环境及系统，由于 runtime 已经到了 func 级别，热更新代码以及启动服务都是快速可以响应的。 ","date":"2023-02-15","objectID":"/faas-notes/:3:2","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"3.2 Mesh 方向 综上，若 FAAS 代表着是“无服务器”架构的话，其实 Service Mesh 严格意义上不能称为是“无服务器”架构，它并不能将容器部署与代码部署隔离开，只是在服务响应中增加了一层代理，用来控制应用程序中服务请求的传递，可以使得服务到服务的通讯快速、可靠和安全。 ","date":"2023-02-15","objectID":"/faas-notes/:4:0","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"3.2.1 运行架构 优点： 简化微服务和容器中服务之间的通信； 更容易的诊断通讯错误，发生在自己的基础设施层上； 支持加密、认证和授权等安全特性； 允许更快地开发、测试和部署应用程序； 放置在容器集群的边车代理可以有效的管理网络服务； 缺点： 运行时实例通过使用服务网格而增加； 每次服务的调用都要经过 sidecar proxy； 没有解决与其他服务或者系统的集成，以及路由类型或转换的映射； 网格管理的复杂新被抽象化和集中化； ","date":"2023-02-15","objectID":"/faas-notes/:4:1","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"3.2.2 架构分层 将调用限流、熔断、安全、服务注册与发现、服务管理等非业务逻辑的功能全部都放到 Sidecar 中去，本质上是一个管理性质进程在管理着业务逻辑性质的进程，进程之间的通讯使用的是 UDC(Unix domain socket)。 ","date":"2023-02-15","objectID":"/faas-notes/:4:2","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["faas"],"content":"4 Reference https://en.wikipedia.org/wiki/Function_as_a_service https://serverless.aliyun.com/ https://cloud.tencent.com/product/scf https://www.huaweicloud.com/product/functiongraph.html https://martinfowler.com/articles/serverless.html https://aws.amazon.com/cn/lambda/ https://time.geekbang.org/column/article/226574 https://www.techtarget.com/searchitoperations/definition/service-mesh https://www.zhaohuabing.com/2018/03/29/what-is-service-mesh-and-istio/ ","date":"2023-02-15","objectID":"/faas-notes/:5:0","tags":["faas","notes","serverless"],"title":"FAAS 调研笔记","uri":"/faas-notes/"},{"categories":["financing"],"content":"办理港卡之后，在证券市场找到了一款注重用户交互的证券 APP（长桥证券 APP），使用体验是大家常用港美股证券 APP 中最好的，活动期间通过专属链接注册开户，可以申请港美股终身免佣，推荐大家使用，投资港美股主要就是港卡比较难办，现在长桥与两个银行搞团办活动，大家感兴趣的可以办理注册下，另外现在入金还有奖励，办理好港卡和银行账户，就可以投资港美股了，就可以做世界 Top 公司的股东了。当然要牢记股市有风险，投资需谨慎，理性投资。 ","date":"2023-02-12","objectID":"/financing-long-bridge/:0:0","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"1 注册长桥 ","date":"2023-02-12","objectID":"/financing-long-bridge/:1:0","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"2 办理港卡 准备办卡资料；ps 小米同学建议优先选择民生。 北京民生团办时间：2.21 - 2.24 北京南洋团办时间：暂未确定，火热报名中，预计 3 月底 动态更新 ","date":"2023-02-12","objectID":"/financing-long-bridge/:2:0","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"2.1 民生香港办卡资料 身份证 + 护照（有效期大于 6 个月）； 任意国家多次往返签证； 员工工牌，实体卡； 现场会开民生内地卡，需转入 5w 人民币保留 3 个月后可提取； ","date":"2023-02-12","objectID":"/financing-long-bridge/:2:1","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"2.2 南洋香港办卡资料 身份证 + 护照（有效期大于 6 个月）； 任意国家多次往返签证； 现场会开南洋内地卡，需转入 1w 人民币，下卡可提取； ","date":"2023-02-12","objectID":"/financing-long-bridge/:2:2","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"2.3 签证渠道 如无签证，可淘宝搜索尼泊尔签证，选择销量高的店铺，选择单次停留90天，180天有效期（一般是99元）。 注意：办卡信息和服务由银行提取，长桥不收取任何费用。 ","date":"2023-02-12","objectID":"/financing-long-bridge/:2:3","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"3 入金活动 ps. 根据不同月份活动动态更新。 长桥 2 月开工福利送不停！ ","date":"2023-02-12","objectID":"/financing-long-bridge/:3:0","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"3.1 开户福利 开户可享港股免佣福利、长桥现金打新免费（新老客户）、100 港币股票现金卡、新客专享美元货币基金，年化收益 4.65% 左右，资金不浪费。 ","date":"2023-02-12","objectID":"/financing-long-bridge/:3:1","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"3.2 新用户入金 2w 港币福利 600 港币股票现金卡 + 400 港币平台费抵扣卡； 两人拼团，每人额外再送 200 京东卡； 入金 30 天内交易一次美股期权，再送 200 港币股票现金卡； 港股终身免佣； ","date":"2023-02-12","objectID":"/financing-long-bridge/:3:2","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["financing"],"content":"4 企业认证 如果你是可支持认证的企业员工的话，建议做一下企业认证，一般有企业邮箱的话直接输入邮箱账号接收验证码就可以完成认证了，企业认证后有需要优惠活动。 ","date":"2023-02-12","objectID":"/financing-long-bridge/:4:0","tags":["证券","长桥","港美股","longbridge"],"title":"长桥港美股团办活动","uri":"/financing-long-bridge/"},{"categories":["summary"],"content":"今年，时光依旧不饶人，步入社会以来，时间就似乎不会慢下来，都在光速飞逝，很遗憾，今年疫情依旧没有结束，3 月份的时候还作为密切接触者被隔离了 21 天，总的来说，今年有悲伤同时又十分幸运，感觉冥冥之中都是安排好的。 ","date":"2022-12-31","objectID":"/debuginn-2022/:0:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"网站数据 2022年统计数据共享链接 ","date":"2022-12-31","objectID":"/debuginn-2022/:1:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"摄影专区 今年为了兴趣爱好买了一台微单 索尼 α6400+18135 镜头，同时，也想着把自己的摄影作品呈现给大家，每年我都会更新一批图片到这里，选 10 张自己认为比较好的图片拿来展出，水平不高，但是每一张照片背后都有属于它的专属意义。直达链接 ","date":"2022-12-31","objectID":"/debuginn-2022/:2:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"年度事件 ","date":"2022-12-31","objectID":"/debuginn-2022/:3:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"疫情 有感动有奇迹 记得在 3 月份的某一天，突然接到领导通知，大家全体居家办公，具体情况听通知，不得外出，下午就接到了确认密接的防疫办的电话，让在家等着去集中隔离，由于密接人数比较多，第二天下午才安排到酒店隔离，一切安排都没有那么混乱，大家都有序进行隔离入住，庆幸的是，隔离的地方还不错，至少可以安心的在隔离期间办公了，隔离期间还下了一场雪，别有一番风景。 隔离期间，大家互相勉励，配合大白检测，大家都很有信心，隔离结束之后，得知大家作为密接都没有被感染 😷，像是一个奇迹，大家都好好滴，同时也传来了确诊同事阳转阴的好消息。 回头想来，这次防疫应该是北京政府做的一轮比较优秀的防疫案例了，做到了透明、快且安全。 ","date":"2022-12-31","objectID":"/debuginn-2022/:3:1","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"是的 我们就这样相遇了 都说红螺寺和雍和宫很灵验，去寺院诚心叩拜了每一个佛祖菩萨，感谢佛祖菩萨，的确如此，是的，我们就这样相遇了，新的一年和她，真好。 新的一年，我们的故事正在续写～ 我坚信真诚的对待感情总会有好的结果，感谢相遇，感谢这神奇的缘分～ ps：不过多介绍，还有下文哦～ ","date":"2022-12-31","objectID":"/debuginn-2022/:3:2","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"是的 我成杨过了 12月17号在喉咙疼了好几天的情况下，最后还是测量的体温在 38.5 度，我已经感觉中招了，不出意外，接下来连续三天都持续高烧，浑身上下疼痛，之后还流鼻血，应该是高烧烧的，之后就是居家躺尸阶段，没有精神同时伴随有轻微咳嗽，后来做了抗原检测，果然中招，不过目前好了。大家注意防护与提高自身免疫力，很重要的。 ","date":"2022-12-31","objectID":"/debuginn-2022/:3:3","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"好物分享 摄影设备：微单 索尼 α6400+18135 镜头； 键鼠套装：Mac 新一代键盘、触控板套装； 显示设备：目前主力生产使用的 LG HDR 4k 显示器； 辅助灯光：目前使用的是小米屏幕挂灯 1s，搭配米家使用非常流畅； 充电设备：小米无线充电宝+座充底座，既可以室内充当无线充电，又可以户外活动使用； ","date":"2022-12-31","objectID":"/debuginn-2022/:4:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"年度书籍 今年算是奋起阅读的一年了，短短三个月时间就啃下来很多书，很有营养，以后也要给自己补补能量，让自己变得更强。 技术 《Effective Go 中英双语版》bingo，很棒的一本 Go 入门数据； 公司 《一往无前》范海涛，讲解公司创立到十周年发生的故事; 小说 《黄金时代》王小波，自由？背叛？性？ 读完没有啥感觉； 散文 《乖，摸摸头》大冰，第二次读，算是疫情三年禁锢肉体的另一种解脱； 技术 《图解 HTTP》上野，用通俗易懂的漫画讲解； 技术 《分布式缓存：原理、架构及Go语言实现》胡世杰，讲的很透彻，数据提供的很透彻； 技术 《深入理解Java虚拟机JVM高级特性与最佳实践》周志明，java 进阶书籍，值得推荐； 技术 《深入设计模式》，设计模式算是 code 中让房子长什么样的设计方法论了； 散文 《保重》大冰，没有读完，算是给自己的青春留下一章吧，保重； ","date":"2022-12-31","objectID":"/debuginn-2022/:5:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"年度文章 本年度很懒，没有出啥文章，就写了两篇，那就算作年度文章吧～ Go 语言学习进阶之路 https://www.debuginn.cn/7402.html 使用 pprof 对 Go 程序进行分析优化 https://www.debuginn.cn/7444.html ","date":"2022-12-31","objectID":"/debuginn-2022/:6:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"Github 个人页面 今年倾心打造自己的技术主页，术业有专攻，对自己在技术专业能力方面在 23年有更高的要求，同时希望自己在技术圈可以成为有影响力的人，来帮助更多的同行，同时也在不断的提升自己，直达链接。 ","date":"2022-12-31","objectID":"/debuginn-2022/:7:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["summary"],"content":"总结 这一年总的来说是给自己带来很大成长的一年，褪去了年少的青涩，增加了一点成熟的模样，也懂得了珍惜当下，活好每一天，爱人爱己，学会了倾听、学会了表达、学会了接受失去、同时也学会了迎接未来，感恩、感谢、感激、感动，这就是我的 2022年。 2023年，祝大家新年快乐， happy new year ～ ","date":"2022-12-31","objectID":"/debuginn-2022/:8:0","tags":["Debug客栈","2022","2023","年度总结"],"title":"2022 年度总结","uri":"/debuginn-2022/"},{"categories":["golang"],"content":"前言 在生产环境中，偶尔会发生 Go 程序 CPU 暴增的现象，排除某时段并发大的场景外，通过监控面板看不到程序是因为什么原因导致的，Go 语言原生就提供了工具 pprof，Google 对于 pprof 的解释就是一个用于可视化和分析数据的工具。 通过使用 Go pprof 可以对程序的 CPU性能、内存占用、Goroutine wait share resource、mutex lock 做剖面分析，我们可以使用该工具收集运行时的程序性能指标，从而分析出程序中是否由于代码编写不合理导致存在不合理的资源占用情况，从而对程序进行优化用来提升其性能。 ","date":"2022-05-01","objectID":"/go-tools-pprof/:1:0","tags":["Go","pprof","分析","go pprof","go tools"],"title":"使用 pprof 对 Go 程序进行分析优化","uri":"/go-tools-pprof/"},{"categories":["golang"],"content":"功能 Go pprof 提供了以下五种不同维度观测其程序的功能： CPU Profiling：CPU 性能分析，按照指定时间采集监听其 Go 程序 CPU 的使用情况，可以确定 Go 程序在哪个程序段中占用 CPU 耗时长； Memory Profiling：内存性能分析，用来分析程序的内存堆栈区使用情况，用来检测是否存在内存泄漏； Block Profiling：Goroutine 等待共享资源阻塞分析； Mutex Profiling：互斥锁分析，用来报告共享资源使用互斥锁的竞争的情况； Goroutine Profiling：协程性能分析，用来报告对当前运行时的 Goroutine 操作及数量。 ","date":"2022-05-01","objectID":"/go-tools-pprof/:2:0","tags":["Go","pprof","分析","go pprof","go tools"],"title":"使用 pprof 对 Go 程序进行分析优化","uri":"/go-tools-pprof/"},{"categories":["golang"],"content":"使用 Go pprof 工具的使用也是比较简单快捷的，可以使用runtime/pprof包生成一个 profile 文件，网上也有很多的教程，这里不再过多描述了，详细可以看下包提供的函数，上面介绍了使用方法。 目前我们主要使用的是net/http/pprof包，启动一个独立端口号 http 程序单独用来 Go 程序的分析，搭配着 graphviz 组件来可视化程序来分析数据，使用起来也是比较方便的： 第一步，将net/http/pprof包引用到程序中，建议直接放在程序入口处 main.go 文件 import ( _ \"net/http/pprof\" ) 第二步，若本身是一个 http 的程序，不需要此步骤，若不是 http web 程序或者不想将对应信息暴露在外网，可以单开一个 http web 程序用来专门监听服务： func main() { // 程序逻辑代码 go func() { _ = http.ListenAndServe(\":8848\", nil) }() } 第三步，运行主程序，访问 pprof 界面： http://127.0.0.1:8848/debug/pprof/ # 主界面 http://127.0.0.1:8848/debug/pprof/allocs # 所有过去内存分配的采样 http://127.0.0.1:8848/debug/pprof/block # 导致同步阻塞的堆栈跟踪 http://127.0.0.1:8848/debug/pprof/cmdline # 当前程序的命令行的完整调用路径 http://127.0.0.1:8848/debug/pprof/goroutine # 所有当前 Goroutine 的堆栈跟踪 http://127.0.0.1:8848/debug/pprof/heap # 活动对象的内存分配的采样 http://127.0.0.1:8848/debug/pprof/mutex # 争用互斥锁持有者的堆栈跟踪 http://127.0.0.1:8848/debug/pprof/profile # CPU 配置文件 http://127.0.0.1:8848/debug/pprof/threadcreate # 创建新 OS 线程的堆栈跟踪 http://127.0.0.1:8848/debug/pprof/trace # 当前程序执行的跟踪 后缀加上 ?debug=1 可以可视化查看对应描述，不加就可以下载成 profile 文件，使用 pprof 命令可视化查看对应数据。 第四步，使用 go tool pprof -http=:6001 profile 命令查看分析程序。 ","date":"2022-05-01","objectID":"/go-tools-pprof/:3:0","tags":["Go","pprof","分析","go pprof","go tools"],"title":"使用 pprof 对 Go 程序进行分析优化","uri":"/go-tools-pprof/"},{"categories":["golang"],"content":"分析 上图是针对 CPU 使用做的采集可视化，箭头越粗、方块越大就代表着对应的操作消耗 CPU 大，可以看到占用 CPU 最多的操作就是 json 的序列化和反序列化操作。 同理对应的内存性能、Goroutine 阻塞的分析都可以看出对应的操作。 ","date":"2022-05-01","objectID":"/go-tools-pprof/:4:0","tags":["Go","pprof","分析","go pprof","go tools"],"title":"使用 pprof 对 Go 程序进行分析优化","uri":"/go-tools-pprof/"},{"categories":["golang"],"content":"总结 使用 go pprof 工具可以分析解剖程序运行性能问题，可以快速定位生产环境中遇到的问题，并作出优化或者 fix bug，最后祝大家不会写出 bug code，程序稳定、头发永在。 ","date":"2022-05-01","objectID":"/go-tools-pprof/:5:0","tags":["Go","pprof","分析","go pprof","go tools"],"title":"使用 pprof 对 Go 程序进行分析优化","uri":"/go-tools-pprof/"},{"categories":["summary"],"content":"今年，时间依旧飞快流逝，转眼间，自己已经毕业了小2年了，渐渐的自己开始习惯了北漂的生活，一个人的北京，自由与孤独同在。也体会到了离家远的遗憾，远的连奶奶最后一面也没有见到，第一次感受到了亲人阴阳两隔的无奈与悲哀。疫情 😷 在全球范围内还在持续，国内偶尔也零星的出现，但愿 22 年疫情结束，全世界人们都可以回归到疫情之前，和爱人、亲人、朋友去想去的地方，去探索多彩的世界。 ","date":"2021-12-30","objectID":"/debuginn-2021/:0:0","tags":["Debug客栈","2021","2022","年度总结"],"title":"2021 年度总结","uri":"/debuginn-2021/"},{"categories":["summary"],"content":"网站数据 2021年统计数据共享链接 今年，写了一些在工作中使用到的 Golang 的一些技巧及思考，以及一些规范。 让我意外的是大家对 Go 语言入门学习有着很大的兴趣，下面这个文章是今年访问最多的文章，访问量：2785 Go 语言开发设计指北 https://www.debuginn.cn/6832.html ","date":"2021-12-30","objectID":"/debuginn-2021/:1:0","tags":["Debug客栈","2021","2022","年度总结"],"title":"2021 年度总结","uri":"/debuginn-2021/"},{"categories":["summary"],"content":"技术导航 经常游荡于各个大厂的技术博客之中，于是做了一个集合导航，后续计划将大佬们也收集到此，大家有好的技术分享网站也可以评论区留言分享一下。 大厂技术栈 https://www.debuginn.cn/tech ","date":"2021-12-30","objectID":"/debuginn-2021/:2:0","tags":["Debug客栈","2021","2022","年度总结"],"title":"2021 年度总结","uri":"/debuginn-2021/"},{"categories":["prometheus"],"content":"近期，我们对 APP 网关 Gateway 做了升级，由于项目创建时间过早（6年前的项目），那时候还没有好的包管理工具，使用的是最原始的 Go Path 来进行项目的依赖管理，历史包袱比较重，项目中很多的第三方引用都是直接将代码拷贝到项目目录下，升级与维护起来特别麻烦，升级之后就是现在官方主推的是 Go module 包管理方式。 解决了上面的这个痛点，网关程序就可以集成一些业界主流的基础工具，升级与维护起来就简单多了。 言归正传，本文主要是讲的我们是如何用 Prometheus 对网关进行监控的，之前我们的网关程序也是集成了我们公司开源打点监控工具 Open falcon，并且使用 Grafana 进行绘图并查看，但是为啥我们不再继续使用了？之后我们为啥拥抱了 Prometheus 生态？还有一些打点、报警、绘图的思考，还有一些我们在使用的过程中出现的问题以及解决方案，一一讲解一下。 ","date":"2021-12-11","objectID":"/prometheus-gateway/:0:0","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"抛弃 Open falcon 拥抱 Prometheus 在决定使用 Prometheus 之前，我们的 Gateway 使用的是 Open falcon，但是一直存在着一个对于我们而言的痛点，就是作为网关程序，历史维护的路由太多了，接口可用性及接口报错无法聚合报警，也就是我们的监控体系存在着盲区，这个对我们而言来说是最为致命的，那个接口出现了问题会直接导致用户的使用，并且我们使用的那些上游服务出现问题我们也无法及时感知。 使用 Prometheus 最主要的是我们可以通过 PromQL 语法进行正则匹配，实现对某个或多个接口的聚合计算并报警，这样就可以解决我们无法聚合报警的一个痛点。 ","date":"2021-12-11","objectID":"/prometheus-gateway/:1:0","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"打点、绘图、报警 ","date":"2021-12-11","objectID":"/prometheus-gateway/:2:0","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"打点 全面、量小 作为业务使用，怎么设计点位，既可以满足报警使用，对每个接口进行各项指标的监控，同时要保证点位数据是可穷举的（避免出现 OOM）和产生数据量比较小。简而言之，就是“监控要全面、打点数据量要小”，因为数据量大的话在 Prometheus 拉取指标的时间及周期就不得不设置的过大，这样的后果就是造成图的绘制缓慢甚至超时，同时报警也失去了实效性。 我们网关使用的是 http 协议，可以充分利用 Go 的 net/http 特性，使用中间件设计，对请求与返回进行打点，于是我们是这样设计的： 对任意一个请求做一个 qps 的打点记录（无任何的业务参与其中）； 对单个路由请求进行打点（区分业务状态码）； 对单个路由请求进行耗时打点（区分业务状态码）。 请求路由按照业界通用的设计：/version/model/action 以上的场景，仅仅使用指标类型中的两种 Counter（计数器） 和 Histogarm（直方图）就可以满足我们打点需求。 ","date":"2021-12-11","objectID":"/prometheus-gateway/:2:1","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"绘图 清晰、快速 构建一栋房子所需的材料都准备好了，准备建造， building…… 点位指标收集到了，接下来就是对点位进行各个维度的拼装，来呈现我们想要的图，这里解答一下为什么我们要把业务状态码打到指标中去，以及我们是如何使用的：我们的系统设计采用业务封装错误码，只要是传输调用链路没有问题，所有的场景都走业务状态码，类似的返回解决如下： { \"code\": 0, \"desc\": \"success\", \"data\":{ \"result\": \"ok\" } } code 为 0，代表当前请求是正常的，返回数据会封装在 data 中； code 不为 0，代表着当前请求存在业务上可捕获或者自定义的错误。 作为网关程序，与下游微服务采用相同的接口设计，对我们现在的打点设计也是非常友好的。 同样的，有的服务使用的是 Restful API 思想，使用的是 http 标准状态码，那就是 200 代表着成功，非 200 代表着业务或者系统存在错误，当然 5XX 错误可以单独拿出来做可用性或者细化的报警。 之所以打点记录业务状态码，好处如下： 对业务状态码打点，可以对某个业务上的特定错误进行捕捉，看图及报警都是非常便捷的； 不影响对接口可用性进行计算，可以多维度聚合计算可用性（根据业务定义而言）。 当然，打点指标设置的粒度越小，对应的点位的存储大小以及聚合运算的代价也是成倍的提高的。 铺垫了好久，说一下我们是怎么进行绘图的，在打点的时候讲到使用 Counter、Histogram 进行打点，绘图的时候我们主要从以下三点进行可视化： 接口的 qps 看图呈现； 接口可用性（Pxx）看图呈现； 接口请求PXX 耗时统计 看图呈现。 接口 qps 看图绘图 qps 的点位数据怎么打？就是充分利用中间件的设计，在一个请求 prepare 阶段就将该路由记录并获取进行打点。 使用 PromQL 语句就可以实现对对应信息看图的绘制。 // 过去1分钟 每秒请求 qps // sum 求和函数 // rate 计算范围向量中时间序列的每秒平均增长率 // api_request_alert_counter 指标名称 // service_name 和 subject 都是 label kv参数 sum(rate(api_request_alert_counter{service_name=\"gateway\", subject=\"total\"}[1m])) by (subject) 接口可用性看图绘图 接口可用性就是验证当前接口在单位时间内的处理正确的请求数目比上总体的请求数目，在打点的时候也讲到，我们业务代码 0 代表着正确返回，非 0 的代表着存在问题，这样就可以很简单的算出来接口的可用性。 // 过去1分钟 每秒接口可用性 // sum 求和函数 // rate 计算范围向量中时间序列的每秒平均增长率 // api_request_cost_status_count 指标名称 // service_name 和 code 都是 label kv参数 (sum(rate(api_request_cost_status_count{service_name=\"gateway\", code=\"0\"}[1m])) by (handler) / ( sum(rate(api_request_cost_status_count{service_name=\"gateway\", code=\"0\"}[1m])) by (handler) + sum(rate(api_request_cost_status_count{service_name=\"gateway\", code!=\"0\"}[1m])) by (handler)) ) * 100.0 接口 Pxx 耗时统计看图绘图 接口耗时统计打点依赖 prometheus api 中的 histogram 实现，在呈现打点耗时的时候有时候局部的某个耗时过长并不能进行直接反应整体的，我们只需要关注 SLO （服务级别目标）目标下是否达标即可。 // 过去1分钟 95% 请求最大耗时统计 // histogram_quantile 1000* histogram_quantile(0.95, sum(rate(api_request_cost_status_bucket{service_name=\"gateway\",handler=~\"v1.app.+\"}[1m])) by (handler, le)) histogram_quantile(φ float, b instant-vector) 从 bucket 类型的向量 b 中计算 φ (0 ≤ φ ≤ 1) 分位数（百分位数的一般形式）的样本的最大值。（有关 φ 分位数的详细说明以及直方图指标类型的使用，请参阅直方图和摘要）。向量 b 中的样本是每个 bucket 的采样点数量。每个样本的 labels 中必须要有 le 这个 label 来表示每个 bucket 的上边界，没有 le 标签的样本会被忽略。直方图指标类型自动提供带有 _bucket 后缀和相应标签的时间序列。 上面是官方对于 histogram_quantile 函数的解释，关注的是 设置 φ 分位数 对应的 bucket 桶，但是实际中有 分位数计算误差的问题。 Prometheus 官方 histogram 设置的默认 buckets 如下： DefBuckets = []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10} 这里可以看到我们的接口指标分界时间，每一个请求的耗时都会根据具体的设置的 buctet 的范围落到不同的区间内，这里设置的桶的范围直接影响到计算值的准确度（上面所提到的 分位数计算误差问题）。 ","date":"2021-12-11","objectID":"/prometheus-gateway/:2:2","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"报警 及时、准确 使用 Prometheus 的 Alert Manager 就可以对服务进行报警，但是如何及时又准确的报警，已经如何合理设置报警，我们就要引入 SLO 的概念，在实际的业务场景中，我们会发现某个接口某个时间段的耗时是一组离散的点： 我们可以看到大部分的请求可以在 1s 之内就可以快速的返回，只有个别的请求可能由于网络的抖动、应用短暂升级或者其他因素导致过慢，若是我们直接设置接口最大请求耗时超过2s（持续一个时间段），那我们就面临着疯狂的告警轰炸，同时告警也就失去了针对某个接口的异常活动做出提示供开发人员处理的意义。 服务级别目标（Service-level objective，SLO）是指服务提供者向客户作出的服务保证的量化指标。服务级别目标与服务级别协议有所不同。服务级别协议是指服务提供者向客户保证会提供什么样的服务，服务级别目标则是服务的量化说明。 Service-level objective 服务级别目标 比方说我们发现上面的 90% 请求都在 1s 内返回，我们就可以只需要对 90% 请求耗时做监控分析其调用链路并告警。 举个栗子，比方说我们一个首页的接口 /v1/home/page 99% 的请求可以在 500ms 内返回，只有个别的请求超过 2s+ 的时间，大多数情况下我们就不会关心这 1%的请求，那我们就可以定制一个 持续 1分钟首页 99% 请求耗时大于 1s的报警，这样当我们收到报警的时候，我们就可以第一时间知道首页出现了问题，我们就可以根据报警及时处理。 **业务的报警是与接口的实现与调用链路的复杂度是紧密结合在一起的，根据不同的业务场景，配置合理的报警才满足我们及时准确的要求。**反之就是配置过高不灵敏、往往线上已经出现了好久报警就是没有，配置过低，分分钟触发报警，对业务开发人员增加了排查问题的时间成本。 ","date":"2021-12-11","objectID":"/prometheus-gateway/:2:3","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"遇到的问题 ","date":"2021-12-11","objectID":"/prometheus-gateway/:3:0","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"收集指标过大拉取超时 由于我们是 gateway BFF 层做得指标，本身的路由的基数就比较大，热点路由就有好几百个，再算上对路由的打点、耗时、错误码等等的打点，导致我们每台机器的指标数量都比较庞大，最终指标汇总的时候下游的 prometheus 节点拉取经常出现耗时问题。 前期解决方案比较粗暴，就是修改 prometheus job 的拉取频率及其超时时间，这样可以解决超时问题，但是带来的结果就是最后通过 grafana 看板进行看图包括报警收集上来的点位数据延迟大，并且随着我们指标的设置越来越多的话必然会出现超时问题。 目前的解决方案就是做分布式，采用 prometheus 联邦集群的方式来解决指标收集过大的问题，采用了分布式，就可以将机器分组收集汇总，之后就可以成倍速的缩小 prometheus 拉取的压力。 ","date":"2021-12-11","objectID":"/prometheus-gateway/:3:1","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"动态收集机器指标 因为我们机器都是部署在集群上并且会随着活动大促动态调整机器的数量，联邦集群中配置文件最重要的就是配置各个收集节点指标的 IP:Port ，我们不可能每次都去手动维护这个配置，成本比较高，那么我们就需要将配置动态写入，针对此问题，在 leader 的建议下，使用运维服务树拿到该节点下的机器的 Ip，使用脚本程序动态维护起来就非常方便了，默认 Prometheus 是 20s 读取一次配置。 ","date":"2021-12-11","objectID":"/prometheus-gateway/:3:2","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"请求的耗时看图与报警不准确 这个问题是在我们的业务中，请求耗时最常见的是在 2s 之内返回，但是通过 Prometheus histogram 对应 1-2s 的请求会落在 le 为 2.5 桶中，导致报警误报，我们看日志中的请求在 1.* s 的都算在 2.5 的桶上，而报警的配置是 大于 2s， emmm DefBuckets = []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10} 之后根据我们的业务场景调整了一下，使用了自己的 CustomBuckets： CustomBuckets = []float64{.01, .025, .05, .1, .25, .5, 1, 1.5, 2, 3, 4, 8} ","date":"2021-12-11","objectID":"/prometheus-gateway/:3:3","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["prometheus"],"content":"References Prometheus 官方文档 Prometheus 翻译文档 wiki SLO 服务级别目标 wiki 累积直方图 ","date":"2021-12-11","objectID":"/prometheus-gateway/:4:0","tags":["prometheus","grafana","open falcon","counter","histogram"],"title":"我们是如何用 Prometheus 对网关进行监控的","uri":"/prometheus-gateway/"},{"categories":["job"],"content":" 永远相信美好的事情即将发生 欢迎大家联系我，让我为你内推吧，小米众多岗位等你来选，不清楚岗位信息的可以联系我，我会给你发对应的内推部门及岗位，也可以联系我查询内推情况，感觉OK，你就来吧！ ","date":"2021-09-23","objectID":"/mi-work/:0:0","tags":["内推"],"title":"来小米，一起玩 ！！！","uri":"/mi-work/"},{"categories":["git"],"content":"前言 在团队开发中，使用 Git 作为版本开发工具，可以便捷地协同多人管理并行开发，但是由于自己或者其他人代码提交污染了远程分支，就需要对远程代码进行恢复操作，Git 提供了 reset 和 revert 两种命令来进行恢复操作，这两种操作效果是截然不同的，不太清楚这个原理的同学需要了解一下，以免在实际的开发过程中翻车，导致线上远程仓库不可逆转的操作。 首先从英文释义来讲，reset 是重置的意思，revert 是恢复、还原的意思，作为 Coder ，第一感觉 reset 的效果比 revert 更猛一些，实际情况也的确如此，让我们一起探讨一下吧。 ","date":"2021-09-21","objectID":"/git-reset-revert/:1:0","tags":["git","github","reset","revert"],"title":"Git 命令 reset 和 revert 的区别","uri":"/git-reset-revert/"},{"categories":["git"],"content":"背景 Git 的每一次提交都是一次 commit，上图可以看到在时间线上有三次提交，此时 HEAD 指向 main 分支，main 分支又指向最新的 Commit3。 HEAD 是指向当前分支的最新提交的指针，可以在任意分支进行切换； main （master）分支，是一个 git 代码仓库的主分支也是默认分支； commit 每一次提交代码都会产生一个 commit id 来标识工作区的变更与改动。 ","date":"2021-09-21","objectID":"/git-reset-revert/:2:0","tags":["git","github","reset","revert"],"title":"Git 命令 reset 和 revert 的区别","uri":"/git-reset-revert/"},{"categories":["git"],"content":"实践出真理 为了直接明白的了解其原理，我这里在 github 上创建一个空白的仓库，按照上图创建三次提交： commit b0ef8f9125226af8f06ff1aba7c1f1fc83adea9b (HEAD -\u003e master, origin/master) Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 16:36:39 2021 +0800 feat add 3.go commit 338bf3e30983d34074f37a18b3ff80ea9bca75f0 Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 16:36:09 2021 +0800 feat add 2.go commit 6b166ed34962da08d944e2b1d3f36d9015dd8f35 Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 16:35:16 2021 +0800 feat add 1.go ","date":"2021-09-21","objectID":"/git-reset-revert/:3:0","tags":["git","github","reset","revert"],"title":"Git 命令 reset 和 revert 的区别","uri":"/git-reset-revert/"},{"categories":["git"],"content":"Git Reset git reset 的作用是将 HEAD 指向指定的版本上去： 1 使用 git log 查看提交记录： commit b0ef8f9125226af8f06ff1aba7c1f1fc83adea9b (HEAD -\u003e master, origin/master) Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 16:36:39 2021 +0800 feat add 3.go commit 338bf3e30983d34074f37a18b3ff80ea9bca75f0 Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 16:36:09 2021 +0800 feat add 2.go commit 6b166ed34962da08d944e2b1d3f36d9015dd8f35 Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 16:35:16 2021 +0800 feat add 1.go 这里可以看到我们提交了三次记录，我们现在想恢复到第一次 commit 提交的时候。 2 使用 git reset –hard 命令操作： ➜ demo git:(master) git reset --hard 6b166ed34962da08d944e2b1d3f36d9015dd8f35 HEAD 现在位于 6b166ed feat add 1.go 再次查看 git log : commit 6b166ed34962da08d944e2b1d3f36d9015dd8f35 (HEAD -\u003e master) Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 16:35:16 2021 +0800 feat add 1.go 此时我们可以看到已经恢复到了第一次提交代码的时候，目前我们是使用 git reset --hard 的方式，其实这里存在着三种方式，TODO 下一篇 git 操作讲一下。 这时候我们只是讲本地的 HEAD 指向了 main 分支的 commit 1，但是远程并没有变更，此时需要强行推一下就可以了。 3 使用git push -f 强行推送到远程： ➜ demo git:(master) git push -f 总共 0（差异 0），复用 0（差异 0），包复用 0 To github.com:debuginn/demo.git + b98f95e...6b166ed master -\u003e master (forced update) 此时我们可以看到远程也没有了我们之前提交的三次记录而是只有第一次的提交记录。 警告 在团队合作的共同操作一个仓库的时候， git reset 命令一定要慎重使用，在使用的时候一定要再三确认其他同学的代码是否会被重置操作而导致代码丢失，导致一些提交记录的丢失，这些都是不可逆的，一定要慎重。 ","date":"2021-09-21","objectID":"/git-reset-revert/:3:1","tags":["git","github","reset","revert"],"title":"Git 命令 reset 和 revert 的区别","uri":"/git-reset-revert/"},{"categories":["git"],"content":"Git revert git revert 是用来重做某一个 commit 提交的内容，在我们原始的提交之中，我们会发现分支上面有创建了一个新的 commit 提交，而此时我们对于想重做的某个 commit 提交的内容都不存在了： 1 使用git log查看提交记录： Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 16:36:39 2021 +0800 feat add 3.go 2 使用git revert命令重做操作： ➜ demo git:(master) git revert 338bf3e30983d34074f37a18b3ff80ea9bca75f0 删除 2.go [master ef822b7] Revert \"feat add 2.go\" 1 file changed, 9 deletions(-) delete mode 100644 2.go 再次查看 git log : commit ef822b71c33a2dbbdaa350fddcfa14e8fc55e543 (HEAD -\u003e master, origin/master) Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 17:12:00 2021 +0800 Revert \"feat add 2.go\" This reverts commit 338bf3e30983d34074f37a18b3ff80ea9bca75f0. commit b0ef8f9125226af8f06ff1aba7c1f1fc83adea9b Author: debuginn \u003cdebuginn@icloud.com\u003e Date: Tue Sep 21 17:05:39 2021 +0800 feat add 3.go 可以看到当前已经重做了一下 commit 2 的提交，已经讲 2.go 删除掉了。 可以看到 github 上面有了四次提交记录。 ","date":"2021-09-21","objectID":"/git-reset-revert/:3:2","tags":["git","github","reset","revert"],"title":"Git 命令 reset 和 revert 的区别","uri":"/git-reset-revert/"},{"categories":["git"],"content":"总结 git reset和git revert都是属于重新恢复工作区以及远程提交的方式，但这两种操作有着截然不同的结果： git reset是将之前的提交记录全部抹去，将 HEAD 指向自己重置的提交记录，对应的提交记录都不复存在； git revert 操作是将选择的某一次提交记录 重做，若之后又有提交，提交记录还存在，只是将指定提交的代码给清除掉。 选择合适的方式回滚自己的代码在团队合作中很重要，但是要慎重操作，不要丢失代码哦。 ","date":"2021-09-21","objectID":"/git-reset-revert/:4:0","tags":["git","github","reset","revert"],"title":"Git 命令 reset 和 revert 的区别","uri":"/git-reset-revert/"},{"categories":["coin"],"content":"今天使用数字人民币兑换了建党100周年纪念币，过程比较坎坷，不过最终还是兑换成功了。 预约 ? 纪念币成功后，今天中秋假期，正好去兑换纪念币，小雨转中雨 ☁️，作为多年没有使用纸质人民币的我实在是没有钱来兑换纪念币，之后搜索了一下附近可以兑换人民币的营业厅，都在千米之外，算了…… 突然想到前两天美团有一个数字人民币的活动，下载了数字人民币 APP，研究了一下，发现有工商银行支持数字人民币，之后搜寻了一下网点，发现北京地区都是支持数字人民币的了，之后我就去申请了工商银行电子钱包，往里面转了 200 元钱，之后去银行网点ing。 到了之后工作人员引领到专门兑换纪念币柜台，我问了一下是否可以使用数字人民币兑换，好家伙，社死瞬间，一下来了 6 个工作人员看我操作，柜台小姐姐说没有操作过数字人民币付款，之后那我当一下小白鼠 ? ？ 操作出来数字人民币支付二维码页面，之后扫描发现不能使用 emmmmm，尴尬，看了提示，原来是让我下载工行的 APP，之后使用上面的数字人民币进行支付，一通下载注册之后，再次去柜台兑换，扫码 =\u003e 支付，等了 5s 左右，最终成功兑换了纪念币，现在想想，我应该是第一个使用数字人民币兑换纪念币的第一人了吧。 数字人民币未来由国家导向大力推广，会使人民的支付更加便捷，不过个人建议纸质币保留下来，照顾不会使用手机的老年群体，总之，技术的进步，未来看来我们都是为了一串数字而奋斗喽。 ","date":"2021-09-19","objectID":"/coin-use-epay/:0:0","tags":["coin","e-pay","数字人民币","纪念币"],"title":"使用数字人民币兑换建党100周年纪念币","uri":"/coin-use-epay/"},{"categories":["golang"],"content":"译文原地址：Should methods be declared on T or *T - David 在 Go 中，对于任何的类型 T，都存在一个类型 *T，他是一个表达式的结果，该表达式接收的是类型 T ，例如： type T struct { a int; b bool } var t T // t's type is T var p = \u0026t // p's type is *T 这两种类型，T 和 *T 是不同的，但 *T 不能代替 T。 你可以在你拥有的任意类型上声明一个方法；也就是说，在您的包中的函数声明的类型。因此，您可以在声明的类型 T 和对应的派生指针类型 *T 上声明方法。另一种说法是，类型上的方法被声明为接收器接收者值的副本，或一个指向其接收者值的指针。所以问题就存在了，究竟是哪种形式最合适？ 显然，如果你的方法改变了他的接收者，他应该在 *T 上声明。但是，如果方法不改变他的接收者，在 T 上声明它是安全的么？ 事实证明，这样做的话安全的情况非常有限（简单理解就是不安全的）。例如，众所周知，你不应该复制一个 sync.Mutex 的值，因为它打破了互斥量的不变量。由于互斥锁控制对变量（共享资源）的访问，他们经常被包装在一个结构体中，包含他们的控制的值（共享资源）： package counter type Val struct { mu sync.Mutex val int } func (v *Val) Get() int { v.mu.Lock() defer v.mu.Unlock() return v.val } func (v *Val) Add(n int) { v.mu.Lock() defer v.mu.Unlock() v.val += n } 大部分 Gopher 都知道，忘记在指针接收器 *Val 上是声明 Get 或 Add 方法是错误的。然而，任何嵌入 Val 来利用其 0 值的类型，也必须仅在其指针接收器上声明方法，否者可能会无意复制其嵌入类型值的内容： type Stats struct { a, b, c counter.Val } func (s Stats) Sum() int { return s.a.Get() + s.b.Get() + s.c.Get() // whoops（哎呀） } 维护值切片的类型可能会出现类似的陷阱，当然也有可能发生意外的数据竞争。 简而言之，我认为您更应该喜欢在 *T 上声明方法，除非您有非常充分的理由不该这样做。 我们说 T 但这只是您声明的类型的占位符； 此规则是递归的，取 *T 类型的变量的地址返回的是 **T 类型的结果； 这就是为什么没有人可以在像 int 这样的基础类型上声明方法； Go 中的方法只是将接受者作为第一个形式参数传递的函数的语法糖； 如果方法不改变它的接收者，它是否需要是一个方法吗？ 相关文章： What is the zero value, and why is it useful? Ice cream makers and data races Slices from the ground up The empty struct 最后，此篇文章我是第一次尝试翻译英文文章，尽管英文水平不太好，一些单词不认识，但是相信自己翻译一篇文章可以学习英语与理解 Go 设计获取 double 的乐趣。 ","date":"2021-06-27","objectID":"/go-metheds-on-t/:0:0","tags":["go","translate"],"title":"[译] 方法是否应该在 T 或 *T 上声明","uri":"/go-metheds-on-t/"},{"categories":["summary"],"content":"距离最后一篇博文 《Go 语言开发设计指北》发布已经过去一个多月的时间了，在这一段的时间里，在看了大量的书籍?，在工作上安排的工作都比较得心应手，时间还算比较充裕，但是懒惰心里没有丝毫退去 ?，这样是不行的，很容易让自己的思维和学习能力下降。 先来谈谈近期阅读的一些文章吧，《高性能 MySQL》这一本书相信是计算机从业人员必读的一本书 ? 了吧，这本书虽然看起来比较厚，但是里面的知识面和富有情趣的讲解还是很不错的，给作者点个赞，现在是第一遍读这本书，本着：“先把书读薄”的原则来读，已经攻读了3章多了，学到了很多实际中业务开发的宝贵经验，但是在实际设计中还是会落入坑中，学到了主键、索引设计技巧，以及具体是怎么去使用的，自己所书写的每一条 SQL 语句是在 MySQL中是怎样运行的，执行效率如何，是否可以优化，以及怎么去衡量自己优化的效率可以达到多少，在这本书中都有所讲解。 第二本就是在极客时间上追更鸟窝大神的《Go语言并发实战》，学习了学多的Go语言并发设计所使用到的并发原语及处理方法，包括 Mutex、RWMutex、WaitGroup、Pool、Once、Context等等操作及内部实现，emmm 目前看老师已经更新完了 自己还没有追更完，惭愧呀，Flag 要树立起来了，哈哈。 第三本是《GC的认识》，在开发过程中，自己在业务代码的设计中无需考虑变量声明后销毁的流程，因为在Go语言中已经实现了对堆栈资源的销毁与清理，但是GC是怎么操作的自己之前都是模糊的了解有三色标记，从根出发标记，很笼统的概念，近期看的这本书，严格意义上一笔记，就讲解了GC的执行过程，怎么去观察GC操作以及怎么去对GC优化等操作，详细的就不展开了，大家感兴趣的可以去看一下。 还有就是一些小的细节点的学习了，还有对自己项目组中的项目及框架了解了一下，这里就不分享啦，实际上是不知道是否存在蟹蜜危机。 毕竟上一篇文章发布的时候就战战兢兢 。 结尾呼应标题，这是一篇水文，主要是想告诉大家 Meng小羽并没有跑路 Debug客栈 还在，另外希望大家有好的分享资料的分享的话可以和我互动或者加入我的群聊，毕竟 1+1 \u003e 2 的，对吧。好了不多说了，跑步去了 ?。 ","date":"2021-04-24","objectID":"/debuginn-2021-emmm/:0:0","tags":["碎碎念"],"title":"emmm 这是一篇碎碎念","uri":"/debuginn-2021-emmm/"},{"categories":["golang"],"content":"Go 语言是一种强类型、编译型的语言，在开发过程中，代码规范是尤为重要的，一个小小的失误可能会带来严重的事故，拥有一个良好的 Go 语言开发习惯是尤为重要的，遵守开发规范便于维护、便于阅读理解和增加系统的健壮性。 以下是我们项目组开发规范加上自己开发遇到的问题及补充，希望对你有所帮助： 注：我们将以下约束分为三个等级，分别是：【强制】、【推荐】、【参考】。 ","date":"2021-03-07","objectID":"/go-dev-design/:0:0","tags":["go","mysql","redis","code review","log","stat","go fmt"],"title":"Go 语言开发设计指北","uri":"/go-dev-design/"},{"categories":["golang"],"content":"Go 编码相关 【强制】代码风格规范遵循 go 官方标准：CodeReviewComments，请使用官方 golint lint 进行风格静态分析； 【强制】代码格式规范依照 gofmt，请安装相关 IDE 插件，在保存代码或者编译时，自动将源码通过 gofmt 做格式化处理，保证团队代码格式一致（比如空格，递进等） 【强制】业务处理代码中不能开 goroutine，此举会导致 goroutine 数量不可控，容易引起系统雪崩，如果需要启用 goroutine 做异步处理，请在初始化时启用固定数量 goroutine，通过 channel 和业务处理代码交互，初始化 goroutine 的函数，原则上应该从 main 函数入口处明确的调用： func crond() { defer func() { if err := recover(); err != nil { // dump stack \u0026 log } }() // do something } func main() { // init system go crond() go crond2() // handlers } 【强制】异步开启 goroutine 的地方（如各种 cronder )，需要在最顶层增加 recover()，捕捉 panic，避免个别 cronder 出错导致整体退出： func globalCrond() { for _ := ticker.C { projectCrond() itemCrond() userCrond() } } func projectCrond() { defer func() { if err := recover(); err != nil { // 打日志，并预警 } } // do } 【强制】当有并发读写 map 的操作，必须加上读写锁 RWMutex，否则 go runtime 会因为并发读写报 panic，或者使用 sync.Map 替代； 【强制】对于提供给外部使用的 package，返回函数里必须带上 err 返回，并且保证在 err == nil 情况下，返回结果不为 nil，比如： resp, err := package1.GetUserInfo(xxxxx) // 在err == nil 情况下，resp不能为nil或者空值 【强制】当操作有多个层级的结构体时，基于防御性编程的原则，需要对每个层级做空指针或者空数据判别，特别是在处理复杂的页面结构时，如： type Section struct { Item *SectionItem Height int64 Width int64 } type SectionItem struct { Tag string Icon string ImageURL string ImageList []string Action *SectionAction } type SectionAction struct { Type string Path string Extra string } func getSectionActionPath(section *Section) (path string, img string, err error) { if section.Item == nil || section.Item.Action == nil { // 要做好足够防御，避免因为空指针导致的panic err = fmt.Errorf(\"section item is invalid\") return } path = section.Item.Action.Path img = section.Item.ImageURL // 对取数组的内容，也一定加上防御性判断 if len(section.Item.ImageList) \u003e 0 { img = section.Item.ImageList[0] } return } 【推荐】生命期在函数内的资源对象，如果函数逻辑较为复杂，建议使用 defer 进行回收： func MakeProject() { conn := pool.Get() defer pool.Put(conn) // 业务逻辑 ... return } 对于生命期在函数内的对象，定义在函数内，将使用栈空间，减少 gc 压力： func MakeProject() (project *Project){ project := \u0026Project{} // 使用堆空间 var tempProject Project // 使用栈空间 return } 【强制】不能在循环里加 defer，特别是 defer 执行回收资源操作时。因为 defer 是函数结束时才能执行，并非循环结束时执行，某些情况下会导致资源（如连接资源）被大量占用而程序异常： // 反例： for { row, err := db.Query(\"SELECT ...\") if err != nil { ... } defer row.Close() // 这个操作会导致循环里积攒许多临时资源无法释放 ... } // 正确的处理，可以在循环结束时直接close资源，如果处理逻辑较复杂，可以打包成函数： for { func () { row, err := db.Query(\"SELECT ...\") if err != nil { ... } defer row.Close() ... }() } 【推荐】对于可预见容量的 slice 或者 map，在 make 初始化时，指定cap大小，可以大大降低内存损耗，如： headList := make([]home.Sections, 0, len(srcHomeSection)/2) tailList := make([]home.Sections, 0, len(srcHomeSection)/2) dstHomeSection = make([]*home.Sections, 0, len(srcHomeSection)) …. if appendToHead { headList = append(headList, info) } else { tailList = append(tailList, info) } …. dstHomeSection = append(dstHomeSection, headList…) dstHomeSection = append(dstHomeSection, tailList…) 【推荐】逻辑操作中涉及到频繁拼接字符串的代码，请使用 bytes.Buffer 替代。使用 string 进行拼接会导致每次拼接都新增 string 对象，增加 GC 负担： // 正例： var buf bytes.Buffer for _, name := range userList { buf.WriteString(name) buf.WriteString(\",\") } return buf.String() // 反例： var result string for _, name := range userList { result += name + \",\" } return result 【强制】对于固定的正则表达式，可以在全局变量初始化时完成预编译，可以有效加快匹配速度，不需要在每次函数请求中预编译： var wordReg = regexp.MustCompile(\"[\\\\w]+\") func matchWord(word string) bool { return wordReg.MatchString(word) } 【推荐】JSON 解析时，遇到不确定是什么结构的字段，建议使用 json.RawMessage 而不要用 interface，这样可以根据业务场景，做二次 unmarshal 而且性能比 interface 快很多； 【强制】锁使用的粒度需要根据实际情况进行把控，如果变量只读，则无需加锁；读写，则使用读写锁 sync.RWMutex； 【强制】使用随机数时(math/rand)，必须要做随机初始化(rand.Seed)，否则产生出的随机数是可预期的，在某些场合下会带来安全问题。一般情况下，使用math/rand可以满足业务需求，如果开发的是安全模块，建议使用crypto/rand，安全性更好； 【推荐】对性能要求很高的服务，或者对程序响应时间要求高的服务，应该避免开启大量 gouroutine； 说明：官方虽然号称 goroutine 是廉价的，可以大量开启 goroutine，但是由于 goroutine 的调度并没有实现优先级控制，使得一些关键性的 goroutine（如网络/磁盘IO，控制全局资源的goroutine）没有及时得到调度而拖慢了整体服务的响应时间，因而在系统设计时，如果对性能要求很高，应避免开启大量goroutine。 ","date":"2021-03-07","objectID":"/go-dev-design/:1:0","tags":["go","mysql","redis","code review","log","stat","go fmt"],"title":"Go 语言开发设计指北","uri":"/go-dev-design/"},{"categories":["golang"],"content":"打点规范 【强制】打点使用.来做分隔符，打点名称需要包含业务名，模块，函数，函数处理分支等，参考如下： // 业务名.服务名.模块.功能.方法 service.gateway.module.action.func 【强制】打点使用场景是监控系统的实时状态，不适合存储任何业务数据； 【强制】在打点个数太多时，展示时速度会变慢。建议单个服务打点的key不超过10000个，key中单个维度不同值不超过 1000个（千万不要用 user_id 来打点)； 【推荐】如果展示的时候需要拿成百上千个key的数据通过 Graphite 的聚合函数做聚合，最后得到一个或几个 key。这种情况下可以在打点的时候就把这个要聚合的点聚合好，这样展示的时候只要拿这几个 key，对展示速度是巨大的提升。 ","date":"2021-03-07","objectID":"/go-dev-design/:2:0","tags":["go","mysql","redis","code review","log","stat","go fmt"],"title":"Go 语言开发设计指北","uri":"/go-dev-design/"},{"categories":["golang"],"content":"日志相关 【强制】日志信息需带上下文，其中 logid 必须带上，同一个请求打的日志都需带上 logid，这样可以根据 logid 查找该次请求相关的信息； 【强制】对debug/notice/info 级别的日志输出，必须使用条件输出或者使用占位符方式，避免使用字符拼接方式： log.Debug(\"get home page failed %s, id %d\", err, id) 【强制】如果是解析 json 出错的日志，需要将报错 err 及原内容一并输出，以方便核查原因； 【推荐】对debug/notice/info级别的日志，在打印日志时，默认不显示调用位置（如/path/to/code.go:335） 说明：go 获取调用栈信息是比较耗时的操作(runtime.Caller)，对于性能要求很高的服务，特别是大量调用的地方，应尽量避免开发人员在使用该功能时，需知悉这个调用带来的代价。 ","date":"2021-03-07","objectID":"/go-dev-design/:3:0","tags":["go","mysql","redis","code review","log","stat","go fmt"],"title":"Go 语言开发设计指北","uri":"/go-dev-design/"},{"categories":["golang"],"content":"Redis 相关 【推荐】统一使用:作为前缀后缀分隔符，这里可以根据 Redis 中间件 key proxy 怎么解析分析 Key 进行自定义，便于基础服务的数据可视化及问题排查； 【强制】避免使用 HMGET/HGETALL/HVALS/HKEYS/SMEMBERS 阻塞命令这类命令在 value 较大时，对 Redis 的 CPU/带宽消耗较高，容易导致响应过慢引发系统雪崩； 【强制】不可把 Redis 当成存储，如有统计相关的需求，可以考虑异步同步到数据库进行统计，Redis 应该回归缓存的本质； 【推荐】避免使用大 key，按经验超过 10k 的 value，可以压缩(gzip/snappy等算法)后存入内存，可以减少内存使用，其次降低网络消耗，提高响应速度： value, err := c.RedisCache.GetGzip(key) …. c.RedisCache.SetExGzip(content, 60) 【推荐】Redis 的分布式锁，可以使用: lock: redis.Do(\"SET\", lockKey, randint, \"EX\", expire, \"NX\") unlock: redis.GetAndDel(lockKey, randint) // redis暂不支持，可以用lua脚本 【推荐】尽量避免在逻辑循环代码中调用 Redis，会产生流量放大效应，请求量较大时需采用其他方法优化（比如静态配置文件）； 【推荐】key 尽量离散读写，通过uid/imei/xid等跟用户/请求相关的后缀分摊到不同分片，避免分片负载不均衡； 【参考】当缓存量大，请求量较高，可能超出 Redis 承受范围时，可充分利用本地缓存(localcache)+redis缓存的组合方案来缓解压力，削减峰值： 使用这个方法需要具备这几个条件： cache 内容与用户无关，key 状态不多，属于公共信息； 该cache内容时效性较高，但是访问量较大，有峰值流量。 key := \"demoid:3344\" value := localcacche.Get(key) if value == \"\" { value = rediscache.Get(key) if value != \"\" { // 随机缓存 1~5s，各个机器间错开峰值，只要比 redis缓存短即可 localcache.SetEx(key, value, rand.Int63n(5)+1) } } if value == \"\" { .... // 从其他系统或者数据库获取数据 appoint.GetValue() // 同时设置到redis及localcache中 rediscache.SetEx(key, content, 60) localcache.SetEx(key, content, rand.Int63n(5)+1) } 【参考】对于请求量高，实时性也高的内容，如果纯粹使用缓存，当缓存失效瞬间，会导致大量请求穿透到后端服务，导致后端服务有雪崩危险： 如何兼顾扛峰值，保护后端系统，同时也能保持实时性呢？在这种场景下，可以采用随机更新法更新数据，方法如下： 正常请求从缓存中读取，缓存失效则从后端服务获取； 在请求中根据随机概率 1%（或者根据实际业务场景设置比率）会跳过读取缓存操作，直接从后端服务获取数据，并更新缓存。 这种做法能保证最低时效性，并且当访问量越大，更新概率越高，使得内容实时性也越高。 如果结合上一条 localcache+rediscache 做一二级缓存，则可以达到扛峰值同时保持实时性。 ","date":"2021-03-07","objectID":"/go-dev-design/:4:0","tags":["go","mysql","redis","code review","log","stat","go fmt"],"title":"Go 语言开发设计指北","uri":"/go-dev-design/"},{"categories":["golang"],"content":"数据库相关 【强制】操作数据库 sql 必须使用 stmt 格式，使用占位符替代参数，禁止拼接 sql； 【强制】SQL语句查询时，不得使用 SELECT * （即形如 SELECT * FROM tbl WHERE），必须明确的给出要查询的列名，避免表新增字段后报错； 【强制】对于线上业务 SQL，需保证命中索引，索引设计基于业务需求及字段区分度，一般可区分状态不高的字段（如 status 等只有几个状态），不建议加到索引中； 【强制】在成熟的语言中，有实体类，数据访问层(repository / dao)和业务逻辑层( service )；在我们的规范中存储实体 struct 放置于 entities 包下； 【强制】对于联合索引，需将区分度较大的字段放前面，区分度小放后面，查找时可以减少被检索数据量； -- 字段区分度 item_id \u003e project_id alter table xxx add index idx_item_project ( item_id , project_id ) 【强制】所有数据库表必须有主键 id； 【强制】主键索引名为 pk字段名; 唯一索引名为 uk字段名; 普通索引名则为 idx_字段名； 【强制】防止因字段类型不同造成的隐式转换，导致索引失效，造成全表扫描问题； 【强制】业务上有唯一特性的字段，即使是多字段的组合，也必须建成唯一索引； 【强制】一般事务标准操作流程： func TestTXExample(t *testing.T) { // 打开事务 tx, err := db.Beginx() if err != nil { log.Fatal(\"%v\", err) return } // defer异常 needRollback := true defer func() { if r := recover(); r != nil { // 处理recover，避免因为panic，资源无法释放 log.Fatal(\"%v\", r) needRollback = true } if needRollback { xlog.Cause(\"test.example.transaction.rollback\").Fatal() tx.Rollback() } }() // 事务的逻辑 err = InsertLog(tx, GenTestData(1)[0]) if err != nil { log.Fatal(\"%v\", err) return } // 提交事务 err = tx.Commit() if err != nil { log.Fatal(\"%v\", err) return } needRollback = false return } 【强制】执行事务操作时，请确保SELECT ... FOR UPDATE条件命中索引，使用行锁，避免一个事务锁全表的情况; 【强制】禁止超过三个表的 join，需要 join 的字段，数据类型必须一致，多表关联查询时，保证被关联的字段有索引; 【强制】数据库 max_open 连接数不可设置过高，会导致代理连接数打满导致不可用状况; ","date":"2021-03-07","objectID":"/go-dev-design/:5:0","tags":["go","mysql","redis","code review","log","stat","go fmt"],"title":"Go 语言开发设计指北","uri":"/go-dev-design/"},{"categories":["summary"],"content":"2021 年的一月份马上就过去了，在这一个月中，并没有新鲜出炉的博文，恰恰相反的是我这一个月以来，在思考，自己的博客怎么输出高质量有水平的文章，正如一首优美的旋律，怎么听都可以让人回味无穷，每一遍都有自己的收获。 关于提升自己博客文章的水平，这个月思考了很多的方向，也阅读了不少人对于博客的看法和理解，最终对自己博客总结了几点不足之处： 看到及听到一种新技术或者新的事物，总是以为看了几篇的相关的文章介绍及简短的理解文章，就认为自己了解了某一个事物或者技术，之后输出自己的想法，写出一篇总结的文章，理所应当的写不出有深度有营养的文章； 写一篇博文访问量的关注与文章输出的内容对比更倾向于前者，突然感觉到自己很肤浅，本末倒置，好的文章输出最不用关心的就是访问量的问题； 博文不是自己的 OKR，而是自己技术的自留地，入职大厂之后，感觉自己的技术文章输出应该高出一个层次，一些浅显易懂的或者容易学到的点就不需要总结成文章了，眼高手低，没有认清自己的技术与输出的水平； 自己的技术储备不足（看的书及教程少），博客中一些文章还停留在了解的层次，并没有真正的去 Get 到每个的深层次的水平中去； 懒惰的心理，短视频及游戏 ? VS Debug客栈，大部分时间选择前者，但是前者看了再多，玩的再6，也提升不了自己，只能当算法喂养下的白痴。 毫不夸张的说，若是把博客水平比做成人的一生，我的博客水平依旧处在了18岁之前，没有自己的思考，更多的是在教程、分享的模版下输出，虽有输出，但今天的我发现并没有太多的营养。 正如上方的分割线，我希望自己未来的输出在这里是一个分水岭，接下来自己可以学到更多，变得更强，让自己输出的文章有深度，自己的编程技术更加有水平。 回归主题，“如何提升自己的技术博文水平”，其实映射出是自己的技术水平的不足导致的，那如何提升自己的技术水平，自己总结了一下接下来要做的努力： 阅读技术书籍，技术不能停留在会使用的阶段，要知道自己的每一步操作，在计算机内部发生了什么，原理及使用的技术是什么，现在的我谈不上如何去改进某个技术，但是要会灵活的使用现有技术提升自己的编程水平，提高自己代码的稳定性及让自己的代码写出来如诗一般优雅； 在本职工作中，多看项目组及同事的代码，不仅仅是看代码，思考为什么这样设计，这样设计带来的好处是什么，会有哪些不足，如何改进及优化； 在流行的技术及 Go 语言包中，加入到开源的项目中去，多去看大佬们的代码及设计哲学，了解业界技术的更迭及主流用法，可以的话贡献自己的代码； 多去交流技术，不能认为自己代码很 Low，没有了解很多就对研讨会或者分享会望而却步，恰恰相反，自己在这些分享会中会发现自己的水平处在什么阶段及自己如何去提升自己； 多去整理学过了、了解到的技术的笔记，学会提炼及吸收成自己的知识体系： 这是自己搭建的笔记平台：https://notes.debuginn.cn 自己的学习笔记都会同步至此平台，更多的是自己的学习笔记及重要的知识点，这就是我的小本本。 最后，感谢自己导师的教诲与提醒，自己要更加的努力，提升自己，2021，定不负大家的厚望，努力成为项目组中的中坚力量，加油！！！撰写出更多有营养的文章，当然，有些理解片面或者不足的文章还请大家批评指出，谢谢 ","date":"2021-01-30","objectID":"/debuginn-write-blog/:0:0","tags":["技术","博文"],"title":"如何提升自己的技术博文水平","uri":"/debuginn-write-blog/"},{"categories":["summary"],"content":"今年，最大的感受就是时间过的太快了，一切都是那么的来不及 …… 2020 年，疫情、毕业、工作，学生时代的 END，社会人时代的 START …… 2021 年，希望一切都在慢慢变好，新的开始、新的未来！！！ 每一次总结都是新的开始的起点，那么，接下来就开始吧～ ","date":"2020-12-31","objectID":"/debuginn-2020/:0:0","tags":["Debug客栈","2020","2021","年度总结"],"title":"2020 年度总结","uri":"/debuginn-2020/"},{"categories":["summary"],"content":"网站数据 今年是小站运行的第 4 年，感谢大家的支持与访问，这是我分享的天地、同时也是见证我成长的地方，加油～ 一往无前 ！！！ ","date":"2020-12-31","objectID":"/debuginn-2020/:1:0","tags":["Debug客栈","2020","2021","年度总结"],"title":"2020 年度总结","uri":"/debuginn-2020/"},{"categories":["summary"],"content":"最受欢迎的文章 Restful API 设计指北 https://www.debuginn.cn/5178.html 吊打百度，多吉搜索引擎 程序猿的 Chrome 浏览器插件推荐 搭建流媒体服务器 PingOS 平台搭建 怎么优雅的选择 MySQL 存储引擎 ","date":"2020-12-31","objectID":"/debuginn-2020/:2:0","tags":["Debug客栈","2020","2021","年度总结"],"title":"2020 年度总结","uri":"/debuginn-2020/"},{"categories":["summary"],"content":"More 页面 2020 看见的我不止一面，这里记录了我的 MORE https://www.debuginn.cn/more ","date":"2020-12-31","objectID":"/debuginn-2020/:3:0","tags":["Debug客栈","2020","2021","年度总结"],"title":"2020 年度总结","uri":"/debuginn-2020/"},{"categories":["golang"],"content":"Mutex 是用来保证只有一个 goroutine 访问共享资源，在大量的并发场景中，特别是读场景中，一个共享资源块只能让 goroutine 串行访问，这就导致了性能的影响，解决方法就是区分读写操作。 这样就可以将串行的读变成并行的读，用来提高读操作的性能。 Go 标准库 RWMutex （读写锁）就是用来解决 readers-writers 问题的。 ","date":"2020-12-05","objectID":"/go-concurrence-rw-mutex/:0:0","tags":["go","concurrence","RWMutex"],"title":"Go 并发编程之 RWMutex","uri":"/go-concurrence-rw-mutex/"},{"categories":["golang"],"content":"RWMutex 标准库中的 RWMutex 是一个 reader/writer 互斥锁，RWMutex 在同一时间只能由 n 个 reader 持有，或者只能被单个的 writer 持有。 Lock/Unlock：写操作时调用的方法，若是被 reader 或者 writer 持有， Lock 会一直阻塞，直到可以获取到锁，Ulock 是释放锁； Rlock/RUnlock：读操作时低哦用的方法，如果已经被 writer 持有的话， Rlock 会一直阻塞，直到获取到锁，否者直接返回， RUlock 是 reader 释放锁的方法； RLocker：为读操作返回一个 Locker 接口的对象。 RWMutex 的零值是未加锁的状态，所以在使用 RWMutex 作为变量或者嵌入到 struct 中去，都没有必要进行显式的初始化。 ","date":"2020-12-05","objectID":"/go-concurrence-rw-mutex/:1:0","tags":["go","concurrence","RWMutex"],"title":"Go 并发编程之 RWMutex","uri":"/go-concurrence-rw-mutex/"},{"categories":["golang"],"content":"实现原理 针对于 readers-writers 问题是基于对读和写操作的优先级，读写锁的设计分为三类： Read-preferring 读优先设计：并发效果好，但是在大量的并发场景下会导致写饥饿； Write-preferring 写优先设计：针对新请求而言，主要是避免了 writer 饥饿问题，也就是说同一时间有一个 reader 和 writer 等待获取锁，会优先给 writer； 不指定优先级：FIFO，不区分读写优先级，适用于某些特定的场景。 RWMutex 设计是 write-preferring 写优先设计。一个正在阻塞的 Lock 调用会排出新的 reader 请求到锁。 RWMutex 包含一个 Mutex，以及四个辅助字段 writerSem、readerSem、readerCount 和 readerWait： type RWMutex struct { w Mutex // 互斥锁解决多个 writer 的竞争 writerSem uint32 // writer 信号量 readerSem uint32 // reader 信号量 readerCount int32 // reader 的数量，记录当前 reader 等待的数量 readerWait int32 // writer 等待完成的 reader的 数量 } const rwmutexMaxReaders = 1 \u003c\u003c 30 ","date":"2020-12-05","objectID":"/go-concurrence-rw-mutex/:2:0","tags":["go","concurrence","RWMutex"],"title":"Go 并发编程之 RWMutex","uri":"/go-concurrence-rw-mutex/"},{"categories":["golang"],"content":"RLock/RUlock 实现 func (rw *RWMutex) RLock() { // 对 reader 计数 +1，readerCount 会出现负数 // 1、没有 writer 竞争或者持有锁的时候，readerCount 充当计数器存在 // 2、如果有 writer 竞争锁或者持有锁时，那么，readerCount 不仅仅承担着 reader 的计数功能，还能够标识当前是否有 writer 竞争或持有锁 if atomic.AddInt32(\u0026rw.readerCount, 1) \u003c 0 { // rw.readerCount 是负值的时候，意味着此时有 writer 等待请求锁 // 因为writer优先级高，所以把后来的 reader 阻塞休眠 runtime_SemacquireMutex(\u0026rw.readerSem, false, 0) } } func (rw *RWMutex) RUnlock() { // 将 reader 计数 -1 if r := atomic.AddInt32(\u0026rw.readerCount, -1); r \u003c 0 { // 如果为 负数，代表着当前有 writer 在竞争锁，检查是不是所有的 reader 都将锁释放 // 若释放了就让 writer 获取到锁进行写操作 rw.rUnlockSlow(r) // 有等待的writer } } func (rw *RWMutex) rUnlockSlow(r int32) { // rUnlockSlow 将持有锁的 reader 计数 -1 的时候； // 会检查既有的 reader 是不是都已经释放了锁； // 如果都释放了锁，就会唤醒 writer，让 writer 持有锁。 if atomic.AddInt32(\u0026rw.readerWait, -1) == 0 { // 最后一个reader了，writer终于有机会获得锁了 runtime_Semrelease(\u0026rw.writerSem, false, 1) } } ","date":"2020-12-05","objectID":"/go-concurrence-rw-mutex/:2:1","tags":["go","concurrence","RWMutex"],"title":"Go 并发编程之 RWMutex","uri":"/go-concurrence-rw-mutex/"},{"categories":["golang"],"content":"Lock / Unlock RWMutex 是一个多 writer 多 reader 的读写锁，所以同时可能有多个 writer 和 reader。那么，为了避免 writer 之间的竞争，RWMutex 就会使用一个 Mutex 来保证 writer 的互斥。 func (rw *RWMutex) Lock() { // 首先解决其他 writer 竞争问题 rw.w.Lock() // 反转 readerCount，告诉 reader 有 writer 竞争锁 r := atomic.AddInt32(\u0026rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders // 如果当前有 reader 持有锁，那么需要等待 if r != 0 \u0026\u0026 atomic.AddInt32(\u0026rw.readerWait, r) != 0 { runtime_SemacquireMutex(\u0026rw.writerSem, false, 0) } } 一旦一个 writer 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(\u003e=0) 修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。 func (rw *RWMutex) Unlock() { // 告诉 reader 没有活跃的 writer 了 r := atomic.AddInt32(\u0026rw.readerCount, rwmutexMaxReaders) // 唤醒阻塞的 reader 们 for i := 0; i \u003c int(r); i++ { runtime_Semrelease(\u0026rw.readerSem, false, 0) } // 释放内部的互斥锁 rw.w.Unlock() } 当一个 writer 释放锁的时候，它会再次反转 readerCount 字段。可以肯定的是，因为当前锁由 writer 持有，所以，readerCount 字段是反转过的，并且减去了 rwmutexMaxReaders 这个常数，变成了负数。 所以，这里的反转方法就是给它增加 rwmutexMaxReaders 这个常数值。既然 writer 要释放锁了，那么就需要唤醒之后新来的 reader，不必再阻塞它们了，让它们开开心心地继续执行就好了。 在 RWMutex 的 Unlock 返回之前，需要把内部的互斥锁释放。释放完毕后，其他的 writer 才可以继续竞争这把锁。 ","date":"2020-12-05","objectID":"/go-concurrence-rw-mutex/:2:2","tags":["go","concurrence","RWMutex"],"title":"Go 并发编程之 RWMutex","uri":"/go-concurrence-rw-mutex/"},{"categories":["golang"],"content":"RWMutex 常犯的三种错误 不可复制 重入导致死锁 释放未加锁的 RWMutex ","date":"2020-12-05","objectID":"/go-concurrence-rw-mutex/:2:3","tags":["go","concurrence","RWMutex"],"title":"Go 并发编程之 RWMutex","uri":"/go-concurrence-rw-mutex/"},{"categories":["golang"],"content":"我们比较常见的大型项目的设计中都会出现并发访问问题，并发就是为了解决数据的准确性，保证同一个临界区的数据只能被一个线程进行操作，日常中使用到的并发场景也是很多的： 计数器：计数器结果不准确； 秒杀系统：由于同一时间访问量比较大，导致的超卖； 用户账户异常：同一时间支付导致的账户透支； buffer 数据异常：更新 buffer 导致的数据混乱。 上面都是并发带来的数据准确性的问题，决绝方案就是使用互斥锁，也就是今天并发编程中的所要描述的 Mutex 并发原语。 ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:0:0","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"实现机制 互斥锁 Mutex 就是为了避免并发竞争建立的并发控制机制，其中有个“临界区”的概念。 在并发编程过程中，如果程序中一部分资源或者变量会被并发访问或者修改，为了避免并发访问导致数据的不准确，这部分程序需要率先被保护起来，之后操作，操作结束后去除保护，这部分被保护的程序就叫做临界区。 使用互斥锁，限定临界区只能同时由一个线程持有，若是临界区此时被一个线程持有，那么其他线程想进入到这个临界区的时候，就会失败或者等待释放锁，持有此临界区的线程退出，其他线程才有机会获得这个临界区。 Mutex 是 Go 语言中使用最广泛的同步原语，也称为并发原语，解决的是并发读写共享资源，避免出现数据竞争 data race 问题。 ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:1:0","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"基本使用 互斥锁 Mutex 提供了两个方法 Lock 和 Unlock：进入到临界区使用 Lock 方法加锁，退出临界区使用 Unlock 方法释放锁。 type Locker interface { Lock() Unlock() } func(m *Mutex)Lock() func(m *Mutex)Unlock() 当一个 goroutine 调用 Lock 方法获取到锁后，其他 goroutine 会阻塞在 Lock 的调用上，直到当前获取到锁的 goroutine 释放锁。 接下来是一个计数器的例子，是由 100 个 goroutine 对计数器进行累加操作，最后输出结果： package main import ( \"fmt\" \"sync\" ) func main() { var mu sync.Mutex countNum := 0 // 确认辅助变量是否都执行完成 var wg sync.WaitGroup // wg 添加数目要和 创建的协程数量保持一致 wg.Add(100) for i := 0; i \u003c 100; i++ { go func() { defer wg.Done() for j := 0; j \u003c 1000; j++ { mu.Lock() countNum++ mu.Unlock() } }() } wg.Wait() fmt.Printf(\"countNum: %d\", countNum) } ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:2:0","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"实际使用 很多时候 Mutex 并不是单独使用的，而是嵌套在 Struct 中使用，作为结构体的一部分，如果嵌入的 struct 有多个字段，我们一般会把 Mutex 放在要控制的字段上面，然后使用空格把字段分隔开来。 甚至可以把获取锁、释放锁、计数加一的逻辑封装成一个方法。 package main import ( \"fmt\" \"sync\" ) // 线程安全的计数器 type Counter struct { CounterType int Name string mu sync.Mutex count uint64 } // 加一方法 func (c *Counter) Incr() { c.mu.Lock() defer c.mu.Unlock() c.count++ } // 取数值方法 线程也需要受保护 func (c *Counter) Count() uint64 { c.mu.Lock() defer c.mu.Unlock() return c.count } func main() { // 定义一个计数器 var counter Counter var wg sync.WaitGroup wg.Add(100) for i := 0; i \u003c 100; i++ { go func() { defer wg.Done() for j := 0; j \u003c 1000; j++ { counter.Incr() } }() } wg.Wait() fmt.Printf(\"%d\\n\", counter.Count()) } ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:3:0","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"思考问题 Q：你已经知道，如果 Mutex 已经被一个 goroutine 获取了锁，其它等待中的 goroutine 们只能一直等待。那么，等这个锁释放后，等待中的 goroutine 中哪一个会优先获取 Mutex 呢？ A：FIFO，先来先服务的策略，Go 的 goroutine 调度中，会维护一个保障 goroutine 运行的队列，当获取到锁的 goroutine 执行完临界区的操作的时候，就会释放锁，在队列中排在第一位置的 goroutine 会拿到锁进行临界区的操作。 ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:4:0","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"实现原理 Mutex 的架构演进目前分为四个阶段： 初版 Mutex：使用一个 flag 变量表示锁?是否被持有； 给新人机会：照顾新来的 goroutine 先获取到锁； 多给些机会：照顾新来的和被唤醒的 goroutine 获取到锁； 解决饥饿：存在竞争关系，有饥饿情况发生，需要解决。 ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:5:0","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"初版 Mutex // 互斥锁的结构，包含两个字段 type Mutex struct { key int32 // 锁是否被持有的标识 sema int32 // 信号量专用，用以阻塞/唤醒goroutine } Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。 在使用 Mutex 的时候，需要严格遵循 “谁申请，谁释放” 原则。 ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:5:1","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"解决饥饿 由于使用了给新人机会，又肯呢个会出现每次都会被新来的 goroutine 获取到锁，导致等待的 goroutine 一直获取不到锁，造成饥饿问题。 type Mutex struct { state int32 sema uint32 } const ( mutexLocked = 1 \u003c\u003c iota // mutex is locked mutexWoken mutexStarving // 从state字段中分出一个饥饿标记 mutexWaiterShift = iota starvationThresholdNs = 1e6 ) func (m *Mutex) Lock() { // Fast path: 幸运之路，一下就获取到了锁 if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { return } // Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争 m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 starving := false // 此goroutine的饥饿标记 awoke := false // 唤醒标记 iter := 0 // 自旋次数 old := m.state // 当前的锁的状态 for { // 锁是非饥饿状态，锁还没被释放，尝试自旋 if old\u0026(mutexLocked|mutexStarving) == mutexLocked \u0026\u0026 runtime_canSpin(iter) { if !awoke \u0026\u0026 old\u0026mutexWoken == 0 \u0026\u0026 old\u003e\u003emutexWaiterShift != 0 \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() iter++ old = m.state // 再次获取锁的状态，之后会检查是否锁被释放了 continue } new := old if old\u0026mutexStarving == 0 { new |= mutexLocked // 非饥饿状态，加锁 } if old\u0026(mutexLocked|mutexStarving) != 0 { new += 1 \u003c\u003c mutexWaiterShift // waiter数量加1 } if starving \u0026\u0026 old\u0026mutexLocked != 0 { new |= mutexStarving // 设置饥饿状态 } if awoke { if new\u0026mutexWoken == 0 { throw(\"sync: inconsistent mutex state\") } new \u0026^= mutexWoken // 新状态清除唤醒标记 } // 成功设置新状态 if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { // 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回 if old\u0026(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // 处理饥饿状态 // 如果以前就在队列里面，加入到队列头 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 阻塞等待 runtime_SemacquireMutex(\u0026m.sema, queueLifo, 1) // 唤醒之后检查锁是否应该处于饥饿状态 starving = starving || runtime_nanotime()-waitStartTime \u003e starvationThresholdNs old = m.state // 如果锁已经处于饥饿状态，直接抢到锁，返回 if old\u0026mutexStarving != 0 { if old\u0026(mutexLocked|mutexWoken) != 0 || old\u003e\u003emutexWaiterShift == 0 { throw(\"sync: inconsistent mutex state\") } // 有点绕，加锁并且将waiter数减1 delta := int32(mutexLocked - 1\u003c\u003cmutexWaiterShift) if !starving || old\u003e\u003emutexWaiterShift == 1 { delta -= mutexStarving // 最后一个waiter或者已经不饥饿了，清除饥饿标记 } atomic.AddInt32(\u0026m.state, delta) break } awoke = true iter = 0 } else { old = m.state } } } func (m *Mutex) Unlock() { // Fast path: drop lock bit. new := atomic.AddInt32(\u0026m.state, -mutexLocked) if new != 0 { m.unlockSlow(new) } } func (m *Mutex) unlockSlow(new int32) { if (new+mutexLocked)\u0026mutexLocked == 0 { throw(\"sync: unlock of unlocked mutex\") } if new\u0026mutexStarving == 0 { old := new for { if old\u003e\u003emutexWaiterShift == 0 || old\u0026(mutexLocked|mutexWoken|mutexStarving) != 0 { return } new = (old - 1\u003c\u003cmutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(\u0026m.state, old, new) { runtime_Semrelease(\u0026m.sema, false, 1) return } old = m.state } } else { runtime_Semrelease(\u0026m.sema, true, 1) } } ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:5:2","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"思考问题 Q： 目前 Mutex 的 state 字段有几个意义，这几个意义分别是由哪些字段表示的？ A：state 字段一共有四个子字段，前三个 bit 是 mutexLocked（锁标记）、mutexWoken（唤醒标记）、mutexStarving（饥饿标记），剩余 bit 标示 mutexWaiter（等待数量）。 Q： 等待一个 Mutex 的 goroutine 数最大是多少？是否能满足现实的需求？ A：目前的设计来看取决于 state 的类型，目前是 int32，由于3个字节代表了状态，有 536870911，一个 goroutine 初始化的为 2kb，约等于 1024 GB 即 1TB，目前内存体量那么大的服务还是少有的，可以满足现在的使用。 常见错误的四种场景 Lock/Unlock 不是成对出现; Copy 已使用的 Mutex; 重入; 死锁。 ","date":"2020-11-15","objectID":"/go-concurrence-mutex/:6:0","tags":["go","concurrence","Mutex"],"title":"Go 并发编程之 Mutex","uri":"/go-concurrence-mutex/"},{"categories":["golang"],"content":"Brew 是 Mac 上包管理工具，和 Linux 上的 apt 、yum、rpm 一样，可以提供非图形化软件的安装，昨天在打造宇宙最强 IDE 的时候，使用brew工具更新了一下软件包，是我的 Go 版本升级到了最新版本，同时之前配置的多版本 Go 抹掉了，现在写一下记录，你如果需要的话可以使用一下。 之前写过一个使用 GVM 版本管理工具的文章，这个是第三方工具管理的，都比较好用，你可以根据自己的需求安装。 ","date":"2020-11-01","objectID":"/go-use-brew-switch-version/:0:0","tags":["go","brew"],"title":"优雅的使用 Brew 切换 Go 版本","uri":"/go-use-brew-switch-version/"},{"categories":["golang"],"content":"方案一 brew switch ","date":"2020-11-01","objectID":"/go-use-brew-switch-version/:1:0","tags":["go","brew"],"title":"优雅的使用 Brew 切换 Go 版本","uri":"/go-use-brew-switch-version/"},{"categories":["golang"],"content":"1 brew install brew install go ","date":"2020-11-01","objectID":"/go-use-brew-switch-version/:1:1","tags":["go","brew"],"title":"优雅的使用 Brew 切换 Go 版本","uri":"/go-use-brew-switch-version/"},{"categories":["golang"],"content":"2 brew switch ~ brew info go go: stable 1.15.3 (bottled), HEAD 使用 brew info go 命令你可以看到当前目前的 go 可以切换的版本，接下来就安装多个版本并且切换到对应的版本。 // 安装指定 go 版本 brew install go@\u003cversion\u003e // forexample brew install go@1.12.17 安装好了 之后使用 brew info go 查看是否可以切换了。 brew switch go 1.12.17 单纯的使用上面的命令你会发现，go 不能使用了，并且会出现下面的提示： ~ brew switch go 1.12.17 Cleaning /usr/local/Cellar/go/1.12.17 Cleaning /usr/local/Cellar/go/1.15.3 0 links created for /usr/local/Cellar/go/1.12.17 创建了零个连接，就代表着没有成功的将 go 版本指向你所需要的版本下，问题是什么呢？现将 go 版本切回 go 1.15.3，你会发现可以切换并正常使用： ~ brew switch go 1.15.3 Cleaning /usr/local/Cellar/go/1.12.17 Cleaning /usr/local/Cellar/go/1.15.3 3 links created for /usr/local/Cellar/go/1.15.3 ~ go version go version go1.15.3 darwin/amd64 定位这个原因你需要看看为什么没有未给 go 1.12.17 版本创建软连接，首先要找一下 go 默认安装的位置，使用 go env 查看安装目录： /usr/local/Cellar/go/ 使用 brew 工具在 MacOS Catalina 系统安装的位置。 进入到目录之后在 go 目录下只有刚才默认安装的 1.15.3 版本，并没有自己安装的版本，退出父级目录看到了下载的 go@1.12.17 版本，由于软连接连接的是上方的路径，需要将这个目录移动至 go 目录下： // 打开默认目录 cd /usr/local/Cellar/go/ // 退出目录 cd .. // 移动目录至 go 目录下 mv go@1.12.17 go/ // 重要！！！ 重命名文件夹 mv go@1.12.17 1.12.17 接下来使用切换命令 brew switch go \u003cversion\u003e 就可以切换环境了。 ","date":"2020-11-01","objectID":"/go-use-brew-switch-version/:1:2","tags":["go","brew"],"title":"优雅的使用 Brew 切换 Go 版本","uri":"/go-use-brew-switch-version/"},{"categories":["golang"],"content":"方案二 brew link 使用 Homebrew 3.2.9 验证。 1、安装新的版本： brew install go@1.16 // 安装 go 1.16 版本 2、移除原有的 go 版本软链 brew unlink go 3、指定新的版本软链 brew link go@1.16 ","date":"2020-11-01","objectID":"/go-use-brew-switch-version/:2:0","tags":["go","brew"],"title":"优雅的使用 Brew 切换 Go 版本","uri":"/go-use-brew-switch-version/"},{"categories":["golang"],"content":"近期做了一个需求，是检测某个 IP 是否在若干 IP 段内，做固定地点 IP 筛查，满足特定业务需求。 ","date":"2020-09-08","objectID":"/go-ip-segment-range-check/:0:0","tags":["go","ip"],"title":"Go IP 段范围校验","uri":"/go-ip-segment-range-check/"},{"categories":["golang"],"content":"解决方案 ","date":"2020-09-08","objectID":"/go-ip-segment-range-check/:1:0","tags":["go","ip"],"title":"Go IP 段范围校验","uri":"/go-ip-segment-range-check/"},{"categories":["golang"],"content":"PLAN A 点分十进制范围区分 简单来讲，就是将 IPv4 原有的四段，分别对比 IP 地址，查看每一段是否在 IP 段范围内，可以用于段控制在每一个特定段 0 ～ 255 内筛选，例如： 192.123.1.0 ～ 192.123.156.255 这样的比较规范的特定段可以实现简单的筛选，但是问题来了，不规则的连续 IP 段怎么排除？ 如下： IP段：192.168.1.0 ～ 192.172.3.255 IP： 192.160.0.255 这样就会出现问题，可以看到按照简单的分段对比，很明显校验不通过，但是这个 IP 还是存在在 IP 段中，方案只能针对统一分段下规则的IP段才可以区分。 ","date":"2020-09-08","objectID":"/go-ip-segment-range-check/:1:1","tags":["go","ip"],"title":"Go IP 段范围校验","uri":"/go-ip-segment-range-check/"},{"categories":["golang"],"content":"PLAN B 转整型对别 IP 地址可以转换为整数，可以将 IP 范围化整为 整数范围进行排查。 这种方式只需要将授为范围内的地址转换为整数，就可以将 IP 排查在外了。 ","date":"2020-09-08","objectID":"/go-ip-segment-range-check/:1:2","tags":["go","ip"],"title":"Go IP 段范围校验","uri":"/go-ip-segment-range-check/"},{"categories":["golang"],"content":"代码 以下是示例代码： package main import ( \"fmt\" \"strconv\" \"strings\" ) func main() { ipVerifyList := \"192.168.1.0-192.172.3.255\" ip := \"192.170.223.1\" ipSlice := strings.Split(ipVerifyList, `-`) if len(ipSlice) \u003c 0 { return } if ip2Int(ip) \u003e= ip2Int(ipSlice[0]) \u0026\u0026 ip2Int(ip) \u003c= ip2Int(ipSlice[1]) { fmt.Println(\"ip in iplist\") return } fmt.Println(\"ip not in iplist\") } func ip2Int(ip string) int64 { if len(ip) == 0 { return 0 } bits := strings.Split(ip, \".\") if len(bits) \u003c 4 { return 0 } b0 := string2Int(bits[0]) b1 := string2Int(bits[1]) b2 := string2Int(bits[2]) b3 := string2Int(bits[3]) var sum int64 sum += int64(b0) \u003c\u003c 24 sum += int64(b1) \u003c\u003c 16 sum += int64(b2) \u003c\u003c 8 sum += int64(b3) return sum } func string2Int(in string) (out int) { out, _ = strconv.Atoi(in) return } ","date":"2020-09-08","objectID":"/go-ip-segment-range-check/:2:0","tags":["go","ip"],"title":"Go IP 段范围校验","uri":"/go-ip-segment-range-check/"},{"categories":["golang"],"content":"限流器是后台服务中十分重要的组件，在实际的业务场景中使用居多，其设计在微服务、网关、和一些后台服务中会经常遇到。限流器的作用是用来限制其请求的速率，保护后台响应服务，以免服务过载导致服务不可用现象出现。 限流器的实现方法有很多种，例如 Token Bucket、滑动窗口法、Leaky Bucket等。 在 Golang 库中官方给我们提供了限流器的实现golang.org/x/time/rate，它是基于令牌桶算法（Token Bucket）设计实现的。 ","date":"2020-08-24","objectID":"/go-standard-lib-time-rate-pkg/:0:0","tags":["go","standard lib","time rate"],"title":"Go 标准库 限流器 time/rate 设计与实现","uri":"/go-standard-lib-time-rate-pkg/"},{"categories":["golang"],"content":"令牌桶算法 令牌桶设计比较简单，可以简单的理解成一个只能存放固定数量雪糕?的一个冰箱，每个请求可以理解成来拿雪糕的人，有且只能每一次请求拿一块?，那雪糕拿完了会怎么样呢？这里会有一个固定放雪糕的工人，并且他往冰箱里放雪糕的频率都是一致的，例如他 1s 中只能往冰箱里放 10 块雪糕，这里就可以看出请求响应的频率了。 令牌桶设计概念： 令牌：每次请求只有拿到 Token 令牌后，才可以继续访问； 桶：具有固定数量的桶，每个桶中最多只能放设计好的固定数量的令牌； 入桶频率：按照固定的频率往桶中放入令牌，放入令牌不能超过桶的容量。 也就是说，基于令牌桶设计算法就限制了请求的速率，达到请求响应可控的目的，特别是针对于高并发场景中突发流量请求的现象，后台就可以轻松应对请求了，因为到后端具体服务的时候突发流量请求已经经过了限流了。 ","date":"2020-08-24","objectID":"/go-standard-lib-time-rate-pkg/:1:0","tags":["go","standard lib","time rate"],"title":"Go 标准库 限流器 time/rate 设计与实现","uri":"/go-standard-lib-time-rate-pkg/"},{"categories":["golang"],"content":"具体设计 ","date":"2020-08-24","objectID":"/go-standard-lib-time-rate-pkg/:2:0","tags":["go","standard lib","time rate"],"title":"Go 标准库 限流器 time/rate 设计与实现","uri":"/go-standard-lib-time-rate-pkg/"},{"categories":["golang"],"content":"限流器定义 type Limiter struct { mu sync.Mutex // 互斥锁（排他锁） limit Limit // 放入桶的频率 float64 类型 burst int // 桶的大小 tokens float64 // 令牌 token 当前剩余的数量 last time.Time // 最近取走 token 的时间 lastEvent time.Time // 最近限流事件的时间 } limit、burst 和 token 是这个限流器中核心的参数，请求并发的大小在这里实现的。 在令牌发放之后，会存储在 Reservation 预约对象中： type Reservation struct { ok bool // 是否满足条件分配了 token lim *Limiter // 发送令牌的限流器 tokens int // 发送 token 令牌的数量 timeToAct time.Time // 满足令牌发放的时间 limit Limit // 令牌发放速度 } ","date":"2020-08-24","objectID":"/go-standard-lib-time-rate-pkg/:2:1","tags":["go","standard lib","time rate"],"title":"Go 标准库 限流器 time/rate 设计与实现","uri":"/go-standard-lib-time-rate-pkg/"},{"categories":["golang"],"content":"消费 Token Limiter 提供了三类方法供用户消费 Token，用户可以每次消费一个 Token，也可以一次性消费多个 Token。而每种方法代表了当 Token 不足时，各自不同的对应手段。 Wait、WaitN func (lim *Limiter) Wait(ctx context.Context) (err error) func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) 其中，Wait 就是 WaitN(ctx, 1)，在下面的方法介绍实现也是一样的。 使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 ( 小于 n )，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。 Allow、AllowN func (lim *Limiter) Allow() bool func (lim *Limiter) AllowN(now time.Time, n int) bool AllowN 方法表示，截止到当前某一时刻，目前桶中数目是否至少为 n 个，满足则返回 true，同时从桶中消费 n 个 token。 反之返回不消费 Token，false。 通常对应这样的线上场景，如果请求速率过快，就直接丢到某些请求。 Reserve、ReserveN 官方提供的限流器有阻塞等待式的 Wait，也有直接判断方式的 Allow，还有提供了自己维护预留式的，但核心的实现都是下面的 reserveN 方法。 func (lim *Limiter) Reserve() *Reservation func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation 当调用完成后，无论 Token 是否充足，都会返回一个Reservation *对象。 你可以调用该对象的 Delay() 方法，该方法返回了需要等待的时间。如果等待时间为 0，则说明不用等待。 必须等到等待时间结束之后，才能进行接下来的工作。 或者，如果不想等待，可以调用 Cancel() 方法，该方法会将 Token 归还。 func (lim *Limiter) reserveN(now time.Time, n int, maxFutureReserve time.Duration) Reservation { lim.mu.Lock() // 首先判断是否放入频率是否为无穷大 // 如果为无穷大，说明暂时不限流 if lim.limit == Inf { lim.mu.Unlock() return Reservation{ ok: true, lim: lim, tokens: n, timeToAct: now, } } // 拿到截至 now 时间时 // 可以获取的令牌 tokens 数量及上一次拿走令牌的时间 last now, last, tokens := lim.advance(now) // 更新 tokens 数量 tokens -= float64(n) // 如果 tokens 为负数，代表当前没有 token 放入桶中 // 说明需要等待，计算等待的时间 var waitDuration time.Duration if tokens \u003c 0 { waitDuration = lim.limit.durationFromTokens(-tokens) } // 计算是否满足分配条件 // 1、需要分配的大小不超过桶的大小 // 2、等待时间不超过设定的等待时长 ok := n \u003c= lim.burst \u0026\u0026 waitDuration \u003c= maxFutureReserve // 预处理 reservation r := Reservation{ ok: ok, lim: lim, limit: lim.limit, } // 若当前满足分配条件 // 1、设置分配大小 // 2、满足令牌发放的时间 = 当前时间 + 等待时长 if ok { r.tokens = n r.timeToAct = now.Add(waitDuration) } // 更新 limiter 的值，并返回 if ok { lim.last = now lim.tokens = tokens lim.lastEvent = r.timeToAct } else { lim.last = last } lim.mu.Unlock() return r } ","date":"2020-08-24","objectID":"/go-standard-lib-time-rate-pkg/:2:2","tags":["go","standard lib","time rate"],"title":"Go 标准库 限流器 time/rate 设计与实现","uri":"/go-standard-lib-time-rate-pkg/"},{"categories":["golang"],"content":"具体使用 rate 包中提供了对限流器的使用，只需要指定 limit（放入桶中的频率）、burst（桶的大小）。 func NewLimiter(r Limit, b int) *Limiter { return \u0026Limiter{ limit: r, // 放入桶的频率 burst: b, // 桶的大小 } } 在这里，使用一个 http api 来简单的验证一下 time/rate 的强大： func main() { r := rate.Every(1 * time.Millisecond) limit := rate.NewLimiter(r, 10) http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) { if limit.Allow() { fmt.Printf(\"请求成功，当前时间：%s\\n\", time.Now().Format(\"2006-01-02 15:04:05\")) } else { fmt.Printf(\"请求成功，但是被限流了。。。\\n\") } }) _ = http.ListenAndServe(\":8081\", nil) } 在这里，我把桶设置成了每一毫秒投放一次令牌，桶容量大小为 10，起一个 http 的服务，模拟后台 API。 接下来做一个压力测试，看看效果如何： func GetApi() { api := \"http://localhost:8081/\" res, err := http.Get(api) if err != nil { panic(err) } defer res.Body.Close() if res.StatusCode == http.StatusOK { fmt.Printf(\"get api success\\n\") } } func Benchmark_Main(b *testing.B) { for i := 0; i \u003c b.N; i++ { GetApi() } } 效果如下： ...... 请求成功，当前时间：2020-08-24 14:26:52 请求成功，但是被限流了。。。 请求成功，但是被限流了。。。 请求成功，但是被限流了。。。 请求成功，但是被限流了。。。 请求成功，但是被限流了。。。 请求成功，当前时间：2020-08-24 14:26:52 请求成功，但是被限流了。。。 请求成功，但是被限流了。。。 请求成功，但是被限流了。。。 请求成功，但是被限流了。。。 ...... 在这里，可以看到，当使用 AllowN 方法中，只有当令牌 Token 生产出来，才可以消费令牌，继续请求，剩余的则是将其请求抛弃，当然在实际的业务处理中，可以用比较友好的方式反馈给前端。 在这里，先有的几次请求都会成功，是因为服务启动后，令牌桶会初始化，将令牌放入到桶中，但是随着突发流量的请求，令牌按照预定的速率生产令牌，就会出现明显的令牌供不应求的现象。 ","date":"2020-08-24","objectID":"/go-standard-lib-time-rate-pkg/:3:0","tags":["go","standard lib","time rate"],"title":"Go 标准库 限流器 time/rate 设计与实现","uri":"/go-standard-lib-time-rate-pkg/"},{"categories":["golang"],"content":"开源仓库 目前 time/rate 是一个独立的限流器开源解决方案，感兴趣的小伙伴可以给此项目一个 Star，谢谢。 https://github.com/golang/time ","date":"2020-08-24","objectID":"/go-standard-lib-time-rate-pkg/:4:0","tags":["go","standard lib","time rate"],"title":"Go 标准库 限流器 time/rate 设计与实现","uri":"/go-standard-lib-time-rate-pkg/"},{"categories":["golang"],"content":"References 限流器系列(2) – Token Bucket 令牌桶 Golang 限流器的使用和实现 Golang 标准库限流器 time/rate 使用介绍 https://github.com/golang/time/rate.go ","date":"2020-08-24","objectID":"/go-standard-lib-time-rate-pkg/:5:0","tags":["go","standard lib","time rate"],"title":"Go 标准库 限流器 time/rate 设计与实现","uri":"/go-standard-lib-time-rate-pkg/"},{"categories":["mbp"],"content":"经过近两个星期的检测，维修 ?，我的 MacBook 满血复活了，事情是这样的，两周前我的电脑突然之间就黑屏，有充电反馈，键盘，Bar 和触控板均失灵，拿到公司 IT 部门，给我的意见是去售后 ?，紧接着到了周末去了售后，给我的解决方案是更换硬件，告诉我说要更换主板，也就代表着硬盘数据没有了，允悲，我同时给他说明针对于我两次修复蝶形键盘的经历，售后人员决定给我申请键盘也更换，心中多少有些安慰，于是他给了我一个维修周期，届时来领取就可以了。 于是我就拿着维修单回去了，过了两天，接到了售后的电话，我本以为修好了，并没有，售后给我说做了检测，显示器也有问题，需要给我更换，这，，，不就是更换全部的部件么，直接给我换台多效率 ?，显然苹果并没有那么给我做，现在拿到手中的就是除了下底壳没有更换，其他全部更换的九成新新机，百感交集呀。 不过，最终是修好了，在公司入职的这么多天也学习了很多东西，近期在不断的整理，后续会总结分享的，感谢一个陌生网友的关怀，?，一个高更新的博客要跑路了，虽然技术很菜，分享的技术网上一大堆，但是经验是积累的，相信自己的努力? 最终会成为大牛的，加油，嘿嘿。 ","date":"2020-08-13","objectID":"/mbp-resurrection/:0:0","tags":["mbp"],"title":"我的MacBook Pro又满血复活啦","uri":"/mbp-resurrection/"},{"categories":["golang"],"content":"RPC 在分布式计算，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC 是一种服务器-客户端（ Client/Server ）模式，经典实现是一个通过 发送请求-接受回应 进行信息交互的系统。 wiki 维基百科 在这里引用一下维基百科对于 RPC 的解释， 可以针对与 HTTP 协议来比较分析，RPC 更适合于公司中大、中型项目分布式调用场景。 ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:1:0","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"调用流程 客户端调用客户端 stub（client stub）。这个调用是在本地，并将调用参数 push 到栈（stack）中; 客户端 stub（client stub）将这些参数包装，并通过系统调用发送到服务端机器。打包的过程叫 marshalling。（常见方式：XML、JSON、二进制编码）; 客户端本地操作系统发送信息至服务器。（可通过自定义TCP协议或HTTP传输）; 服务器系统将信息传送至服务端stub（server stub）; 服务端stub（server stub）解析信息。该过程叫 unmarshalling; 服务端stub（server stub）调用程序，并通过类似的方式返回给客户端。 ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:1:1","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"RPC 与 HTTP 区别 RPC 调用实现的方式是和 HTTP 有异曲同工之处的，但是对于 RPC 与 HTTP 在 请求 / 响应中还是存在着差别的： HTTP 与 RPC 协议在实现上是不同的，大家都了解到 HTTP 原理就是 客户端请求服务端，服务端去响应并返回结果，但是 RPC 协议设计的时候采用的方式就是服务端给客户端提供 TCP 长连接服务，Client 端去调用 Server 提供的接口，实现特定的功能； RPC 可以同时提供同步调用及异步调用，而 HTTP 提供的方式就是同步调用，客户端会等待并接受服务端的请求处理的结果； RPC 服务设计可以提高代码编写过程中的解耦操作，提高代码的可移植性，每一个 服务可以设计成提供特定功能的小服务，客户端去调取远程的服务，而不用去关心远程是怎么实现的。 ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:2:0","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"RPC 应用领域 大型网站的内部子系统设计； 为系统提供降级功能； 并发设计场景； 当然 RPC 也有缺点，每一个 RPC 服务都需要单独搭建，一旦服务出错或者更为严重的不提供支持，作为客户端的就会出现服务不可用，这对系统稳定性及可持续提供支持要求比较高，当然在设计过程中，这样也加大了对系统调试的难度，也就是说这种设计要求 RPC 服务的稳定性及正确性要求是比较大的。 ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:2:1","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"实现代码 ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:3:0","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"客户端实现 package main import ( \"demo/common\" \"fmt\" \"net/rpc\" ) func main() { var args = common.Args{A: 32, B: 14} var result = common.Result{} var client, err = rpc.DialHTTP(\"tcp\", \"127.0.0.1:9090\") if err != nil { fmt.Printf(\"connect rpc server failed, err:%v\", err) } err = client.Call(\"MathService.Divide\", args, \u0026result) if err != nil { fmt.Printf(\"call math service failed, err:%v\", err) } fmt.Printf(\"call RPC server success, result:%f\", result.Value) } ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:3:1","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"服务端实现 package main import ( \"demo/common\" \"fmt\" \"net/http\" \"net/rpc\" ) func main() { var ms = new(common.MathService) // 注册 RPC 服务 err := rpc.Register(ms) if err != nil { fmt.Printf(\"rpc server register faild, err:%s\", err) } // 将 RPC 服务绑定到 HTTP 服务中去 rpc.HandleHTTP() fmt.Printf(\"server start ....\") err = http.ListenAndServe(\":9090\", nil) if err != nil { fmt.Printf(\"listen and server is failed, err:%v\\n\", err) } fmt.Printf(\"server stop ....\") } ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:3:2","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"功能实现 package common import \"errors\" type Args struct { A, B float32 } type Result struct { Value float32 } type MathService struct {} func (s *MathService) Add (args *Args, result *Result) error{ result.Value = args.A + args.B return nil } func (s *MathService) Divide(args *Args, result *Result) error{ if args.B == 0 { return errors.New(\"arge.B is 0\") } result.Value = args.A / args.B return nil } ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:3:3","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"References 简述RPC原理实现 - 博客园 Http和RPC区别 远程过程调用 - 维基百科 直观讲解–RPC调用和HTTP调用的区别 ","date":"2020-08-01","objectID":"/go-rpc-invoke-demo/:4:0","tags":["go","rpc","invoke"],"title":"Go 语言实现 RPC 调用","uri":"/go-rpc-invoke-demo/"},{"categories":["golang"],"content":"在 Go 项目开发中，团队要保持开发版本一致，怎么能够快速的安装及部署并且切换 Go 环境，在这里推荐一款工具 GVM （ Go Version Manager ），它可以便捷切换与自定义 Go Path 、Go Root 等参数，是一款实打实的多版本安装及管理利器。 GVM，类似于ruby 中的 RVM，java 中的 jenv（国产），可用于方便管理 Go 的版本，它有如下几个主要特性： 管理 Go 的多个版本，包括安装、卸载和指定使用 Go 的某个版本； 查看官方所有可用的 Go 版本，同时可以查看本地已安装和默认使用的 Go 版本； 管理多个 GOPATH，并可编辑 Go 的环境变量； 可将当前目录关联到 GOPATH； 可以查看 GOROOT 下的文件差异。 ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:0:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"安装 Installing bash \u003c \u003c(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 或者，如果您使用的是 zsh，只需使用 zsh 更改 bash。 ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:1:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"使用 GVM 使用 gvm 可以查看支持的操作： ➜ ~ gvm Usage: gvm [command] Description: GVM is the Go Version Manager Commands: version - print the gvm version number get - gets the latest code (for debugging) use - select a go version to use (--default to set permanently) diff - view changes to Go root help - display this usage text implode - completely remove gvm install - install go versions uninstall - uninstall go versions cross - install go cross compilers linkthis - link this directory into GOPATH list - list installed go versions listall - list available versions alias - manage go version aliases pkgset - manage go packages sets pkgenv - edit the environment for a package set ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:2:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"安装 Go 版本 例如安装 go1.13 版本： gvm install go1.13 ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:3:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"查看 Go 版本 ➜ ~ gvm list gvm gos (installed) go1.12 =\u003e system ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:4:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"切换 Go 版本 gvm use go1.** ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:5:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"管理 Gopath 环境 GVM 提供了一个比较简单的工具 gvm pkgset 可以创建使用 GOPATH 环境： ➜ ~ gvm pkgset = gvm pkgset * http://github.com/moovweb/gvm == DESCRIPTION: GVM pkgset is used to manage various Go packages == Usage gvm pkgset Command == Command create - create a new package set delete - delete a package set use - select where gb and goinstall target and link empty - remove all code and compiled binaries from package set list - list installed go packages ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:6:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"卸载 Uninstall 卸载某个安装好的 Go 版本： gvm uninstall go1.13 ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:7:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"开源代码 GVM 是一款使用 Shell 脚本实现的便捷工具，作为开源项目，推荐大家给一个 Star 支持。 https://github.com/moovweb/gvm ","date":"2020-07-12","objectID":"/go-use-gvm-switch-version/:8:0","tags":["go","gvm"],"title":"使用 GVM 工具管理 Go 版本","uri":"/go-use-gvm-switch-version/"},{"categories":["golang"],"content":"SQLX 库 sqlx是 Go 的软件包，它在出色的内置database/sql软件包的基础上提供了一组扩展。 该库兼容 sql 原生包，同时又提供了更为强大的、优雅的查询、插入函数。 该库提供四个处理类型，分别是： sqlx.DB - 类似原生的sql.DB； sqlx.Tx - 类似原生的sql.Tx； sqlx.Stmt - 类似原生的 sql.Stmt, 准备 SQL 语句操作； sqlx.NamedStmt - 对特定参数命名并绑定生成 SQL 语句操作。 提供两个游标类型，分别是： sqlx.Rows - 类似原生的 sql.Rows, 从 Queryx 返回； sqlx.Row - 类似原生的 sql.Row, 从 QueryRowx 返回。 ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:1:0","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"安装 SQLX 库 go get github.com/jmoiron/sqlx ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:2:0","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"使用操作 ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:3:0","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"连接数据库 // 初始化数据库 func initMySQL() (err error) { dsn := \"root:password@tcp(127.0.0.1:3306)/database\" db, err = sqlx.Open(\"mysql\", dsn) if err != nil { fmt.Printf(\"connect server failed, err:%v\\n\", err) return } db.SetMaxOpenConns(200) db.SetMaxIdleConns(10) return } SetMaxOpenConns 和 SetMaxIdleConns 分别为设置最大连接数和最大空闲数。 ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:3:1","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"数据表达及引用 在这里提前声明一个用户结构体 user，将 *sqlx.DB 作为一个全局变量使用，当然也要提前引用 MySQL 的驱动包，如下设计： import ( \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"github.com/jmoiron/sqlx\" ) var db *sqlx.DB type user struct { Id int `db:\"id\"` Age int `db:\"age\"` Name string `db:\"name\"` } ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:4:0","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"查询操作 ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:5:0","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"查询一行数据 查询一行数据使用 sqlx 库中的 Get 函数实现： func (db *DB) Get(dest interface{}, query string, args ...interface{}) error dest 是用户声明变量接收查询结果，query 为查询 SQL 语句，args 为绑定参数的赋值。 // 查询一行数据 func queryRow() { sqlStr := \"SELECT id, name, age FROM user WHERE id = ?\" var u user if err := db.Get(\u0026u, sqlStr, 1); err != nil { fmt.Printf(\"get data failed, err:%v\\n\", err) return } fmt.Printf(\"id:%d, name:%s, age:%d\\n\", u.Id, u.Name, u.Age) } ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:5:1","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"查询多行数据 而查询多行数据则使用的是Select 函数： func (db *DB) Select(dest interface{}, query string, args ...interface{}) error 使用 Select 函数进行查询的时候，需要先声明一个结构体数组接收映射过来的数据： // 查询多行数据 func queryMultiRow() { sqlStr := \"SELECT id, name, age FROM user WHERE id \u003e ?\" var users []user if err := db.Select(\u0026users, sqlStr, 0); err != nil { fmt.Printf(\"get data failed, err:%v\\n\", err) return } for i := 0; i \u003c len(users); i++ { fmt.Printf(\"id:%d, name:%s, age:%d\\n\", users[i].Id, users[i].Name, users[i].Age) } } ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:5:2","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"插入、更新、删除操作 在 sqlx 库中，使用插入、更新、删除操作是和原生 sql 库实现是一致的，都是采用 Exec 函数来实现的： 插入操作 // 插入数据 func insertRow() { sqlStr := \"INSERT INTO user(name, age) VALUES(?, ?)\" result, err := db.Exec(sqlStr, \"Meng小羽\", 22) if err != nil { fmt.Printf(\"exec failed, err:%v\\n\", err) return } insertID, err := result.LastInsertId() if err != nil { fmt.Printf(\"get insert id failed, err:%v\\n\", err) return } fmt.Printf(\"insert data success, id:%d\\n\", insertID) } 更新操作 // 更新数据 func updateRow() { sqlStr := \"UPDATE user SET age = ? WHERE id = ?\" result, err := db.Exec(sqlStr, 22, 6) if err != nil { fmt.Printf(\"exec failed, err:%v\\n\", err) return } affectedRows, err := result.RowsAffected() if err != nil { fmt.Printf(\"get affected failed, err:%v\\n\", err) return } fmt.Printf(\"update data success, affected rows:%d\\n\", affectedRows) } 删除操作 // 删除一行 func deleteRow() { sqlStr := \"DELETE FROM user WHERE id = ?\" result, err := db.Exec(sqlStr, 4) if err != nil { fmt.Printf(\"exec failed, err:%v\\n\", err) return } affectedRows, err := result.RowsAffected() if err != nil { fmt.Printf(\"get affected failed, err:%v\\n\", err) return } fmt.Printf(\"delete data success, affected rows:%d\\n\", affectedRows) } 参数绑定 在库中提供最常用的就是NamedQuery和NamedExec函数，一个是执行对查询参数命名并绑定，另一个则是对 CUD 操作的查询参数名的绑定： NamedQuery // 绑定查询 func selectNamedQuery() { sqlStr := \"SELECT id, name, age FROM user WHERE age = :age\" rows, err := db.NamedQuery(sqlStr, map[string]interface{}{ \"age\": 22, }) if err != nil { fmt.Printf(\"named query failed failed, err:%v\\n\", err) return } defer rows.Close() for rows.Next() { var u user if err := rows.StructScan(\u0026u); err != nil { fmt.Printf(\"struct sacn failed, err:%v\\n\", err) continue } fmt.Printf(\"%#v\\n\", u) } } NamedExec // 使用 named 方法插入数据 func insertNamedExec() { sqlStr := \"INSERT INTO user(name, age) VALUES(:name, :age)\" result, err := db.NamedExec(sqlStr, map[string]interface{}{ \"name\": \"里斯\", \"age\": 18, }) if err != nil { fmt.Printf(\"named exec failed, err:%v\\n\", err) return } insertId, err := result.LastInsertId() if err != nil { fmt.Printf(\"get last insert id failed, err:%v\\n\", err) return } fmt.Printf(\"insert data success, id:%d\\n\", insertId) } 事务操作 使用Begin函数、Rollback函数及Commit函数实现事务操作： // 开启事务 func (db *DB) Begin() (*Tx, error) // 回滚事务 func (tx *Tx) Rollback() error // 提交事务 func (tx *Tx) Commit() error 示例代码： // 事务操作 func updateTransaction() (err error) { tx, err := db.Begin() if err != nil { fmt.Printf(\"transaction begin failed, err:%v\\n\", err) return err } defer func() { if p := recover(); p != nil { _ = tx.Rollback() panic(p) } else if err != nil { fmt.Printf(\"transaction rollback\") _ = tx.Rollback() } else { err = tx.Commit() fmt.Printf(\"transaction commit\") return } }() sqlStr1 := \"UPDATE user SET age = ? WHERE id = ? \" reuslt1, err := tx.Exec(sqlStr1, 18, 1) if err != nil { fmt.Printf(\"sql exec failed, err:%v\\n\", err) return err } rows1, err := reuslt1.RowsAffected() if err != nil { fmt.Printf(\"affected rows is 0\") return } sqlStr2 := \"UPDATE user SET age = ? WHERE id = ? \" reuslt2, err := tx.Exec(sqlStr2, 19, 5) if err != nil { fmt.Printf(\"sql exec failed, err:%v\\n\", err) return err } rows2, err := reuslt2.RowsAffected() if err != nil { fmt.Printf(\"affected rows is 0\\n\") return } if rows1 \u003e 0 \u0026\u0026 rows2 \u003e 0 { fmt.Printf(\"update data success\\n\") } return } ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:5:3","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"开源项目 最后将此开源项目放在此处，大家要是感兴趣可以给这个开源项目一个 Star，感谢。 https://github.com/jmoiron/sqlx ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:6:0","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"References http://jmoiron.github.io/sqlx/ sqlx库使用指南 - 李文周的博客 ","date":"2020-07-07","objectID":"/go-mysql-sqlx-pkg/:7:0","tags":["go","mysql"],"title":"Go 语言操作 MySQL 之 SQLX 包","uri":"/go-mysql-sqlx-pkg/"},{"categories":["golang"],"content":"预处理 预处理是 MySQL 为了防止客户端频繁请求的一种技术，是对相同处理语句进行预先加载在 MySQL 中，将操作变量数据用占位符来代替，减少对 MySQL 的频繁请求，使得服务器高效运行。 在这里客户端并不是前台后台之间的 C/S 架构，而是后台程序对数据库服务器进行操作的 C/S 架构，这样就可以简要地理解了后台程序作为 Client 向 MySQL Server 请求并处理结果了。 普通 SQL 执行处理过程： 在客户端准备 SQL 语句； 发送 SQL 语句到 MySQL 服务器； 在 MySQL 服务器执行该 SQL 语句； 服务器将执行结果返回给客户端。 预处理执行处理过程： 将 SQL 拆分为结构部分与数据部分； 在执行 SQL 语句的时候，首先将前面相同的命令和结构部分发送给 MySQL 服务器，让 MySQL 服务器事先进行一次预处理（此时并没有真正的执行 SQL 语句）； 为了保证 SQL 语句的结构完整性，在第一次发送 SQL 语句的时候将其中可变的数据部分都用一个数据占位符来表示； 然后把数据部分发送给 MySQL 服务端，MySQL 服务端对 SQL 语句进行占位符替换； MySQL 服务端执行完整的 SQL 语句并将结果返回给客户端。 ","date":"2020-07-02","objectID":"/go-mysql-prepare/:1:0","tags":["go","mysql","prepare"],"title":"Go 语言操作 MySQL 之 预处理","uri":"/go-mysql-prepare/"},{"categories":["golang"],"content":"预处理优点 预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）； 绑定参数减少了服务器带宽，只需发送查询的参数，而不是整个语句； 预处理语句针对 SQL 注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。 ","date":"2020-07-02","objectID":"/go-mysql-prepare/:2:0","tags":["go","mysql","prepare"],"title":"Go 语言操作 MySQL 之 预处理","uri":"/go-mysql-prepare/"},{"categories":["golang"],"content":"Go 语言实现 在 Go 语言中，使用 db.Prepare() 方法实现预处理： func (db *DB) Prepare(query string) (*Stmt, error) Prepare 执行预处理 SQL 语句，并返回 Stmt 结构体指针，进行数据绑定操作。 查询操作使用 db.Prepare() 方法声明预处理 SQL，使用 stmt.Query() 将数据替换占位符进行查询，更新、插入、删除操作使用 stmt.Exec() 来操作。 ","date":"2020-07-02","objectID":"/go-mysql-prepare/:3:0","tags":["go","mysql","prepare"],"title":"Go 语言操作 MySQL 之 预处理","uri":"/go-mysql-prepare/"},{"categories":["golang"],"content":"预处理查询示例 // 预处理查询数据 func prepareQuery() { sqlStr := \"SELECT id,name,age FROM user WHERE id \u003e ?\" stmt, err := db.Prepare(sqlStr) if err != nil { fmt.Printf(\"prepare sql failed, err:%v\\n\", err) return } rows, err := stmt.Query(1) if err != nil { fmt.Printf(\"exec failed, err:%v\\n\", err) return } defer rows.Close() for rows.Next() { var u user err := rows.Scan(\u0026u.id, \u0026u.name, \u0026u.age) if err != nil { fmt.Printf(\"scan data failed, err:%v\\n\", err) return } fmt.Printf(\"id:%d, name:%s, age:%d\\n\", u.id, u.name, u.age) } } ","date":"2020-07-02","objectID":"/go-mysql-prepare/:3:1","tags":["go","mysql","prepare"],"title":"Go 语言操作 MySQL 之 预处理","uri":"/go-mysql-prepare/"},{"categories":["golang"],"content":"预处理更新示例 // 预处理更新数据 func prepareUpdate() { sqlStr := \"UPDATE user SET age = ? WHERE id = ?\" stmt, err := db.Prepare(sqlStr) if err != nil { fmt.Printf(\"prepare sql failed, err:%v\\n\", err) return } _, err = stmt.Exec(18, 2) if err != nil { fmt.Printf(\"exec failed, err:%v\\n\", err) return } fmt.Printf(\"prepare update data success\") } ","date":"2020-07-02","objectID":"/go-mysql-prepare/:3:2","tags":["go","mysql","prepare"],"title":"Go 语言操作 MySQL 之 预处理","uri":"/go-mysql-prepare/"},{"categories":["golang"],"content":"预处理插入示例 // 预处理更新数据 func prepareUpdate() { sqlStr := \"UPDATE user SET age = ? WHERE id = ?\" stmt, err := db.Prepare(sqlStr) if err != nil { fmt.Printf(\"prepare sql failed, err:%v\\n\", err) return } _, err = stmt.Exec(18, 2) if err != nil { fmt.Printf(\"exec failed, err:%v\\n\", err) return } fmt.Printf(\"prepare update data success\") } ","date":"2020-07-02","objectID":"/go-mysql-prepare/:3:3","tags":["go","mysql","prepare"],"title":"Go 语言操作 MySQL 之 预处理","uri":"/go-mysql-prepare/"},{"categories":["golang"],"content":"预处理删除示例 // 预处理删除数据 func prepareDelete() { sqlStr := \"DELETE FROM user WHERE id = ?\" stmt, err := db.Prepare(sqlStr) if err != nil { fmt.Printf(\"prepare sql failed, err:%v\\n\", err) return } result, err := stmt.Exec(3) n, err := result.RowsAffected() if err != nil { fmt.Printf(\"delete rows failed, err:%v\\n\", err) return } if n \u003e 0 { fmt.Printf(\"delete data success\") } else { fmt.Printf(\"delete data error\") } } ","date":"2020-07-02","objectID":"/go-mysql-prepare/:3:4","tags":["go","mysql","prepare"],"title":"Go 语言操作 MySQL 之 预处理","uri":"/go-mysql-prepare/"},{"categories":["golang"],"content":"事务 数据库事务( transaction )是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 MySQL 存储引擎分类有 MyISAM、InnoDB、Memory、Merge等，但是其中最为常用的就是 MyISAM 和 InnoDB 两个引擎，这两个引擎中，支持事务的引擎就是 Innodb（MySQL 默认引擎），在创建数据库中要注意对应引擎。 这里可以看一下针对 MySQL 选择引擎的文章： https://www.debuginn.cn/5753.html ","date":"2020-07-02","objectID":"/go-mysql-transaction-operation/:1:0","tags":["go","mysql","transaction"],"title":"Go 语言操作 MySQL 之 事务操作","uri":"/go-mysql-transaction-operation/"},{"categories":["golang"],"content":"事务 ACID 通常事务必须满足4个条件（ ACID ）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 条件 解释 原子性 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 ","date":"2020-07-02","objectID":"/go-mysql-transaction-operation/:2:0","tags":["go","mysql","transaction"],"title":"Go 语言操作 MySQL 之 事务操作","uri":"/go-mysql-transaction-operation/"},{"categories":["golang"],"content":"Go 操作 MySQL 使用事务 Go语言中使用以下三个方法实现MySQL中的事务操作： // 开始事务 func (db *DB) Begin() (*Tx, error) // 回滚事务 func (tx *Tx) Rollback() error // 提交事务 func (tx *Tx) Commit() error 示例代码： // 事务更新操作 func transActionUpdate() { tx, err := db.Begin() if err != nil { if tx != nil { _ = tx.Rollback() } fmt.Printf(\"begin trans action failed, err:%v\\n\", err) return } sqlStr1 := \"UPDATE user SET age = ? WHERE id = ?\" result1, err := tx.Exec(sqlStr1, 20, 1) if err != nil { _ = tx.Rollback() fmt.Printf(\"exec failed, err:%v\\n\", err) return } n1, err := result1.RowsAffected() if err != nil { _ = tx.Rollback() fmt.Printf(\"exec result1.RowsAffected() failed, err:%v\\n\", err) return } sqlStr2 := \"UPDATE user SET age = ? WHERE id = ?\" result2, err := tx.Exec(sqlStr2, 20, 6) if err != nil { _ = tx.Rollback() fmt.Printf(\"exec failed, err:%v\\n\", err) return } n2, err := result2.RowsAffected() if err != nil { _ = tx.Rollback() fmt.Printf(\"exec result1.RowsAffected() failed, err:%v\\n\", err) return } if n1 == 1 \u0026\u0026 n2 == 1 { _ = tx.Commit() fmt.Printf(\"transaction commit success\\n\") } else { _ = tx.Rollback() fmt.Printf(\"transaction commit error, rollback\\n\") return } } ","date":"2020-07-02","objectID":"/go-mysql-transaction-operation/:3:0","tags":["go","mysql","transaction"],"title":"Go 语言操作 MySQL 之 事务操作","uri":"/go-mysql-transaction-operation/"},{"categories":["golang"],"content":"MySQL 是目前开发中最常见的关系型数据库，使用 Go 语言进行操控数据库需要使用 Go 自带database/sql和驱动go-sql-driver/mysql来实现， 创建好 Go 项目，需要引用驱动依赖： go get -u github.com/go-sql-driver/mysql 使用 MySQL 驱动： func Open(driverName, dataSourceName string) (*DB, error) Open 打开一个 dirverName 指定的数据库，dataSourceName 指定数据源，一般至少包括数据库文件名和其它连接必要的信息。 ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:0:0","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"初始化连接 var db *sql.DB //声明一个全局的 db 变量 // 初始化 MySQL 函数 func initMySQL() (err error) { dsn := \"root:password@tcp(127.0.0.1:3306)/dbname\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return } err = db.Ping() if err != nil { return } return } func main() { // 初始化 MySQL err := initMySQL() if err != nil { panic(err) } defer db.Close() } 初始化连接 MySQL 后需要借助 db.Ping 函数来判断连接是否成功。 ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:1:0","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"SetMaxOpenConns func (db *DB) SetMaxOpenConns(n int) SetMaxOpenConns设置与数据库建立连接的最大数目。 如果 n 大于 0 且小于最大闲置连接数，会将最大闲置连接数减小到匹配最大开启连接数的限制。 如果 n \u003c= 0，不会限制最大开启连接数，默认为0（无限制）。 ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:1:1","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"SetMaxIdleConns func (db *DB) SetMaxIdleConns(n int) SetMaxIdleConns设置连接池中的最大闲置连接数。 如果 n 大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。 如果 n \u003c= 0，不会保留闲置连接。 ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:1:2","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"CURD 进行 CURD 操作，需要对数据库建立连接，同时有供操作的数据（数据库与数据表）： ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:2:0","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"初始化数据 ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:2:1","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"建立数据库 sql_demo CREATE DATABASE sql_demo; USE sql_demo; 创建数据表 user CREATE TABLE `user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT '', `age` INT(11) DEFAULT '0', PRIMARY KEY(`id`) )ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:2:2","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"查询数据 SELECT 便于接收数据，定义一个 user 结构体接收数据： type user struct { id int age int name string } 查询一行数据 db.QueryRow() 执行一次查询，并期望返回最多一行结果（即 Row ）。QueryRow 总是返回非 nil 的值，直到返回值的 Scan 方法被调用时，才会返回被延迟的错误。（如：未找到结果） func (db *DB) QueryRow(query string, args ...interface{}) *Row 实例代码如下： // 查询一行数据 func queryRowDemo() (u1 *user, err error) { // 声明查询语句 sqlStr := \"SELECT id,name,age FROM user WHERE id = ?\" // 声明一个 user 类型的变量 var u user // 执行查询并且扫描至 u err = db.QueryRow(sqlStr, 1).Scan(\u0026u.id, \u0026u.age, \u0026u.name) if err != nil { return nil, err } u1 = \u0026u return } func main() { // 初始化 MySQL err := initMySQL() if err != nil { panic(err) } defer db.Close() u1, err := queryRowDemo() if err != nil { fmt.Printf(\"err:%s\", err) } fmt.Printf(\"id:%d, age:%d, name:%s\\n\", u1.id, u1.age, u1.name) } 结果如下： id:1, age:111, name:22 多行查询 db.Query()执行一次查询，返回多行结果（即 Rows ），一般用于执行 select 命令。参数 args 表示 query 中的占位参数。 func (db *DB) Query(query string, args ...interface{}) (*Rows, error) 实例代码如下： // 查询多行数据 func queryMultiRowDemo() { sqlStr := \"SELECT id,name,age FROM user WHERE id \u003e ?\" rows, err := db.Query(sqlStr, 0) if err != nil { fmt.Printf(\"query data failed，err:%s\\n\", err) return } // 查询完数据后需要进行关闭数据库链接 defer rows.Close() for rows.Next() { var u user err := rows.Scan(\u0026u.id, \u0026u.age, \u0026u.name) if err != nil { fmt.Printf(\"scan data failed, err:%v\\n\", err) return } fmt.Printf(\"id:%d name:%s age:%d\\n\", u.id, u.name, u.age) } } 执行结果： id:1 name:111 age:22 id:3 name:张三 age:22 使用 rows.Next() 循环读取结果集中的数据。 ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:2:3","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"增加数据 INSERT 增加、删除、更新操作均使用 Exec 方法。 func (db *DB) Exec(query string, args ...interface{}) (Result, error) 实例代码如下： // 增加一行数据 func insertRowDemo() { sqlStr := \"INSERT INTO user(name, age) VALUES(?, ?)\" result, err := db.Exec(sqlStr, \"小羽\", 22) if err != nil { fmt.Printf(\"insert data failed, err:%v\\n\", err) return } id, err := result.LastInsertId() if err != nil { fmt.Printf(\"get insert lastInsertId failed, err:%v\\n\", err) return } fmt.Printf(\"insert success, id:%d\\n\", id) } 执行结果： insert success, id:4 ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:2:4","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"更新数据 UPDATE // 更新一组数据 func updateRowDemo() { sqlStr := \"UPDATE user SET age = ? WHERE id = ?\" result, err := db.Exec(sqlStr, 22, 1) if err != nil { fmt.Printf(\"update data failed, err:%v\\n\", err) return } n, err := result.RowsAffected() if err != nil { fmt.Printf(\"get rowsaffected failed, err:%v\\n\", err) return } fmt.Printf(\"update success, affected rows:%d\\n\", n) } ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:2:5","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"删除数据 DELETE // 删除一行数据 func deleteRowDemo() { sqlStr := \"DELETE FROM user WHERE id = ?\" result, err := db.Exec(sqlStr, 2) if err != nil { fmt.Printf(\"delete data failed, err:%d\\n\", err) return } n, err := result.RowsAffected() if err != nil { fmt.Printf(\"get affected failed, err:%v\\n\", err) return } fmt.Printf(\"delete success, affected rows:%d\\n\", n) } ","date":"2020-07-01","objectID":"/go-mysql-curd-operation/:2:6","tags":["go","mysql","curd"],"title":"Go 语言操作 MySQL 之 CURD 操作","uri":"/go-mysql-curd-operation/"},{"categories":["golang"],"content":"在 Go 语言中，为便于存储及管理用户数据，其数据结构设计分为数组 Array、切片 Slice、映射 Map 三种结构。 近期又看了 Go 语言基础的内容，看了一下这三种结构实现的原理： ","date":"2020-06-17","objectID":"/go-array-slice-map/:0:0","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"数组 Array 数组是切片和映射的基础数据结构； 数组是长度固定的数据类型并且在内存中也是连续分配的，固索引数组数据速度是非常快的； 声明数组时需要指定数组存储的类型及数量（数组的长度）； 数组变量的类型包括数组长度和元素的类型，只有两部分都相同的数组才可相互赋值。 ","date":"2020-06-17","objectID":"/go-array-slice-map/:1:0","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"创建及初始化 一旦声明了数组，其本身的数据类型及长度都是不可以进行变更。 // 使用数组字面量声明数组 array := [5]int{1, 2, 3, 4, 5} // 自动推导长度声明数组 array := [...]int{1, 2, 3, 4, 5, 6} // 使用 ... 代替长度，根据初始化元素个数推导 // 声明数组并指定特定元素值 array := [5]int{1:10, 2:20} ","date":"2020-06-17","objectID":"/go-array-slice-map/:1:1","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"指针类型 数组元素的类型可以为任何内置类型，也可以是某种结构类型，也可以是指针类型。 // 声明一个元素长度为 3 的指向字符串的指针数组 var array1 [3]*string // 为指针数组指定元素 *array1[0] = \"demo0\" *array1[1] = \"demo1\" *array1[2] = \"demo2\" ","date":"2020-06-17","objectID":"/go-array-slice-map/:1:2","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"多维数组 数组本身是一维数据，多维数组是由多个数组组合而来的。 // 声明一个二维数组 var array = [3][2]int // 声明了一个两个维度为 3 和 2 的元素 // 初始化二维数组 var array = [3][2]int{ {1, 2}, {3, 4}, {5, 6}} 在函数间传递数组：由于在函数间传递变量时，传递的总是变量的值的副本，所以在传递数组变量时将拷贝整个数组！在定义函数时，对于较大的数据类型应该把参数设计为指针类型，这样在调用函数时，只需在栈上分配给每个指针8字节的内存，但这意味着会改变指针指向的值(共享的内存)，其实大部分情况下应该使用切片类型，而不是数组。 ","date":"2020-06-17","objectID":"/go-array-slice-map/:1:3","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"切片 Slice 切片 slice 是引用类型，它引用了其指针字段所指向的底层数组的一部分或全部； 切片是围绕动态数组的概念构建的； 切片的动态增长是通过 append 来实现的； 缩小则是通过对它再次切片来实现，通过再次切片获得的新切片将和原切片共享底层数组，它们的指针指向同一个底层数组。 ","date":"2020-06-17","objectID":"/go-array-slice-map/:2:0","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"创建及初始化 切片类型有3个字段： 指针：指向切片所包含的第一个元素在底层数组中的地址； 长度：切片所包含的底层数组的元素的个数（切片可访问的元素的个数）； 容量：切片允许增长到的最大元素个数，即底层数组的长度。 make 和切片字面量 // 使用 make 创建一个切片 slice := make([]int, 3) // 创建一个具有长度和容量的切片 slice := make([]int, 1, 6) // 长度为 1，容量为 6 个元素 nil 和空切片 // nil 字符串切片 var slice []string // 空切片 slice := []int{} // 空的整形切片 由于切片只是引用了底层数组，底层数组的数据并不属于切片本身，所以一个切片只需要 24字节的内存(在 64位机器上)：指针字段 8字节、长度字段 8字节、容量字段 8字节。所以在函数之间直接传递切片是高效的，只需分配 24字节的栈内存。 len函数可返还切片的长度、cap函数可返还切片的容量。 ","date":"2020-06-17","objectID":"/go-array-slice-map/:2:1","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"映射 Map 映射 map 是用来存储一系列的无序键值对； 映射是无序的集合，其实现使用了散列表； 映射的散列表包含一组桶，每个桶里存储着一部分键值对； 映射内部使用了两个数组： 第一个数组：存储着用于选择桶的散列键的高八位值，该数组用于区分每个键值对要存在哪个桶里； 第二个数组：每个桶里都有一个字节数组，先依次存储了该桶里的所有键，之后存储了该桶的所有值； ","date":"2020-06-17","objectID":"/go-array-slice-map/:3:0","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"创建及初始化 // 创建一个映射 存储学生信息 students := map[string]string{ \"name\" : \"mengxiaoyu\", \"age\" : \"22\", \"sex\" : \"boy\", \"hobby\": \"pingpang\", } // 显示映射所有信息 for key, value := range students{ fmt.printf(\"key:%s, \\t value:%s\\n\", key, value); } 遍历映射的键值对时的顺序是随机，若要有序的获得映射的键值对，则需要先遍历出映射的键存到一个切片中，然后排序该切片，最后遍历该切片，按切片中元素的顺序去映射中取对应的值。 ","date":"2020-06-17","objectID":"/go-array-slice-map/:3:1","tags":["go","array","slice","map"],"title":"Go 语言基础 数组、切片、映射","uri":"/go-array-slice-map/"},{"categories":["golang"],"content":"TCP/IP TCP/IP 传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP 传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP 传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP/IP 传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。 ","date":"2020-05-25","objectID":"/go-net-socket/:1:0","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"TCP/IP 协议簇常见通信协议 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等 传输层：TCP，UDP 网络层：IP，ICMP，OSPF，EIGRP，IGMP 数据链路层：SLIP，CSLIP，PPP，MTU ","date":"2020-05-25","objectID":"/go-net-socket/:1:1","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"Socket 两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用 PID 来唯一标示一个进程，但 PID 只在本地唯一，网络中的两个进程 PID 冲突几率很大，这时候我们需要另辟它径了，我们知道 IP 层的 ip 地址可以唯一标示主机，而 TCP 层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用 ip 地址＋协议＋端口号唯一标示网络中的一个进程。 能够唯一标示网络中的进程后，它们就可以利用 socket 进行通信了，什么是socket 呢？我们经常把 socket 翻译为套接字，socket 是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 socket是一种\"打开—读/写—关闭\"模式的实现，服务器和客户端各自维护一个\"文件\"，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。 Socket 是实现“打开–读/写–关闭”这样的模式，以使用 TCP 协议通讯的 socket 为例。如下图所示： ","date":"2020-05-25","objectID":"/go-net-socket/:2:0","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"TCP 实现 一个 TCP 客户端进行 TCP 通信的流程如下： 建立与服务端的链接 进行数据收发 关闭链接 ","date":"2020-05-25","objectID":"/go-net-socket/:3:0","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"server 端 package main import ( \"bufio\" \"fmt\" \"net\" ) func process(conn net.Conn) { // 处理完关闭连接 defer conn.Close() // 针对当前连接做发送和接受操作 for { reader := bufio.NewReader(conn) var buf [128]byte n, err := reader.Read(buf[:]) if err != nil { fmt.Printf(\"read from conn failed, err:%v\\n\", err) break } recv := string(buf[:n]) fmt.Printf(\"收到的数据：%v\\n\", recv) // 将接受到的数据返回给客户端 _, err = conn.Write([]byte(\"ok\")) if err != nil { fmt.Printf(\"write from conn failed, err:%v\\n\", err) break } } } func main() { // 建立 tcp 服务 listen, err := net.Listen(\"tcp\", \"127.0.0.1:9090\") if err != nil { fmt.Printf(\"listen failed, err:%v\\n\", err) return } for { // 等待客户端建立连接 conn, err := listen.Accept() if err != nil { fmt.Printf(\"accept failed, err:%v\\n\", err) continue } // 启动一个单独的 goroutine 去处理连接 go process(conn) } } ","date":"2020-05-25","objectID":"/go-net-socket/:3:1","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"client 端 package main import ( \"bufio\" \"fmt\" \"net\" \"os\" \"strings\" ) func main() { // 1、与服务端建立连接 conn, err := net.Dial(\"tcp\", \"127.0.0.1:9090\") if err != nil { fmt.Printf(\"conn server failed, err:%v\\n\", err) return } // 2、使用 conn 连接进行数据的发送和接收 input := bufio.NewReader(os.Stdin) for { s, _ := input.ReadString('\\n') s = strings.TrimSpace(s) if strings.ToUpper(s) == \"Q\" { return } _, err = conn.Write([]byte(s)) if err != nil { fmt.Printf(\"send failed, err:%v\\n\", err) return } // 从服务端接收回复消息 var buf [1024]byte n, err := conn.Read(buf[:]) if err != nil { fmt.Printf(\"read failed:%v\\n\", err) return } fmt.Printf(\"收到服务端回复:%v\\n\", string(buf[:n])) } } ","date":"2020-05-25","objectID":"/go-net-socket/:3:2","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"UDP 实现 UDP 协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。 ","date":"2020-05-25","objectID":"/go-net-socket/:4:0","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"server 端 package main import ( \"fmt\" \"net\" ) func main() { // 建立 udp 服务器 listen, err := net.ListenUDP(\"udp\", \u0026net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 9090, }) if err != nil { fmt.Printf(\"listen failed error:%v\\n\", err) return } defer listen.Close() // 使用完关闭服务 for { // 接收数据 var data [1024]byte n, addr, err := listen.ReadFromUDP(data[:]) if err != nil { fmt.Printf(\"read data error:%v\\n\", err) return } fmt.Printf(\"addr:%v\\t count:%v\\t data:%v\\n\", addr, n, string(data[:n])) // 发送数据 _, err = listen.WriteToUDP(data[:n], addr) if err != nil { fmt.Printf(\"send data error:%v\\n\", err) return } } } ","date":"2020-05-25","objectID":"/go-net-socket/:4:1","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"client 端 package main import ( \"fmt\" \"net\" ) func main() { // 建立服务 listen, err := net.DialUDP(\"udp\", nil, \u0026net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 9090, }) if err != nil { fmt.Printf(\"listen udp server error:%v\\n\", err) } defer listen.Close() // 发送数据 sendData := []byte(\"Hello server\") _, err = listen.Write(sendData) // 发送数据 if err != nil { fmt.Println(\"发送数据失败，err:\", err) return } // 接收数据 data := make([]byte, 4096) n, remoteAddr, err := listen.ReadFromUDP(data) // 接收数据 if err != nil { fmt.Println(\"接收数据失败，err:\", err) return } fmt.Printf(\"recv:%v addr:%v count:%v\\n\", string(data[:n]), remoteAddr, n) } ","date":"2020-05-25","objectID":"/go-net-socket/:4:2","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["golang"],"content":"参考文章 Go语言基础之网络编程 - 李文周的个人博客 简单理解Socket - 谦行 - 博客园 TCP/IP协议 - 百度百科 详解TCP连接的“三次握手”与“四次挥手”(下) ","date":"2020-05-25","objectID":"/go-net-socket/:5:0","tags":["go","net","socket"],"title":"Go 语言使用 net 包实现 Socket 网络编程","uri":"/go-net-socket/"},{"categories":["linux"],"content":"经常使用 Linux 的同学在编辑文本文件的时候一定知道 Vim 这一款神器，它代替 Linux 默认原装的 Vi 编辑器，它的快捷键可以使你在操控文件的时候如庖丁解牛般流畅，博主目前只会简单的命令，感觉不能满足开发需求，今天特地的学习了一下，并且针对于常用的命令做了整理及汇总： ","date":"2020-05-16","objectID":"/linux-vim-command/:0:0","tags":["linux","vim"],"title":"Linux Vim 命令手记","uri":"/linux-vim-command/"},{"categories":["linux"],"content":"开源项目 首先，Vim 编辑器是一个开源的项目，按照惯例，请给开发者一个 Star 奖励： https://github.com/vim/vim ","date":"2020-05-16","objectID":"/linux-vim-command/:1:0","tags":["linux","vim"],"title":"Linux Vim 命令手记","uri":"/linux-vim-command/"},{"categories":["linux"],"content":"常用命令示意图 ","date":"2020-05-16","objectID":"/linux-vim-command/:2:0","tags":["linux","vim"],"title":"Linux Vim 命令手记","uri":"/linux-vim-command/"},{"categories":["linux"],"content":"常用命令参考 快捷键 操作说明 Ctrl + f 屏幕向下移动一页，类似 Page Down 按键 Ctrl + b 屏幕向上移动一页，类似 Page Up 按键 0 或 Home 键 移动到这一行最前面的字符处 $ 或 End 键 移动到这一行最后面的字符处 G 移动到这个文件的最后一行 gg 移动到这个文件的第一行，相当于 1G N[Enter] N 为数字。光标向下移动 N 行 /word 向下寻找一个名称为 word 的字符串 ?word 向上寻找一个名称为 word 的字符串 n 搭配查找 word 字符串使用，代表重复前一个查找的操作。例：如果前一个命令执行了 /word 命令去向下查找 word 这个字符串，当按下 n 后，会继续向下查找 word 这个字符串。 N 搭配查找 word 字符串使用，代表重复前一个查找的操作（反向）。 :n1,n2s/word1/word2/g 将此文本中的 word1字符串 替换为 word2 字符串 :1,$s/word1/word2/gc 将此文本中的 word1字符串 替换为 word2 字符串【给用户 confim提示】 x, X 在一行字符中，x为向后删除一个字符，X为向前删除一个字符 dd 删除光标所在那一行 ndd n为数字，删除光标所在向下n行 yy 复制光标所在那一行 nyy n为数字，复制光标所在向下n行 p, P p将已经复制的数据在光标下一行粘贴 P将已经复制的数据在光标上一行粘贴 u 复原前一个操作 Ctrl + r 重做上一个操作 . 重复上一个操作 ","date":"2020-05-16","objectID":"/linux-vim-command/:3:0","tags":["linux","vim"],"title":"Linux Vim 命令手记","uri":"/linux-vim-command/"},{"categories":["linux"],"content":"模式切换 快捷键 操作说明 i, I 进入插入模式（Insert mode）: i为目前光标所在处插入，I为在目前行所在的第一个非空格符处插入。 a, A 进入插入模式（Insert mode）: a为目前光标的下一个字符处插入，A为在目前行所在的最后一个字符处开始插入。 o,O 进入插入模式（Insert mode）: o为在目前光标所在下一行插入一个新行，O为在目前光标所在上一行插入一个新行。 r,R 进入替换模式（Replace mode）：r 只会替换光标所在的那一个字符一次，R 会替换光标所在的文字，直到按下 [esc] 键。 [esc] 退出编辑模式 ","date":"2020-05-16","objectID":"/linux-vim-command/:4:0","tags":["linux","vim"],"title":"Linux Vim 命令手记","uri":"/linux-vim-command/"},{"categories":["linux"],"content":"基础操作 快捷键 操作说明 快捷键 操作说明 :w 将编辑的文件写入磁盘文件中去。 :q! 强制退出编辑，且不保存操作。 :q 退出编辑，进入到命令行模式中去。 :wq 保存且退出编辑。 :wq! 强制保存且退出编辑。 Vim 环境修改。 :set nu 显示行号，设置后会在没有行前面前缀对应行号。 :set nonu 与:set nu相反，取消行号显示 ","date":"2020-05-16","objectID":"/linux-vim-command/:5:0","tags":["linux","vim"],"title":"Linux Vim 命令手记","uri":"/linux-vim-command/"},{"categories":["linux"],"content":"键盘标识 ","date":"2020-05-16","objectID":"/linux-vim-command/:6:0","tags":["linux","vim"],"title":"Linux Vim 命令手记","uri":"/linux-vim-command/"},{"categories":["mysql"],"content":"对于数据库这一块询问比较多的就是在 MySQL 中怎么去选择一种合适当前业务需求的存储引擎，而 MySQL 中支持的存储引擎又有很多种，那么 MySQL 中分别又有那些，怎么优雅的使用呢？ ","date":"2020-05-01","objectID":"/mysql-chooes-storage-engine/:0:0","tags":["mysql","engin","database"],"title":"怎么优雅的选择 MySQL 存储引擎","uri":"/mysql-chooes-storage-engine/"},{"categories":["mysql"],"content":"划分引擎原因 在文件系统中，MySQL 将每个数据库（也可以称之为 schema ）保存为数据目录下的一个子目录。创建表时，MySQL 会在数据库子目录下创建一个和表同名的 .frm 文件保存表的定义。例如创建一个名为 DebugTable 的表，MySQL 会在 DebugTable.frm 文件中保存该表的定义。 因为 MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在 Windows 系统中，大小写是不敏感的；而在类 Unix 系统中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在 MySQL 服务层wk统一处理的。 ","date":"2020-05-01","objectID":"/mysql-chooes-storage-engine/:1:0","tags":["mysql","engin","database"],"title":"怎么优雅的选择 MySQL 存储引擎","uri":"/mysql-chooes-storage-engine/"},{"categories":["mysql"],"content":"查看支持引擎 想了解 MySQL 中支持的引擎的情况，可以使用如下命令查看： show engines; 结果如下（MySQL版本：Ver 8.0.19）： mysql\u003e show engines; +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | MyISAM | YES | MyISAM storage engine | NO | NO | NO | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | ARCHIVE | YES | Archive storage engine | NO | NO | NO | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ 9 rows in set (0.00 sec) ","date":"2020-05-01","objectID":"/mysql-chooes-storage-engine/:2:0","tags":["mysql","engin","database"],"title":"怎么优雅的选择 MySQL 存储引擎","uri":"/mysql-chooes-storage-engine/"},{"categories":["mysql"],"content":"存储引擎分类 MySQL 存储引擎分类有 MyISAM、InnoDB、Memory、Merge等，可以看上面表中列出的支持引擎，但是其中最为常用的就是 MyISAM 和 InnoDB 两个引擎，其中针对于以上讲到的存储引擎，如下表进行对比： 对比项目 MyISAM InnoDB Memory Merge 存储限制 256TB 64TB RAM 内存表 / 是否支持事务 否 是 否 否 是否支持全文索引 是 否 否 否 是否支持数索引 是 是 是 否 是否支持哈希索引 否 否 是 否 是否支持数据缓存 否 是 否 否 是否支持外键索引 否 是 否 否 备注 支持事务，行级锁定和外键 指向MyISAM表操作 ","date":"2020-05-01","objectID":"/mysql-chooes-storage-engine/:3:0","tags":["mysql","engin","database"],"title":"怎么优雅的选择 MySQL 存储引擎","uri":"/mysql-chooes-storage-engine/"},{"categories":["mysql"],"content":"MyISAM 与 InnoDB 区别 两种类型最主要的差别是InnoDB支持事务处理与外键和行级锁。 InnoDB 可借由事务日志（ Transaction Log ）来恢复程序崩溃（ crash ），或非预期结束所造成的数据错误； 而 MyISAM 遇到错误，必须完整扫描后才能重建索引，或修正未写入硬盘的错误。 InnoDB 的修复时间，一般都是固定的，但 MyISAM 的修复时间，则与数据量的多寡成正比。 相对而言，随着数据量的增加，InnoDB 会有较佳的稳定性。 MyISAM 必须依靠操作系统来管理读取与写入的缓存，而 InnoDB 则是有自己的读写缓存管理机制。（ InnoDB 不会将被修改的数据页立即交给操作系统）因此在某些情况下，InnoDB 的数据访问会比 MyISAM 更有效率。 InnoDB 目前并不支持 MyISAM 所提供的压缩与 terse row formats（简洁的行格式） ，所以对硬盘与高速缓存的使用量较大。 当操作完全兼容 ACID（事务）时，虽然 InnoDB 会自动合并数笔连接，但每次有事务产生时，仍至少须写入硬盘一次，因此对于某些硬盘或磁盘阵列，会造成每秒 200 次的事务处理上限。 若希望达到更高的性能且保持事务的完整性，就必使用磁盘缓存与电池备援。 当然 InnoDB 也提供数种对性能冲击较低的模式，但相对的也会降低事务的完整性。而MyISAM则无此问题，但这并非因为它比较先进，这只是因为它不支持事务。 ","date":"2020-05-01","objectID":"/mysql-chooes-storage-engine/:4:0","tags":["mysql","engin","database"],"title":"怎么优雅的选择 MySQL 存储引擎","uri":"/mysql-chooes-storage-engine/"},{"categories":["mysql"],"content":"应用场景 MyISAM 管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的 SELECT 查询，那么 MyISAM 是更好的选择。 InnoDB 用于事务处理应用程序，具有众多特性，包括 ACID 事务支持。如果应用中需要执行大量的 INSERT 或 UPDATE 操作，则应该使用 InnoDB，这样可以提高多用户并发操作的性能。 ","date":"2020-05-01","objectID":"/mysql-chooes-storage-engine/:5:0","tags":["mysql","engin","database"],"title":"怎么优雅的选择 MySQL 存储引擎","uri":"/mysql-chooes-storage-engine/"},{"categories":["mysql"],"content":"参考文章 Mysql 存储引擎的区别和比较 - zgrgfr - CSDN Mysql的存储引擎之：MERGE 存储引擎 - 翔之天空 - CSDN MySQL存储引擎之 Merge 引擎 MySQL存储引擎 - MyISAM与InnoDB区别 - Rocky - 知乎 MySQL引擎介绍 - 慕课网 - 知乎 ","date":"2020-05-01","objectID":"/mysql-chooes-storage-engine/:6:0","tags":["mysql","engin","database"],"title":"怎么优雅的选择 MySQL 存储引擎","uri":"/mysql-chooes-storage-engine/"},{"categories":["tools"],"content":"近期由于工作原因需要更换公司原有 RTMP 协议推流，由于 Flash 插件今年年底就淘汰使用，并且一直在寻找一种并发好、延时低、同时便于回放功能的应用，在网上找到了基于Nginx + FFmpeg 推流的解决方案，可以实现 HLS 协议推流，看项目介绍可以实现 HLS+ 协议，这个工具安装比较便捷。 首先介绍一下这个开源的项目，欢迎给他们 star，谢谢。 https://github.com/pingostack/pingos 官网地址：https://pingos.io/ ","date":"2020-04-03","objectID":"/pingos-build-sever/:0:0","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["tools"],"content":"安装 项目文档：https://pingos.io/docs/zh/quick-start 在官方网站的项目文档中讲解的不是很清晰，特别是针对新手来说是有一定的难度，我这里使用的是 Linux CentOS 7.4 64位环境，需要提前安装 Git 应用，这个就不详细讲解了，接下来讲一下如何安装： ","date":"2020-04-03","objectID":"/pingos-build-sever/:1:0","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["tools"],"content":"1 下载源码 git clone https://github.com/pingostack/pingos.git ","date":"2020-04-03","objectID":"/pingos-build-sever/:1:1","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["tools"],"content":"2 快速安装 cd pingos ./release.sh -i ","date":"2020-04-03","objectID":"/pingos-build-sever/:1:2","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["tools"],"content":"3 启动服务 cd /usr/local/pingos/ ./sbin/nginx ","date":"2020-04-03","objectID":"/pingos-build-sever/:1:3","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["tools"],"content":"配置 一般情况下，安装完毕 PingOS 后就可以使用了，通过配置文件可以看到 nginx 占用端口为80，rtmp 端口占用为1935 。 但是在实际情况下，80 端口一般是使用于 HTTP 等服务，所以说尽量将服务端口设置为非 80 端口，由于使用了阿里云，可以关闭防火墙，同时配置安全组策略将 8080 入端口设置为允许状态。 下面是修改好的配置文件，位置为：/usr/local/pingos/conf/nginx.conf： user root; daemon on; master_process on; worker_processes 1; #worker_rlimit 4g; #error_log logs/error.log; #error_log logs/error.log notice; error_log logs/error.log info; worker_rlimit_nofile 102400; worker_rlimit_core 2G; working_directory /tmp; #pid logs/nginx.pid; events { # use epoll; worker_connections 1024; multi_listen unix:/tmp/http 8080; multi_listen unix:/tmp/rtmp 1935; } stream_zone buckets=1024 streams=4096; rtmp { log_format log_bandwidth '{\"app\":\"$app\",\"name\":\"$name\",\"bitrate\":$bitrate,\"args\":\"$args\",\"timestamp\":$ntp,\"ts\":\"$time_local\",\"type\":\"$command\",\"remote_addr\":\"$remote_addr\",\"domain\":\"$domain\"}'; access_log logs/bandwidth.log log_bandwidth trunc=60s; server { listen 1935; serverid 000; out_queue 2048; server_name localhost; application live { rtmp_auto_pull on; rtmp_auto_pull_port unix:/tmp/rtmp; # live_record on; # live_record_path /tmp/record; # recorder r1{ # record all; # record_path /tmp/record; # } # exec_publish bash -c \"ffmepg -i rtmp://127.0.0.1/live/$name -c copy /tmp/mp4/$name-$starttime.mp4\"; live on; hls on; hls_path /tmp/hls; hls_fragment 4000ms; # hls_max_fragment 6000ms; hls_playlist_length 12000ms; hls2memory on; mpegts_cache_time 20s; hls2_fragment 1300ms; hls2_max_fragment 1600ms; hls2_playlist_length 3900ms; wait_key on; wait_video on; cache_time 3s; low_latency off; fix_timestamp 2s; # h265 codecid, default 12 hevc_codecid 12; } } } http { include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_X-Forwarded-For\" \"$http_X-Real-IP\" \"$host\"'; access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #reset_server_name www.test1.com www.test2.com; #gzip on; server { listen 8080; location /rtmp_stat { rtmp_stat all; rtmp_stat_stylesheet /stat.xsl; } location /xstat { rtmp_stat all; } location /sys_stat { sys_stat; } location /control { rtmp_control all; } location /live { flv_live 1935; add_header 'Access-Control-Allow-Origin' '*'; add_header Cache-Control no-cache; } location /ts { ts_live 1935 app=live; } location /hls { # Serve HLS fragments types { application/vnd.apple.mpegurl m3u8; video/mp2t ts; } root /tmp; add_header Cache-Control no-cache; add_header 'Access-Control-Allow-Origin' '*'; } location /hls2 { hls2_live 1935 app=live; add_header 'Access-Control-Allow-Origin' '*'; add_header Cache-Control no-cache; } location / { chunked_transfer_encoding on; root html/; } } } 修改完配置之后需要进行 nginx 服务重新载入等操作。 ","date":"2020-04-03","objectID":"/pingos-build-sever/:2:0","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["tools"],"content":"命令 # 进入到 PingOS 应用目录，下面所有操作皆以此目录下进行 cd /usr/local/pingos/ # 开启 nginx 服务器 ./sbin/nginx # 检查 nginx 配置语法是否正确 ./sbin/nginx -t # 重新加载 nginx 配置 ./sbin/nginx -s reload # 停止 nginx 服务器 ./sbin/nginx -s stop ","date":"2020-04-03","objectID":"/pingos-build-sever/:3:0","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["tools"],"content":"推流 配置好服务器，可以看一下流媒体服务器推流效果，这里我是用的是 OBS 推流应用，推流端使用的是 RTMP 协议，在播放端使用的是 hls+ 协议。 这里给大家提供两个官方推荐查看推流效果的地址，也是应用提供的 Web 页面： http://ip地址:端口/h5player/flv 无插件播放http-flv直播流 http://ip地址:端口/rtmp_stat 查看当前服务器推流统计数据 播放地址：http://ip地址:端口/hls2/流名.m3u8 ","date":"2020-04-03","objectID":"/pingos-build-sever/:4:0","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["tools"],"content":"参考 PingOS 项目参考 怎么搭建hls低延时直播（lowlatency hls）- 知乎 最后，这是一个系列的文章，后续还有针对 PingOS 流媒体服务还有对应优化，敬请关注 ","date":"2020-04-03","objectID":"/pingos-build-sever/:5:0","tags":["pingos","ffmpeg","hls"],"title":"搭建流媒体服务器 PingOS 平台搭建","uri":"/pingos-build-sever/"},{"categories":["computer"],"content":"早就想着装一台组装机，来实操一下高中学的计算机组装与维修 ?，哈哈，开玩笑，想着组装一台电脑是我早有打算的事情，凭借着在学校实验室的时候帮助老师修理百十来台电脑的经验也可以轻松应对，正好家里人有装电脑的需求，本想着装机是一件比较愉快的事情，实时是激动的心、残废的手，装机翻车了，不过整体流程还可以，最后也正常的运行了起来，听我细细道来吧。 ","date":"2020-03-21","objectID":"/computer-install/:0:0","tags":["computer"],"title":"记一次不太正规的装机实践","uri":"/computer-install/"},{"categories":["computer"],"content":"配置 朋友出价，我出配置，4000左右机型，性能还可以。 配件名称 型号 价格 CPU 英特尔（Intel）i5 9400F 酷睿六核 盒装CPU处理器 ¥1199 主板 技嘉（GIGABYTE）B365 M AORUS ELITE ¥669 显卡 七彩虹（Colorful）iGame GeForce GTX 1650 SUPER AD Special OC 4G 1530-1755MHz ¥1279 内存条 金士顿(Kingston) DDR4 2666 8GB 台式机内存条 骇客神条 Fury雷电系列 ¥359 SSD 东芝（TOSHIBA）250G SSD固态硬盘 M.2接口（NVME协议） RC500系列 ¥409 电源 鑫谷（Segotep）额定350W 核动力-巡洋舰 Q5 电源 ¥139 散热器 酷冷至尊(Cooler Master) 暴雪T400i 风冷散热器 ¥89.9 机箱 爱国者（aigo）炫影黑京东专供版 电脑机箱（配3把发光风扇/支持ATX主板/蜂窝玻璃面板/背线） ¥229 总价 ¥4322.90 ","date":"2020-03-21","objectID":"/computer-install/:1:0","tags":["computer"],"title":"记一次不太正规的装机实践","uri":"/computer-install/"},{"categories":["computer"],"content":"包装 不得不说，京东快递就是很快，不过，快归快，3000米，抱着这三个大箱子往住的地方跑，最后手抖不停???，看来要健身减肥了。 打开了纸箱，买的配件都显露了出来，在床上摆拍了一下。 很壮观，也很有气势，哈哈，接下来就进行拆解组装了………… ","date":"2020-03-21","objectID":"/computer-install/:2:0","tags":["computer"],"title":"记一次不太正规的装机实践","uri":"/computer-install/"},{"categories":["computer"],"content":"组装 一般组装都讲究顺序，作为从不看产品使用说明的我，上来就装起了主板 ?，看到 CPU 和散热风扇在孤零零的躺着，emmm，拆出来吧，唉，就这样才把 CPU 放上，装上了内存，固态 SSD，和散热器，由于太过锋利，又没有防护措施，唉，挂了彩。 此处省略弱鸡的我装机，省略500子，最后终于安装成功。 给大家一个实践得来的建议，装机顺序，一定要记好： 安装 CPU 及散热风扇； 安装内存条、M.2 接口类型的固态； 安装主板，固定扩展插槽位置对齐； 安装电源； 安装显卡； 从背部走线，对应主板、CPU供电插槽、显卡供电插槽、音视频，USB2.0/3.0 、散热器供电插槽插上对应的线，同学们，看说明书； 开机，测试安装如何； 可以的话就整理线，用扎带固定好，关上机箱，就可以喽。 经过以上安装步骤，终于安装完毕，请看结果： 插上电源，为我爆灯……………… 正常运行，感觉良好，记下来就要装系统喽。 ","date":"2020-03-21","objectID":"/computer-install/:3:0","tags":["computer"],"title":"记一次不太正规的装机实践","uri":"/computer-install/"},{"categories":["computer"],"content":"系统 首当其从，当然是 Windows10 啦，嗯，没错，只有 Windows10 是可以配得上我亲手装的机器，所谓郎才配女貌 ??。从公司让同事帮忙借了一套显示器及无线键鼠，之后又安装了大白菜系统，开始安装。 不得不说，现在的配置安装 windows10 真的很快，并且开关机可以达到5秒内完成，牛掰。 ","date":"2020-03-21","objectID":"/computer-install/:4:0","tags":["computer"],"title":"记一次不太正规的装机实践","uri":"/computer-install/"},{"categories":["coin","financing"],"content":"最近在上了一个在线的理财班（微信群实时上课），因为收费比较便宜，自己抱着学到赚到的原则，看看实际情况进行合理安排自己的进阶课程，因为知道这是一个类似公益性质的课程，之后会推荐他们专业课程，所以自己有一定的衡量，接下来对这个理财做一下小结。 之前并没有意思到理财的重要性，主要是因为理财感觉还比较遥远，后来上课之后了解到，十年至今中国的通货膨胀率远远比现在银行存款利率高，也就是说现在的人民币在手中注定着贬值，贬值的速度远远大于自己资金的积累，最后就会变成一颗韭菜，时间会变成一个巨大的收割机，如果不开始理财，自己会变成新一代的韭菜避免不了被割的风险。 “富人思维”是为期12天理财课程培养的重点，主要是让你养成一个好的攒钱投资的习惯，学会利用“钱生钱”，接下来就给大家介绍一下学习的十四条“富人思维”： ","date":"2020-02-28","objectID":"/coin-financing/:0:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第一条 获得经济独立、财务自由的意义是什么？ 经济独立、财富自由并不是独善其身，它的本质是让自己、家人变的更好的能力。 【从个人讲】，可以更好的选择自己喜欢的东西、自己喜欢的生活方式、婚姻方式，最终实现踏踏实实靠自己，得来属于自己的精神自由。把经济这个生存的“命脉”交给他人，其实就是把自己选择的权力让给了他人，也把自己生活的主动权让给了他人。 【从家庭讲】，与爱人共同分担家庭的财务重担，应对老人的医疗花销、孩子的教育花销，让家庭关系因为共同的努力获得财富而更美好，而不是因为钱受到冲击而动摇。 一句话总结：提升理财技能，实现财务独立，获得更多自主选择的权力，获得给家人更好的生活的能力。 ","date":"2020-02-28","objectID":"/coin-financing/:1:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第二条 月光或者积蓄不多的人，为什么不能等有钱再学习理财？ 月光和积蓄不多本质是错误理财思维造成的结果， 【在花钱上】，很多都是坏支出，一心只想买买买，很多东西在冲动消费之后要么用了几次就放置一边，要么后悔自责又在下次陷入到恶性循环，但对于投资自己成长的好支出，却又思前想后。其关键在于，没有好支出、坏支出的思维意识，被欲望牵着走，没有将有限的资金花在刀刃上。 【在攒钱上】，单纯靠工资攒钱是最低效最差的方式，如果只靠工资收入来攒钱，很可能到退休了还没有攒够理财的本金。真正聪明的小伙伴会在获得第一笔工资收入时就开始选择合适的理财工具来积累自己的本金和非工资收入了。 具有富人思维的人，哪怕是现在月光或者积蓄不多，就会从一开始就通过工资和非工资收入两条路径来增加自己的收入。两条腿走路肯定比只靠工资收入一条腿走的更快更远。 一句话总结：提升财富要靠工资和非工资收入【两条腿】走路，绝对不能独腿前行。 ","date":"2020-02-28","objectID":"/coin-financing/:2:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第三条 中产家庭为什么不能沉溺在自己的工资收入中？ 中产家庭看似收入比较稳定，其实抗风险能力不强，他们有房贷要还，小孩要养，甚至父母还要大量的开销。 【孩子还未成人的家庭】，孩子没有收入，花销逐年增大，这时候如果夫妻中有一人遇到一段时间不能工作的情况，家庭财务整体情况可能会出现较大落差，进而影响生活质量。 【全职宝妈的家庭】，女性负责照顾孩子，没有工资性收入，只有老公一人的收入是家庭收入的主要来源，如果老公遭遇大裁员等意外情况，家庭很可能立即陷入坐吃山空的财务危机中，或者啃老的尴尬境地。 所以中产家庭更需要尽早尽快建立自己的非工资收入体系，【在没发生意外的时候】，可以为家庭提供一份额外的收入，补贴家用；【在发生意外的时候】，能够抵御财务风险，不至于到毫无收入的被动地步。 学习并掌握获得非工资收入的能力，是为自己负责，也是为了家人负责。 一句话总结：中产的【财务安全】来自工资收入和非工资收入的双管齐下，没有充足的非工资收入的中产家庭，谈不上财务真正安全。 ","date":"2020-02-28","objectID":"/coin-financing/:3:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第四条 为什么说复利三要素中最容易掌控的是收益率？ 复利三要素，本金、时间、收益率。把钱存在保险箱中，复利会发挥反向作用，把钱一口一口吃掉，长期来看1万元每年贬值500元以上。投资开始的越早，时间要素发挥越大，复利的正向作用越早发挥作用。本金大的人，复利作用也比较大，但是投错了地方，本金再大也会亏完。如果本金和时间都不占优势，那么最有效的就是提高年化收益率，而提高年化收益率的关键在于自己的理财能力。 一句话总结：【时间无法改变，越早开始越好；本金依赖生钱资产；收益率源于理财能力，理财能力才是决定复利终值的关键】。 ","date":"2020-02-28","objectID":"/coin-financing/:4:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"富人关键思维 - 第五条 为什么说投资自己的大脑、学会理财技能也是中产升级之法？ 如同经典书籍《富爸爸》中说的，穷人卖时间换钱，其实本质是“卖命”。他们抱怨自己没有钱，其实本质是他们没有认识到投资自己的大脑是最快的脱贫致富之法。 比如一个专家花费一生写了一部巨著，我们花100元买了他的书回来看，其实某种意义上我们是买到了他一生的生命成果，学到了能获得成千上万的收益，这就叫“站在巨人的肩膀上”，贫穷的矮人站在“巨人的肩膀上”也会达到巨人的视野。 但很多人心疼这点投资大脑的钱，所以一直什么都不懂，一直贫穷下去。反之，穷人也能通过投资自己的头脑，学习他人成功的方法，买他人花了很多时间转化的成果，变成自己的东西，快速创造财富，这是最快的脱贫之法。 一句话总结：心疼投资大脑的钱，一直什么都不懂，不是被通货膨胀割韭菜，就是被投资市场割韭菜，一直穷下去。反之学习他人成功的方法，变成自己的技能，是最快的脱贫、升级之法。 ","date":"2020-02-28","objectID":"/coin-financing/:5:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第六条 到底什么时候可以开始投资? 为什么有的人买股票必亏，看了几本书，学了几天课就急急忙忙要去股市里了，我们学车还要几个月，投资作为高度专业化、精细化的一个领域，不经过系统的学习就去“尝试”，这和训练了三天、看了几本武侠小说就上战场的士兵有什么区别呢? 士兵进行系统训练是为了保命，投资者进行系统的学习是为了保钱的“命”，反之，学个半瓶水就去投资市场，美其名为“试试”，这样的“试试”不会学到任何教训、经验，只会收获痛苦。那些经过系统训练的人会把那些无知而自以为是的人收割的一滴血不剩。 【这就是投资的真相】，不系统学习就想赚快钱就是送命。当你打算投资一个目标，有系统的分析方法，不再为了涨跌而心惊胆战的时候，这才是投资可以真正开始的时候。 一句话总结:投资第一原则:不懂不要投，懂了安心投，盲目“尝试”无疑送命，系统训练方可真正保住钱“命”。 ","date":"2020-02-28","objectID":"/coin-financing/:6:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第七条 为什么月光、负债的人应该拿出一部分资金学习理财技能？ 这里的负债主要指的是让自己的财务状况不断恶化的【坏负债】。 月光和负债只是不懂理财的结果，没有理财技能才是月光和负债的原因。很多人一方面不懂投资的骗局，一方面又眼红想赚一下，最终都入了骗局的“坑”，如果提前投资自己的大脑，难道还会犯这样的错误吗？还有很多人，本来钱就不多，贷款买了一堆耗钱资产，要么不断的刷信用卡、花呗、借呗，窟窿越来越大，要么生活拮据，每天人前风光，人后遭殃。 但对于投资自己，提升理财技能的好负债，他们却斤斤计较，错失了复利的好机会，这样的人生活只会越来越难过。 【成长有顺序，生活致富也有顺序】——先投资大脑，掌握理财的技能，然后再去生钱，月光、负债不学习只会越来越穷?? 一句话总结：月光、负债是财务病，病根是缺少理财技能，忽视病因、不治病根，坏支出、坏负债只会越来越严重。 ","date":"2020-02-28","objectID":"/coin-financing/:7:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第八条 股票价格大跌能跌出什么？ 我们【投资股票正确的方法】可以分为两大步： 第一步：选出内在价值高的好企业 第二步：在好的价格及时买入 这两步是不能颠倒的。 【当股市的价格出现下跌时】，好企业代表的好股票会出现好的买入价格，但是坏企业会跌出让投机者眼红的“陷阱”。如果在选择企业这一步错了，不管是多便宜的价格都徒劳无功，反而损失惨重。 【理性的投资者】对自己无法预测股票价格有自知之明，因为价格的波动总是难以预测的，因此他们将主要精力放在好企业的选择上，当好价格出现的时候果断出手，而后不管是继续跌还是涨，都是任凭风浪起稳坐钓鱼船。他们一般很少看股票，却获得了很高的收益。 一句话总结：股票大跌既有机会也有陷阱，机会的识别需要眼力，机会的把握需要技能，当眼力和技能配不上这个机会的时候，往往会步入陷阱之中。 ","date":"2020-02-28","objectID":"/coin-financing/:8:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第九条 很多人炒股都亏，就说股票风险高，到底该怎么看待投资股票这件事？ 【投机炒股的人】，不懂就去投，一心想赚一把就走，那么股市就是一个大赌场，都特别想赢钱，但又特别怕输钱，风险自然是非常大 而且还很容易上当受骗，赚了以为是自己本事，亏了又说运气不好，说到底都是自欺欺人。 涨了开心要命，跌了悲伤绝望，被价格的波动带着一天悲喜两重天，说到底还是没有技能让自己内心踏实? 【真正的投资股票】，是关注股票代表的公司的好坏，是看到股票背后的本质，经过严谨的分析得出的结论。 这样的投资，即使短时间的价格波动也能心理踏实，最终能够获得复利带来的长期收益?? 一句话总结：投资股票的正确姿势是靠分析，能选出好股票风险自然就小。赌徒在股市是把身家性命交给市场，不懂就投，肯定要被懂的人收割的。 ","date":"2020-02-28","objectID":"/coin-financing/:9:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第十条 为什么工作者、投资者都需要通晓企业分析技能？ 并不是创业者 、大老板才需要了解企业。 【投资中】，股票本质是企业，只有把9大要素都分析清楚，才能分析出好企业，才能给企业估值. 【工作中】，干工作的时候要有企业经营的思维，这样才更容易升职加薪。 即便不为升职，干工作的时候也要有企业经营的思维。因为当你站在更高去看自己的工作内容的时候你才能更好的理解自己的工作内容，这样你可以把工作做成老板真正想要的样子。 而那些只盯着自己的岗位的“井底之蛙”，有的时候挨了骂都不知道为什么，因为他缺乏跳出自己的框框看企业的技能，这就是他自己工作干不好的原因。 所以无论投资、工作，都需要通晓企业分析技能。 总结一句话：工作者用企业分析模型看透工作，投资者用企业分析模型看透股票? ","date":"2020-02-28","objectID":"/coin-financing/:10:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第十一条 为什么要自己掌握理财技能才是最可靠的？ 很多之前学员都表示跟着自己的家人、朋友投资，当赚了的时候会特别感激对方，但是亏的了时候又怨恨对方不靠谱。其实他们的家人、朋友很多也真的是好心，但是他们没有掌握投资技能，靠着小道消息，本质是投机，赚了是运气好，长期亏损是必然。 理财投资这么重要的事情，如果交给别人，就像把自己的“财富之命”交给了别人，如果遇上的是一个没有扎实理财技能的人，那就对自己的“财富之命”太不负责了。因为缺乏理财技能的人，是根本拿不住好股票的，他们无法分析企业，就无法正确面对价格的波动，最终还是逃不过亏损的命运。 而听信银行经理的话，选择银行理财，长期看收益连通货膨胀的贬值都跑不赢。 特别是【中产家庭】，与其听信他人的小道消息，【最可靠的】还是自己通过学习成为家庭资产理财师，为自己的家人打理财产，创造更多非工资收入，这才是最安全可靠的方法。 【一句话总结】：最重要的本事需要掌握在自己手中，就像企业要把核心竞争力掌握在自己的手中一样，理财——事关自己和家庭的财富之命，只有自己掌握了，才是对自己的负责。 ","date":"2020-02-28","objectID":"/coin-financing/:11:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第十二条 我们最应该为孩子留下什么财富？ 我们总想为孩子留下一笔钱、一套房等，这并没有错，但我们给孩子留下的最重要财富却不是金钱。因为如果给孩子留下了金钱，但孩子无法对抗通货膨胀的贬值、缺少科学的理财知识，金山也会吃空，最终落得个流离失所的下场，正如我们前面讲到的山西首富之子一样。 【聪明的父母】会选择在孩子很小的时候就开始正确的财商教育，让孩子从小就养成正确的金钱观，从很小的时候就享受理财技能带来的复利，而【这都取决于父母的理财能力】，如果父母对理财一无所知，或者学个半瓶水，看似明白实则跑偏，那么不仅教不好孩子，还会把孩子带到错误的方向 【不要让孩子像我们父辈和自己一样】，那样又要陷入“无知”—“试错”—“损失”的恶性循环之中，耗费大量的时间成本、试错成本，又错失了大量的机会成本，我们走错的路，就不要让孩子再走一遍了。 【总结一句话】：我们最应该留给孩子的财富是可贵的品格和可靠的理财能力，身教重于言教，用我们的行为带动孩子品格的养成，用我们的理财能力让孩子的财商有一个好基础?? ","date":"2020-02-28","objectID":"/coin-financing/:12:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"富人关键思维 - 第十三条 掌握收益率高的工具的科学方法是什么？ 【方法一】：很多人刚刚知道有一个高收益的工具，恨不得马上就买一个，然后就自我憧憬能赚多少。或者选择去市场中直接尝试，事实证明，他们自己总结的方法时而有效，时而无效，时而自信找到了暴富出路，时而迷茫否定自己、骂社会，我称之为焦虑的“【烧钱尝试法】”。其实他们不仅损失了自己的血汗钱，同时在错误尝试的时间里，也错过了正确买入好目标的机会。 【方法二】：其实最快的方法，绝对不是马上去盲目尝试，莫刀不误砍材工，应该先去学习，在学习中最快的方法，是什么，是看书吗？如果看书能够实现财务自由，那么很多人早就财务自由了，因为看书最大的弊端就是没有反馈，没有人告诉你学的对还是学的错。沉溺在看书中寻求财富自由的人，不能说不努力，但是因为没有老师指点，很多都成了【无效的努力】，最可怕的不是慢，是选错了方向，走错了路，在错误方向上的努力只是巩固错误。 【方法三】：那么最快的学习方法是什么？答案是【巨人同行法】，跟着已经长期成功的投资者学习，巴菲特的老师是投资之神格雷厄姆，我们前天早读课中8岁的投资神童，她的老师是父亲，也是成功投资家。他们都是一边勤奋学习理论，一边在老师的指导下纠正错误，一直走在一条正确的努力之路上。这就是看似缓慢，但实际最快的投资之路。这是一条少有人懂得的路，也是一条少有人走的路，所以真正赚钱的投资者才不多。你打算选哪条路？ 总结一句话：站在巨人的肩膀上，在少有人走的投资学习之路上最快成长。 ","date":"2020-02-28","objectID":"/coin-financing/:13:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["coin","financing"],"content":"关键富人思维 - 第十四条 有的投机者说自己也赚钱了，那么选择做投资者到底好在哪？ 我们投资理财到底是为了什么呢？赚钱，但进一步想，赚钱是不被钱绑架，能有时间做自己想做的事，能和家人快乐的生活。 【不懂就去投的人】，短期内碰上运气了，也能赚到钱，但是他们是怎么度过的呢，每天把大量时间用来盯着大盘，昼夜想着跌了还是涨了，精神总是高度紧张，甚至睡觉都在想明天股票的情况，因为他们选择了“赌博”。历史证明，绝大多数投机者本来最应该乐观开心的两年，到头来却是在焦虑、闹心中度过的，因为他们没有真正的投资判断依据，这就是投机者的生活。 【懂得投资的人】，通过一整套分析方法选出优质的投资目标，算出买入好价格，买入，持有，再算出卖出合理价格，卖出。剩下的时间该干什么干什么，价格跌了，心里知道这是表面的波动，不被其迷惑，拿得住；价格涨了，知道什么时候该卖出，不冲动，赚踏实稳当钱。更厉害的，长期持有，被分红的复利滋润着。这是学习科学方法的自然成果，这也是不学习像苍蝇撞大运的投机者，与踏实学习走正道的投资者的最大差别。 当然，既不投机，也不投资的人都感受不到这些，他们只能感受到钱越来越不值钱，而自己的生活好像越来越紧吧了。 总结一句话：投资者获得的是金钱自由，时间自由，心理自由，投机者就算撞运赚了点，却一直在焦虑与煎熬中。 以上就是十四条富人思维总结来说就是：“不懂不要投，懂了放心投”。 不过目前没有相关的经验，还是一只实习生，不过还要“利其器”，防止以后踩坑。 ","date":"2020-02-28","objectID":"/coin-financing/:14:0","tags":["coin"],"title":"近期理财学习总结","uri":"/coin-financing/"},{"categories":["redis"],"content":"1.Redis数据结构有哪些 ？ String List Hash Set Sorted Set bitmap Geo HyperLogLog Streams 2.Redis相比memcached有哪些优势？ memcached 所有的值均是简单的字符串; redis 作为其替代者，支持更为丰富的数据类型; redis 的速度比 memcached 快很多 redis 可以持久化数据。 3.Redis是单线程，如何解决并发请求访问？ redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。 4. Reids6 淘汰策略有哪些？ noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存，有极少数会例外。 LRU算法 allkeys-lru:所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。 volatile-lru:只限于设置了expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。 随机淘汰 allkeys-random: 所有key通用; 随机删除一部分 key。 volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。 volatile-ttl: 只限于设置了expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。 5.Redis持久化方案有哪些？ RDB(Redis DataBase)持久化：是指用数据集快照的方式半持久化模式，记录redis数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复； AOF(Append-only file)持久化：是指所有的命令行记录以redis命令请求协议的格式完全持久化存储，保存为aof文件。 RDB和AOF的优缺点 ： RDB持久化: 优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。 缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。 AOF持久化: 与RDB持久化相对应； 优点在于支持秒级持久化、兼容性好； 缺点是文件大、恢复速度慢、对性能影响大。 6.Redis内存划分 数据: 作为数据库，数据是最主要的部分； 这部分占用的内存会统计在used_memory中。 进程本身运行需要的内存: Redis主进程本身运行肯定需要占用内存，如代码、常量池等等； 这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。 这部分内存不是由jemalloc分配，因此不会统计在used_memory中。 缓冲内存: 缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等； 其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能； AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。 在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配， 因此会统计在used_memory中。 内存碎片: 内存碎片是Redis在分配、回收物理内存过程中产生的。 例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。 7.Redis 主从复制 复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。 复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。 缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制 。 8.Redis哨兵 在复制的基础上，哨兵实现了自动化的故障恢复。 缺陷：写操作无法负载均衡；存储能力受到单机的限制。 9.redis缓存被击穿处理机制 使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个 get缓存方法。 10.缓存和数据库间数据一致性问题 分布式环境下非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。 只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列 。 11.缓存雪崩问题 像解决缓存穿透一样加锁排队； 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存。 12.Redis分布式 redis支持主从的模式。 原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。 这是一个典型的分布式读写分离模型。利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量 。 13.读写分离模型 通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。 读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。 14.数据分片模型 为解决读写分离模型的缺陷，可以将数据分片模型应用进来。 可以将每个节点看成，都是独立的 master，然后通过业务实现数据分片。 结合上面两种模型，可以将每个 master 设计成由一个 master 和多个slave组成的模型。 15.Redis分布式锁实现 先拿 setnx 来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？ set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！ 16.Redis做异步队列 一般使用list结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当sleep一会再重试。 缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。 能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。 17.Redis中海量数据的正确操作方式 利用SCAN系列命令（SCAN、SSCAN、HSCAN、ZSCAN）完成数据迭代。 18.是否使用过Redis集群，集群的原理是什么？ Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。 Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。 19.Redis集群方案什么情况下会导致整个集群不可用？ 如果有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。 20.说说Redis哈希槽的概念 Redis集群没有使用一致性hash，而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。 21.Redis集群会有写操作丢失吗？为什么？ Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 22.怎么测试Redis的连通性？ 使用ping命令。 23.怎么理解Redis事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 24.Redis如何做内存优化？ 尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。 25.Redis回收进程如何工作的？ 一个客户端运行了新的命令，添加了新的数据。Redis检查内存使用情况，如果大于max memory的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一","date":"2020-01-28","objectID":"/redis-summary/:0:0","tags":["redis"],"title":"Redis 知识点汇总","uri":"/redis-summary/"},{"categories":["redis"],"content":"头条面试 1.Redis连接时的 connect 与 pconnect 的区别 connect：脚本结束之后连接就释放了。 pconnect：脚本结束之后连接不释放，连接保持在php-fpm进程中。 2.Redis有哪些结构时间复杂度较高 List 3.Redis hash的实现 哈希对象的编码可以是 ziplist 或者 hashtable 。 ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此,保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前，保存值的节点在后；先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。 4.redis 主从同步是怎样的过程？ 见第7题 5.redis 的 zset 怎么实现的？ 有序集合的编码可以是 ziplist 或者 skiplist 。 ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。 skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表。 ","date":"2020-01-28","objectID":"/redis-summary/:1:0","tags":["redis"],"title":"Redis 知识点汇总","uri":"/redis-summary/"},{"categories":["redis"],"content":"小米面试 1.Redis数据结构有哪些 String，List，Hash，Set，Sorted Set，bitmap，Geo，HyperLogLog ，Streams 2. Redis 持久化方案有哪些？ RDB(Redis DataBase)持久化：是指用数据集快照的方式半持久化模式，记录redis数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复 AOFAppend-only file。 持久化： 是指所有的命令行记录以redis命令请求协议的格式完全持久化存储)保存为aof文件。 ","date":"2020-01-28","objectID":"/redis-summary/:2:0","tags":["redis"],"title":"Redis 知识点汇总","uri":"/redis-summary/"},{"categories":["redis"],"content":"360 面试 1.redis的持久化 RDB(Redis DataBase)持久化： 是指用数据集快照的方式半持久化模式，记录redis数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复AOFAppend-only file。 持久化： 是指所有的命令行记录以redis命令请求协议的格式完全持久化存储)保存为aof文件。 2.lru算法实现 \u003c?php /** * LRU是最近最少使用页面置换算法(Least Recently Used) * 也就是首先淘汰最长时间未被使用的页面 */ class LRU_Cache { private $array_lru = array(); private $max_size = 0; function __construct($size) { // 缓存最大存储 $this-\u003emax_size = $size; } public function set_value($key, $value) { // 如果存在，则向队尾移动，先删除，后追加 if (array_key_exists($key, $this-\u003earray_lru)) { unset($this-\u003earray_lru[$key]); } // 长度检查，超长则删除首元素 if (count($this-\u003earray_lru) \u003e $this-\u003emax_size) { array_shift($this-\u003earray_lru); } // 队尾追加元素 $this-\u003earray_lru[$key] = $value; } public function get_value($key) { $ret_value = false; if (array_key_exists($key, $this-\u003earray_lru)) { $ret_value = $this-\u003earray_lru[$key]; // 移动到队尾 unset($this-\u003earray_lru[$key]); $this-\u003earray_lru[$key] = $ret_value; } return $ret_value; } public function vardump_cache() { var_dump($this-\u003earray_lru); } } $cache = new LRU_Cache(5); $cache-\u003eset_value(\"01\", \"01\"); $cache-\u003eset_value(\"02\", \"02\"); $cache-\u003eset_value(\"03\", \"03\"); $cache-\u003eset_value(\"04\", \"04\"); $cache-\u003eset_value(\"05\", \"05\"); $cache-\u003evardump_cache(); $cache-\u003eset_value(\"06\", \"06\"); $cache-\u003evardump_cache(); $cache-\u003eset_value(\"03\", \"03\"); $cache-\u003evardump_cache(); $cache-\u003eset_value(\"07\", \"07\"); $cache-\u003evardump_cache(); $cache-\u003eset_value(\"01\", \"01\"); $cache-\u003evardump_cache(); ","date":"2020-01-28","objectID":"/redis-summary/:3:0","tags":["redis"],"title":"Redis 知识点汇总","uri":"/redis-summary/"},{"categories":["linux"],"content":"近期在开发项目中遇到了PHP使用shell_exec执行 Shell 命令的问题，具体说是 Shell 使用 FFmpeg 软件进行录制直播流，但是 PHP 等待命令执行时间是有限的，并且会出现等待时间过长导致该执行接口出现未响应问题，寻找了网上方法，发现了一种比较好的方式，就是将要执行的Shell语句后面加上\u003e/dev/null 2\u003e\u00261这段特殊的命令，简单来说就是将执行的 Shell 操作放到后台进行运行，将快捷反应执行的操作，解决执行 Shell 语句等待问题，接下来就是对这段命令的解析： 命令的结果可以通过%\u003e的形式来定义输出。 /dev/null 代表空设备文件 \u003e 代表重定向到哪里，例如：echo \"123\" \u003e /home/123.txt； 1 表示 stdout 标准输出，系统默认值是 1，所以\u003e/dev/null等同于1\u003e/dev/null； 2 表示 stderr 标准错误； \u0026 表示等同于的意思，2\u003e\u00261，表示 2 的输出重定向等同于 1。 针对下面数字的代表含义的解释： 0:表示键盘输入(stdin) 1:表示标准输出(stdout),系统默认是1 2:表示错误输出(stderr) \u003e /dev/null 2\u003e\u00261 语句含义： \u003e /dev/null ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2\u003e\u00261 ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 ","date":"2020-01-13","objectID":"/linux-dev-null-file/:0:0","tags":["linux","shell"],"title":"Linux \u003e/dev/null 2\u003e\u00261 命令使用说明","uri":"/linux-dev-null-file/"},{"categories":["js"],"content":"马上就要到了传统节日“春节”?，网站添加了飞雪❄️特效，从网上找了源代码，先要感谢张戈博客分享?，现计划将网站在今天上线至过年回来下线，看看可以么，你可以复制到自己的网站或者博客体验一波，加上《一剪梅》真是别有一番滋味。 \u003cscript type=\"text/javascript\"\u003e (function($){ $.fn.snow = function(options){ var $flake = $('\u003cdiv id=\"snowbox\" /\u003e').css({'position': 'absolute','z-index':'9999', 'top': '-50px'}).html('❄'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = { minSize : 6, maxSize : 10, newOn : 1000, flakeColor : \"#FFFFFF\" /* 此处可以定义雪花颜色 */ }, options = $.extend({}, defaults, options); var interval= setInterval( function(){ var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css({ left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor }).animate({ top: endPositionTop, left: endPositionLeft, opacity: 0.2 },durationFall,'linear',function(){ $(this).remove() }); }, options.newOn); }; })(jQuery); $(function(){ $.fn.snow({ minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 20,/* 定义雪花最大尺寸 */ newOn: 800 /* 定义密集程度，数字越小越密集 */ }); }); \u003c/script\u003e ","date":"2020-01-12","objectID":"/js-snowflake/:0:0","tags":["js","jquery"],"title":"JavaScript  飞雪特效","uri":"/js-snowflake/"},{"categories":["summary"],"content":"2019年，这一年来是我经历最多的一年，上半年的我还在学校上着学校学年安排的课程，谈着美好的校园恋爱，下半年就脱离了校园生活，开始独自一人的北漂生活，这一年来也是这个社会变化较大的一年，5G 的商业化的元年，最难就业的一年，等等，这一年现在告诉自己，我坚持了下来，在这个多变的社会生存了下来，顺利找到了实习工作，从校园实验室生活转变为两点一线的上班生活，开始了不一样的生活体验。 这一年来，我的博客访问量也逐渐增多，网站使用了阿里云 ECS + OSS + CDN 全套服务提升性能，虽然写的文章不及阮一峰老师的千万分之一，但是我可以自豪的说，这一年我坚持了下来，持续的积累技术知识及新型的技术的评价让我的博客文章逐渐的多了起来，在项目中的开发知识积累也都写在博客上面，逐步丰富自己的技术栈，使自己成为一个足够优秀的人，来到北京逐渐发现，自己是那千万人中最最平凡的一类人，正如现在实习公司所说：“平凡人做非凡事，成就非凡人生价值”，不断的提升自己的技术能力及分析问题的能力是我现在要做的，另外也是我2020年博客更新的一大方向，2019年，感谢支持Debug客栈成长的小伙伴们，谢谢你们的鼓励与支持，你也可以加入我的QQ群聊，大话人生 @Debug客栈交流群。 2020年，迎来我大学的结束，并且我也将从实习生的身份转变为应届生，开始了真正的工作，去为社会主义添砖加瓦，2020年加油，奥力给！！！ ","date":"2019-12-31","objectID":"/debuginn-2019/:0:0","tags":["Debug客栈","2020","2019","年度总结"],"title":"2019 年度总结","uri":"/debuginn-2019/"},{"categories":["summary"],"content":"热门文章 接下来将网站本年度每月阅读量最高的文章张贴如下： 一月 蓝桥杯 基础练习 数的读法 二月 【NCRE四级网络工程师】计算机网络多选题 三月 解决百度网盘限速问题 四月 可能是史上最全的无版权免费图片网站推荐文章 五月 Laravel5.8+LayUI踩坑之路 六月 Laravel5.8学习日常之清除视图缓存 七月 给网站文字添加高逼格\"抖音\"效果 八月 关于5G的SA与NSA架构 九月 PWA 渐进式Web应用程序 十月 Windows常用软件清单 十一月 MacBook Pro 2019款 入手体验 十二月 PhpStorm Mac / Windows常用快捷键 其中在2019年访客最多的文章是：关于5G的SA与NSA架构 ","date":"2019-12-31","objectID":"/debuginn-2019/:1:0","tags":["Debug客栈","2020","2019","年度总结"],"title":"2019 年度总结","uri":"/debuginn-2019/"},{"categories":["summary"],"content":"网站访客 这里公布的是从2019年8月20日开始统计，使用Google Analytics统计的数据： 用户访问量：8125，事件数：9.5万，新用户数：2.1万。 Google Analytics 在线报告：点击此处访问（需墙） ","date":"2019-12-31","objectID":"/debuginn-2019/:2:0","tags":["Debug客栈","2020","2019","年度总结"],"title":"2019 年度总结","uri":"/debuginn-2019/"},{"categories":["coin"],"content":"自己有着收藏纪念币的习惯，在11月21号凌晨成功预约到了央行发行的首枚异型纪念币普币“泰山纪念币”，看官网通知这枚纪念币值发行了1.2亿枚，所以说相对来说具有较高的收藏价值，并且此纪念币有塑料桶包装，对于收藏来说更容易一些。 ","date":"2019-11-30","objectID":"/coin-taishan/:0:0","tags":["coin"],"title":"预约到了泰山异形纪念币","uri":"/coin-taishan/"},{"categories":["coin"],"content":"预约 凌晨定好闹钟，收到短信的时候还是挺激动的，北京地区的是建设银行来进行发行，下面是银行给我发的预约成功短信： 尊敬的客户，您已成功预约20枚世界文化和自然遗产-泰山普通纪念币，预约编号0016866157426**********。请于您约定的日期持尾号****的身份证件至中国建设银行股份有限公司北京昌平支行兑换，兑换截止日为2019年12月01日。 [建设银行]2019年12月20日 建行的纪念币预约兑换服务还是比较友好的，在26日即将开始兑换的时候又收到了建行兑换通知： 尊敬的客户，您所预约的世界文化和自然遗产—泰山普通纪念币于2019年11月28日至2019年12月1日（网点营业时间）办理兑换，请您在此期间持第二代居民身份证原件，前往约定的营业网点办理兑换业务。我行部分网点周六、日休息，请您提前咨询约定网点后再前往办理。您可通过我行电子渠道（官网、手机银行、微信银行、网银）的“预约记录查询”功能查看您的预约网点地址及联系电话。如已兑换，请忽略此短信。 [建设银行] 2019年11月26日 ","date":"2019-11-30","objectID":"/coin-taishan/:1:0","tags":["coin"],"title":"预约到了泰山异形纪念币","uri":"/coin-taishan/"},{"categories":["coin"],"content":"兑换 今天昌平区支行进行兑换，总体来说比较顺利，可能是去的比较晚，竟然没有排队的，顺利兑换完毕，接下来给大家看一下泰山币。 ","date":"2019-11-30","objectID":"/coin-taishan/:2:0","tags":["coin"],"title":"预约到了泰山异形纪念币","uri":"/coin-taishan/"},{"categories":["coin"],"content":"发行 从建国到现在纪念币发行了上百枚，具体可以去维基百科去看建国以来我国发行的纪念币，这个网页还是比较全的，可以看一下。 另外我接收到纪念币发行的消息主要是关注了**微信公众号“纪念币爱好者”**获得第一时间预约消息，感兴趣的同学可以关注一波。 ","date":"2019-11-30","objectID":"/coin-taishan/:3:0","tags":["coin"],"title":"预约到了泰山异形纪念币","uri":"/coin-taishan/"},{"categories":["coin"],"content":"感想 纪念币的发行是用来收藏的，而不是一些商家进行炒作使得原本具有一定价值的物品瞬间翻了几番，去闲鱼看了一下竟然到了400一桶，看来我是赚了? 纪念币收藏不应该沦为另类股票，这也许这就是资本经济吧，使得原本价值1元的鸡蛋，最后100元售出的时候人们竞相购买，最后发现不就是1元一个鸡蛋么。 PS：图片均来自锤子 坚果Pro2 拍摄 ","date":"2019-11-30","objectID":"/coin-taishan/:4:0","tags":["coin"],"title":"预约到了泰山异形纪念币","uri":"/coin-taishan/"},{"categories":["default"],"content":"现在生活中总是会使用到二维码，在支付中、博客的推广图片上、各种各样的商品推广，都有着二维码的身影，二维码已经是我们的日常生活中有着不可替代的便捷信息载体，近几日在网站了解到字节及腾讯根据自己的产品分别推出了抖音码及小程序码的解析流程，心中有一个疑问：“二维码会被使用完么”，在近一周的资料查询及二维码原理分析，我得到的答案是“二维码会被使用完，但我们目前使用不完”，“二维码会被使用完”是因为二维码是采用黑白点阵组成的一段特殊的代码，可以理解为一张特殊的图片，那么这张图片大小比较固定，那么也就代表着二维码会被使用完，而“我们目前使用不完”是因为点阵组成的二维码个数实在是太多了，即使在我们生活中大量应用，每天都有几百亿个二维码产生，还是使用不完。 那么接下来就给大家介绍一下这个二维码是怎么产生及使用的吧。 ","date":"2019-11-20","objectID":"/will-the-qr-code-run-out/:0:0","tags":["qrcode"],"title":"二维码会使用完么","uri":"/will-the-qr-code-run-out/"},{"categories":["default"],"content":"二维码是什么 二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的、黑白相间的、记录数据符号信息的图形；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。 ","date":"2019-11-20","objectID":"/will-the-qr-code-run-out/:1:0","tags":["qrcode"],"title":"二维码会使用完么","uri":"/will-the-qr-code-run-out/"},{"categories":["default"],"content":"二维码的结构 二维码符号分为功能图形及编码区格式，其中功能图形主要作用是辨别及定位二维码的位置，便于扫码操作。而编码区格式存储着定义的格式信息、版本信息及最为重要的数据和纠错码字，他们共同构成了我们常见到的二维码。 校正图形：规格确定，校正图形的数量和位置也就确定了； 格式信息：表示该二维码的纠错级别，分为L、M、Q、H； 版本信息：即二维码的规格，QR码符号共有40种规格的矩阵（一般为黑白色），从21x21（版本1），到177x177（版本40），每一版本符号比前一版本 每边增加4个模块。 数据和纠错码字：实际保存的二维码信息，和纠错码字（用于修正二维码损坏带来的错误）。 通过上面的图片可以想象到，二维码的大小就是那么大，无论采用怎样的编码格式绘制二维码，都会出现有限的组合数量。 ","date":"2019-11-20","objectID":"/will-the-qr-code-run-out/:2:0","tags":["qrcode"],"title":"二维码会使用完么","uri":"/will-the-qr-code-run-out/"},{"categories":["default"],"content":"二维码数量 QR Code的符号版本范围从版本1到版本40。每个版本具有不同的模块配置或模块数量。（模块是指构成QR Code的黑白点。） “模块配置”是指符号中包含的模块数量，从版本1（21×21个模块）到版本40（177×177）模块）。每个更高的版本号每侧包含4个附加模块。 总数量：2^177*177 个。 ","date":"2019-11-20","objectID":"/will-the-qr-code-run-out/:3:0","tags":["qrcode"],"title":"二维码会使用完么","uri":"/will-the-qr-code-run-out/"},{"categories":["default"],"content":"Reference CSDN 二维码（QR code）基本结构及生成原理 Information capacity and versions of QR Code | QRcode.com | DENSO WAVE ","date":"2019-11-20","objectID":"/will-the-qr-code-run-out/:4:0","tags":["qrcode"],"title":"二维码会使用完么","uri":"/will-the-qr-code-run-out/"},{"categories":["mbp"],"content":"购买MacBook Pro已经有了一个多月的时间，在这一段的时间中，首先给MBP给我的第一印象就是“真香”，近乎完美的外表设计搭配自家MacOS，简直就是一款非常有效的生产力工具，2019款增加的Touch Bar就是一个不折不扣的加分项，接下来就听我细细道来吧。 ","date":"2019-11-03","objectID":"/mbp-2019/:0:0","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"✅ 目标 高中时期就对与乔帮主的创新创意所深深吸引，将一台笔记本压缩到一个档案袋一样大小，真的是一件了不起的事情，当时就被Mac电脑的精美，近乎完美的工业设计打动，但是当时迫于高考，再加上对于电脑的需求并没有那么高。高考结束后，自己考上了本省的一所普通二本院校，所学专业是计算机相关的，正是因为所学专业是计算机专业，当时一根脑筋的认为必须高性能的游戏本才能在自己大学四年来进行学习与编程，于是购置了一台Dell游匣7559款游戏本。 大学期间，这台笔记本是真的够用，但也真的沉，太沉以至于在大学期间他没有几次走出我的大学实验室。另外就是windows系统是真的很崩溃，我人被它搞崩溃，系统也是跟给力，蓝屏问题一直都是一个不定时的炸弹，真的很苦恼，曾经有一段时间给游匣安装了黑苹果，最后迫于黑苹果网卡及各种驱动问题最后又改装了Windows系统，那时，自己的小目标就是实习期间一定要换一台属于自己的MacBook，接下来就有了现在的入手体验。 ","date":"2019-11-03","objectID":"/mbp-2019/:1:0","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"✅ 开箱 苹果的包装一直都是比较讲究的，环保包装，简洁的只有三件（包装三包+MacBook+电源）。 比较灵巧的设计，将两侧“耳朵”竖起，就自动将内包装抬起，挺巧妙的设计。 拿出来之后，打开内侧包装，开始撕膜…… 由于本人撕膜之后过于兴奋，系统设置这一块忘记拍摄了，脑补喜悦的画面吧，接下来给大家介绍一下电脑的性能及系统配置吧。 ","date":"2019-11-03","objectID":"/mbp-2019/:2:0","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"✅ 配置 近期升级到了Catalina版本，看着增加了应用使用时间及iPad扩展功能，挺不错的，接下来看看配置吧。 CPU 2.4GHz 四核 Intel Core i5 处理器 (Turbo Boost 最高可达 4.1GHz)，配备 128MB eDRAM 内存 8GB 2133 MHz LPDDR3 显卡 Intel lris Plus Graphics 645 1536 MB 显示器 13.3英寸（2560 * 1600） 固态硬盘 256GB 固态硬盘 拓展 两个雷雳 3 (USB-C) 端口，USB 3.1 第二代 (速率最高可达 10Gb/s) 全尺寸背光键盘 64 个 (ANSI) 或 65 个 (ISO) 按键 Wi-Fi 网络 802.11ac Wi-Fi 无线网络 兼容 IEEE 802.11a/b/g/n 蓝牙 蓝牙 5.0 无线技术 摄像头 720p FaceTime 高清摄像头 其他 官网详细介绍 ","date":"2019-11-03","objectID":"/mbp-2019/:3:0","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"✅ 系统 ","date":"2019-11-03","objectID":"/mbp-2019/:4:0","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"全屏幕窗口方式 由于苹果本身尺寸比较小，全屏幕的设计搭配触控板可以轻松实现对窗口的扩展，由于是从windows深度用户，开始不太习惯，不过用了两天就被它这功能所深深的吸引，真的特别便捷实用，给人以最大化工作界面的状态。 这种用户界面将极大简化电脑的使用，减少多个窗口带来的困扰。它将使用户获得与iPhone、iPod touch和iPad用户相同的体验。计算体验并不会因此被削弱；相反，苹果正帮助用户更为有效地处理任务。 百度百科 Mac OS ","date":"2019-11-03","objectID":"/mbp-2019/:4:1","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"类Linux系统 这个无疑是我作为开发者实用Mac的神器，在日常工作使用中，对终端的操作，连接远程linux系统，系统本身安装环境都显得那么顺畅，这个是在windows原始Dos系统上不能体会到的，上手后你就了解了。 ","date":"2019-11-03","objectID":"/mbp-2019/:4:2","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"Touch Bar 不得不说，带把的 带bar 的就是好用，如果说键盘拯救了我们输入系统，那bar就拯救了我们手动的选择。 ","date":"2019-11-03","objectID":"/mbp-2019/:4:3","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"无广告干扰 Mac系统软件开发本身就约束开发软件对广告的植入，不过VIP、SVIP，库克也无法拯救大家，目前使用了一个多月，几乎没有广告，用着非常省心。 ","date":"2019-11-03","objectID":"/mbp-2019/:4:4","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"QQ良心版 提到了QQ，简直就是开发者对Mac用户的优惠，红包提醒简直堪比外挂，都说抢红包抢的块，想想那些得到红包的是不是Mac用户？ ","date":"2019-11-03","objectID":"/mbp-2019/:4:5","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"✅ 总结 Mac本虽然优点特别的多，但是由于本身电脑价格昂贵至今博主还在还白条中，不过苹果对于学生有学生教育优惠政策，原本人民币11499的价格便宜到10700，同时还免费赠送了一台Beats Studio3 Wireless 头戴式耳机，要是不满意这个耳机可以咸鱼出售，之后这台笔记本整体可以10k以内购买下来，即使如此对于学生党来说还是比较昂贵的，这也是我为什么实习更换笔记本的一大原因，在使用了一个多月的时间里，这台电脑优缺点兼备，之所以换电脑还是优点大于缺点的： ","date":"2019-11-03","objectID":"/mbp-2019/:5:0","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"优点 轻薄便携，出门或者随身携带重量可以接受； MacOS 使用过的电脑系统中最人性化设计的系统，没有之一； 视网膜屏幕，对使用者十分友好； Touch Bar选择多样，真的很好用； 电池?充满电之后可以重度使用6小时左右； 类Unix设计，命令行上来就用； 无广告干扰，使用很舒适； 薄而坚固的机身，干净的外观设计。 ","date":"2019-11-03","objectID":"/mbp-2019/:5:1","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["mbp"],"content":"缺点 价格贵，即使使用了教育优惠，还是贵； 第三代蝶式键盘，感觉没有键程，就像怼木头一样，使用过机械键盘的感觉明显； 没有有线网口，只有两个闪电口，Wifi够用； 配件贵，这个时代只要是和苹果沾边的都不便宜，除了? 整体来说，苹果本真是一个革命性质的笔记本，用起来的用户交互真的很人性化，要是想购买，最好是在实习入手，享受教育优惠的同时，自己又可以支付较为昂贵的价格，推荐大家为此买单，但是要理性消费哦。 PS：图片均来自锤子 坚果Pro2 拍摄 ","date":"2019-11-03","objectID":"/mbp-2019/:5:2","tags":["mbp"],"title":"MacBook Pro 2019款 入手体验","uri":"/mbp-2019/"},{"categories":["default"],"content":"是不是经常在群中看到大神闲的无聊敲的代码构图，今天，他来了，搜集了网上尽可能多的代码构图，展示给大家，友情提示，推荐使用比较大的屏幕查看，效果会比较好的。 ","date":"2019-10-18","objectID":"/code-picture/:0:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.1 佛祖保佑，永无Bug _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ .' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '\u003c `.___\\_\u003c|\u003e_/___.' \u003e'\"\". | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / ======`-.____`-.___\\_____/___.-`____.-'====== `=---=' ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG ","date":"2019-10-18","objectID":"/code-picture/:1:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.2 草泥马 ┌─┐ ┌─┐ ┌──┘ ┴───────┘ ┴──┐ │ │ │ ─── │ │ ─┬┘ └┬─ │ │ │ │ ─┴─ │ │ │ └───┐ ┌───┘ │ │ │ │ │ │ │ └──────────────┐ │ │ │ ├─┐ │ ┌─┘ │ │ └─┐ ┐ ┌───────┬──┐ ┌──┘ │ ─┤ ─┤ │ ─┤ ─┤ └──┴──┘ └──┴──┘ 神兽保佑 代码无BUG! ","date":"2019-10-18","objectID":"/code-picture/:2:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.3 知识就是力量 .-~~~~~~~~~-._ _.-~~~~~~~~~-. __.' ~. .~ `.__ .'// \\./ \\\\`. .'// | \\\\`. .'// .-~\"\"\"\"\"\"\"~~~~-._ | _,-~~~~\"\"\"\"\"\"\"~-. \\\\`. .'//.-\" `-. | .-' \"-.\\\\`. .'//______.============-.. \\ | / ..-============.______\\\\`. .'______________________________\\|/______________________________`. ","date":"2019-10-18","objectID":"/code-picture/:3:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.4 史蒂文西蒙斯 _.---..._ ./^ ^-._ ./^C===. ^\\. /\\ .|' \\\\ _ ^|.^.| ___.--'_ ( ) . ./ /|| /.---^T\\ , | / /||| C' ._`| ._ / __,-/ / /-,|| \\ \\/ ; /O / _ |) )|, i \\./^O\\./_,-^/^ ,;-^,' \\ |`--/ ..-^^ |_-^ `| \\^- /|: i. .-- / '|. i ==' /' |\\._ _./`._ // |. ^-ooo.._ _.oo../' | ^-.__./X/ . `| |#######b d#### |' ^^^^ / | _\\####### #####b ^^^^^^^^--. ...--^--^^^^^^^_.d###### ######b._ Y _.d######### ##########b._ | _.d############# \"Piccolo\" no. 2 (from Dragonball Z) --- Steven J. Simmons ","date":"2019-10-18","objectID":"/code-picture/:4:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.5 这样很忍者 _ \\\"-._ _.--\"~~\"--._ \\ \" ^. ___ / \\.-~_.-~ .-----' /\\/\"\\ /~-._ / / __ _/\\-.__\\L_.-/\\ \"-. /.-\" \\ ( ` \\_o\u003e\"\u003co_/ \\ .--._\\ /' \\ \\: \" :/_/ \"` / /\\ \"\\ ~ /~\" \\ I \\/]\"-._ _.-\"[ ___ \\|___/ ./ l \\___ ___ .--v~ \"v` ( `-.__ __.-' ) ~v\" ~v--. .-{ | : \\_ \"~\" _/ : | }-. / \\ | ~-.,___,.-~ | / \\ ] \\ | | / [ /\\ \\| : : |/ /\\ / ^._ _K.___,^ ^.___,K_ _.^ \\ / / \"~/ \"\\ /\" \\~\" \\ \\ / / / \\ _ : _ / \\ \\ \\ .^--./ / Y___________l___________Y \\ \\.--^. [ \\ / | [/ ] | \\ / ] | \"v\" l________[____/]________j -Row }r\" / }------t / \\ /`-. / | | Y Y / \"-._/ }-----v' | : | 7-. / | |_| | l | / . \"-._/ l .[_] : \\ : r[]/_. / \\_____] \"--. \"-.____/ \"Dragonball Z\" ---Row ","date":"2019-10-18","objectID":"/code-picture/:5:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.6 皮卡丘皮卡丘 quu..__ $$$b `---.__ \"$$b `--. ___.---uuudP `$$b `.__.------.__ __.---' $$$$\" . \"$b -' `-.-' $$$\" .'| \". d$\" _.' | `. / ...\" .' | `./ ..::-' _.' | / .:::-' .-' .' : ::''\\ _.' | .' .-. .-. `. .' | : /'$$| .@\"$\\ `. .' _.-' .'|$u$$| |$$,$$| | \u003c _.-' | `:$$:' :$$$$$: `. `. .-' : `\"--' | `-. \\ :##. == .###. `. `. `\\ |##: :###: | \u003e \u003e |#' `..'`..' `###' x: / / \\ xXX| / ./ \\ xXXX'| / ./ /`-. `. / / : `- ..........., | / .' | ``:::::::' . |\u003c `. | ``` | x| \\ `.:``. | .' /' xXX| `:`M`M':. | | ; /:' xXXX'| -'MMMMM:' `. .' : /:' |-'MMMM.-' | | .' /' .'MMM.-' `'`' : ,' |MMM\u003c | `' |tbap\\ \\ :MM.-' \\ | .'' \\. `. / / .:::::::.. : / | .:::::::::::`. / | .:::------------\\ / / .'' \u003e::' / `',: : .' `:.:' ","date":"2019-10-18","objectID":"/code-picture/:5:1","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.7 A computer ,----------------, ,---------, ,-----------------------, ,\" ,\"| ,\" ,\"| ,\" ,\" | +-----------------------+ | ,\" ,\" | | .-----------------. | | +---------+ | | | | | | | -==----'| | | | I LOVE DOS! | | | | | | | | Bad command or | | |/----|`---= | | | | C:\\\u003e_ | | | ,/|==== ooo | ; | | | | | // |(((( [33]| ,\" | `-----------------' |,\" .;'| |(((( | ,\" +-----------------------+ ;; | | |,\" /_)______________(_/ //' | +---------+ ___________________________/___ `, / oooooooooooooooo .o. oooo /, \\,\"----------- / ==ooooooooooooooo==.o. ooo= // ,`\\--{)B ,\" /_==__==========__==_ooo__ooo=_/' /___________,\" ","date":"2019-10-18","objectID":"/code-picture/:6:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.8 翼龙 __----~~~~~~~~~~~------___ . . ~~//====...... __--~ ~~ -. \\_|// |||\\\\ ~~~~~~::::... /~ ___-==_ _-~o~ \\/ ||| \\\\ _/~~- __---~~~.==~||\\=_ -_--~/_-~|- |\\\\ \\\\ _/~ _-~~ .=~ | \\\\-_ '-~7 /- / || \\ / .~ .~ | \\\\ -_ / /- / || \\ / / ____ / | \\\\ ~-_/ /|- _/ .|| \\ / |~~ ~~|--~~~~--_ \\ ~==-/ | \\~--===~~ .\\ ' ~-| /| |-~\\~~ __--~~ |-~~-_/ | | ~\\_ _-~ /\\ / \\ \\__ \\/~ \\__ _--~ _/ | .-~~____--~-/ ~~==. ((-\u003e/~ '.|||' -_| ~~-/ , . _|| -_ ~\\ ~~---l__i__i__i--~~_/ _-~-__ ~) \\--______________--~~ //.-~~~-~_--~- |-------~~~~~~~~ //.-~~~--\\ ","date":"2019-10-18","objectID":"/code-picture/:7:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.9 不知道像啥 ) ( /+++=)) ((=+++\\ /++++++++// \\\\+++++++++\\ /++++++++++//( /\\ )\\\\++++++++++\\ /+++++++++++// \\\\^^// \\\\+++++++++++\\ _/++++++++++++// {{@::@}} \\\\++++++++++++\\_ /+++++++++++++(( {\\/} ))+++++++++++++\\ /+++++++++++++++\\\\ \u003c**\u003e //+++++++++++++++\\ /+++++++++++++++++\\\\ / VV \\ //+++++++++++++++++\\ /+++++++++++++++++++\\\\/******\\//+++++++++++++++++++\\ |+/|++++++++++/\\++++++(***/\\***)++++++/\\++++++++++|\\+\\ |/ |+/\\+/\\+/\\/ \\+/\\++\\**|**|**/++/\\+/ \\/\\+/\\+/\\+| \\| v |/ V V V V \\+\\|*|**|*|/+/ V v V V \\| v v /*|*|**|*|*\\... v (**|*|**|*|**). . __\\*|*|**|*|*/__. . (vvv(VVV)(VVV)vvv). . ............../ / / ............../ (( ","date":"2019-10-18","objectID":"/code-picture/:8:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.10 性感的 girl .::::. .::::::::. ::::::::::: ..:::::::::::' '::::::::::::' .:::::::::: '::::::::::::::.. ..::::::::::::. ``:::::::::::::::: ::::``:::::::::' .:::. ::::' ':::::' .::::::::. .::::' :::: .:::::::'::::. .:::' ::::: .:::::::::' ':::::. .::' :::::.:::::::::' ':::::. .::' ::::::::::::::' ``::::. ...::: ::::::::::::' ``::. ```` ':. ':::::::::' ::::.. '.:::::' ':'````.. ","date":"2019-10-18","objectID":"/code-picture/:9:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["default"],"content":"No.11 最后一张龙珠 MMMMM MMMMMM MMMMMMM MMMMMMMM . MMMMMMMMM HMMMMMMMMMM MMMMMMMMMMMM M MMMMMMMMMMMMM M MMMMMMMMMMMMM M MMMMMMMMMMMMM: oMMMMMMMMMMMMMM .MMMMMMMMMMMMMMo MMMMMMMMMMMMMMM M MMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMM. oMMMMMMMMMMMMMMM.M MMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM oMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM: H MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM . MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMM .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMMMMMM MM. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .MMMMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .MMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM HMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMM MMM.oMMMMMMM..MMMMMMMMM:MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMM MM..MMMMMMM...MMMMMMM. MMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMM ..MMMMMM...MMMMMM ..MMMMMMMMMMMMMMMMMMM MMMMMMM:M.MMM.M.. MMMMM M..MMMMM...MMMMMMMMMMMMMMMMMM MMM MMMM. .M..MM.M...MMMMMM..MMMMM.. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM . MMMM..M....M.....:MMM .MMMMMM..MMMMMMM...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMM.M.. ...M......MM.MMMMM.......MHM.M .MMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMM..MM. . MMM.....MMMMMM.M.....M ..MM..M MMMMMMMMMMMMMMMMMMM .MMMMMHMM. ..MMMM. MMM............o..... . .MMMMMMMMMMMMMMM MMM. M... .........................M..:.MMMMMMMMMMMM oMMM............ .................M.M.MMMMMMMMM .....MM........................ . MMMMMM M.....M.....................o.MM.MMMMMMMM. M........................M.. ...MMMMMMMMMMMMMo :....MMM..............MMM..oMMMMMMM M...MMM.............MMMMMMM .............:MMMMMMMM M..... MMM.....M M M............. ................M ooM.................MM MoMMMMMoooM MMoooM......................MoooooooH..oMM MHooooMoM.....................MMooooooM........M oooooooMoooM......... o........MoooooooM............ Mooooooooooo.......M.........Moooooooo:..............M MooMoooooooooM...M........:Mooooooooooo:..............M M..oooooooooooo .........Mooooooooooooooo..............M M...Mooo:oooooooo.M....ooooooooooooooooooo..M...........M ...oooooMoooooooM..Mooooooooooooo:oooooooM.M...........M. M...ooooooMoo:ooooMoooooooooooooHoooooooooH:M. ...........: M..MoooooooMoooooooooooooooooo:ooooooMooooMoM..............M M..ooooooooooMooooooooooooooHoooooooMooHooooM...............M ...ooooooooooooooooooo:MooooooooooooooMoMoooM................ M...oooooooooooooooooooooooooooooooooooooMooMM................M ...MooooooooooooooooooooooooooooooooooooooooMo ................ ...MooooooooooooooooooooooooooooooooooooooooM M................M M...ooooooooooooooooooooooooooooooooooooooooM ................M ...MoooooooooooooooooooooooooooooooooooooooMM .:............... .....MooooooooooooooooooooooooooooooooooooMoo .............M M...... ooooooooooooooooooooooooooooooooooooM M..............M M........MooooMMM MM MM MMMMMMMMMooooooooM M...............M .........HM M: MM :MMMMMM M M............... M..........M M MoM M M................M M.........:M MoH M M M MooooHoooMM. M M...............M M..........Moooo MMooM oooooMooooooooM M..............H M.........MooooM Mooo : ooooooMooooMoooM M........ . .o.M H.. .....ooooo oooo M MooooooooooooooM M... MMMMMMMMMMM MMMMMMMMMMooooM M oooo . ooooooMooooooooM .MMMMMMMMMMMMMMM MMMMMMMMMMooooH : ooooH oooooooooooooooo MMMMMMMMMMMMMMM MMMMMMMMMMoooo ooooM Moooooooooooooooo .MMMMMMMMMMMMMMM MMMMMMMMMMoooo ooooM MooooooooooooooooM MMMMMMMMMMMMMMM MMMMMMMMMMoooM ooooM ooooooooooooooooo MMMMMMMMMMM:M MMMMMMMMMMoooM MooooM oooooooooooMoooooo MH........... . ......Mooo. MooooM oooooooooooooooooo M............M M.M......oooo MooooM Moooooooooooooooooo: .","date":"2019-10-18","objectID":"/code-picture/:10:0","tags":["default"],"title":"一些好玩的代码构图","uri":"/code-picture/"},{"categories":["http"],"content":"当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 ","date":"2019-09-26","objectID":"/http-status-code/:0:0","tags":["http status code"],"title":"HTTP常见状态码","uri":"/http-status-code/"},{"categories":["http"],"content":"1开头 1XX 1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 ","date":"2019-09-26","objectID":"/http-status-code/:1:0","tags":["http status code"],"title":"HTTP常见状态码","uri":"/http-status-code/"},{"categories":["http"],"content":"2开头 2XX 2xx (成功)表示成功处理了请求的状态代码。 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 (已创建) 请求成功并且服务器创建了新的资源。 202 (已接受) 服务器已接受请求，但尚未处理。 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。 206 (部分内容) 服务器成功处理了部分 GET 请求。 ","date":"2019-09-26","objectID":"/http-status-code/:2:0","tags":["http status code"],"title":"HTTP常见状态码","uri":"/http-status-code/"},{"categories":["http"],"content":"3开头 3XX 3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 ","date":"2019-09-26","objectID":"/http-status-code/:3:0","tags":["http status code"],"title":"HTTP常见状态码","uri":"/http-status-code/"},{"categories":["http"],"content":"4开头 4XX 4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 (错误请求) 服务器不理解请求的语法。 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 (禁止) 服务器拒绝请求。 404 (未找到) 服务器找不到请求的网页。 405 (方法禁用) 禁用请求中指定的方法。 406 (不接受) 无法使用请求的内容特性响应请求的网页。 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。 408 (请求超时) 服务器等候请求时发生超时。 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 (未满足期望值) 服务器未满足\"期望\"请求标头字段的要求。 ","date":"2019-09-26","objectID":"/http-status-code/:4:0","tags":["http status code"],"title":"HTTP常见状态码","uri":"/http-status-code/"},{"categories":["http"],"content":"5开头 5XX 5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。 ","date":"2019-09-26","objectID":"/http-status-code/:5:0","tags":["http status code"],"title":"HTTP常见状态码","uri":"/http-status-code/"},{"categories":["5g"],"content":"今天又一次看了何同学的5G的视频，从视频上看了关于何同学讲联通试运行的是NSA架构，SA架构还在研发试运行中，我就纳闷了，作为一个计算机行业的学生，怎么不明白这个架构名词，是自己out了么，后来上网找了资料，原来这个是通讯技术的专业名词，今天算是恶补了一下。 2018年12月份的时候，我们其实已经发布了“半个”5G标准。是的没错，那个时候是“非独立组网(NSA)”的5G标准。 现在在等待SA组网标准。 ","date":"2019-08-17","objectID":"/about-5g-sa-nsa/:0:0","tags":["5g","sa","nsa"],"title":"关于5G的SA与NSA架构","uri":"/about-5g-sa-nsa/"},{"categories":["5g"],"content":"举个栗子 为了大家能够通俗易懂的描述这5G的两个架构，给大家举个栗子： 话说这个张老板，家里养着一头肥朵1， 肥朵1 的小日子过得也很不错！ 但是突然有一天 肥朵 的价钱大涨，张老板想再养一只 肥朵，可是由于资金不足，（理想状态是一头 肥朵 需要有一个单独的房间）张老板很是苦恼，于是张老板给想出了两套方案： 方案一：养 肥朵2 的时候，给 肥朵2 在建一个房子； 方案二：把 肥朵1 和 肥朵2 养在一起，只需将房子变大一点就可以了。 方案一按照理想状态的话，有一个比较大的缺点就是花费比较多，这就比较难受了……，但是 肥朵 比较开心~~~~ 方案二是将房子重新升级变大即可作为资金花费最少，同时能够获得最大效益，张老板选择的面比较大，可就难受了 肥朵，唉，万恶的资本家。 想必大家就已经知道制约SA和NSA的因素了吧！就是money~~~ 而 肥朵1 我们就可以看作是 4G基站 ，而把 肥朵2 看作是 5G基站； 按照方案一 肥朵1 的房子 可以看作是 4G核心网络； 按照方案一 肥朵2 的房子 可以看作是 5G核心网络； 按照方案二的话是将 肥朵1 和肥朵2的房子 看作是4G核心网络，而 肥朵1 也是 4G基站，肥朵2 也是5G基站，请看下图 ： 简而言之，之所以有SA与NSA架构主要是因为运营商愿意不愿意出钱重新部署。 ","date":"2019-08-17","objectID":"/about-5g-sa-nsa/:1:0","tags":["5g","sa","nsa"],"title":"关于5G的SA与NSA架构","uri":"/about-5g-sa-nsa/"},{"categories":["5g"],"content":"5G网络架构 目前讲到的都是 5G网络架构 中的两种，其实还有以下多种选项： 这8个选项分为独立组网和非独立组网两组。其中选项1，2，5，6是独立组网，选项3，4，7，8是非独立组网。非独立组网的选项3，4，7还有不同的子选项。 在这些选项中，选项1早已在4G结构中实现，选项6和选项8仅是理论存在的部署场景，不具有实际部署价值，标准中不予考虑。 ","date":"2019-08-17","objectID":"/about-5g-sa-nsa/:2:0","tags":["5g","sa","nsa"],"title":"关于5G的SA与NSA架构","uri":"/about-5g-sa-nsa/"},{"categories":["5g"],"content":"独立组网SA 选项1：就是单纯的4G核心网+4G核心站，就是纯4G组网架构； 选项2：可以看得出来，就是我们上面例子的方案一，纯5G组网架构； 选项5：只是对原本4G基站做了升级，变为增强型4G基站【eLTE eNB】； 选项6：就是将原本4G基站换为5G基站，然而核心网还是4G。 ","date":"2019-08-17","objectID":"/about-5g-sa-nsa/:2:1","tags":["5g","sa","nsa"],"title":"关于5G的SA与NSA架构","uri":"/about-5g-sa-nsa/"},{"categories":["5g"],"content":"非独立组网NSA 个人感觉NSA还是要比SA复杂一些，但是这样是比较省钱的一种方式，在节省资金的情况下，不影响用户5G体验，相信这也是当下某某运营商的升级过渡期的优先解决方案。 在非独立组网主要是分为3系、7系、和4系，但是单纯的说你是不会明白的，通信的例外，好吧，你就是不会明白?，请看下面的介绍： NSA3系 可以看到3系的解决方案就是将原有4G网络升级加5G基站，让手机实现“双通道上网”，但是控制面在4G，用户面4G与5G互相向用户终端提供支持，这样的好处就是可以在5G升级过度时期起到临时代替作用，但是这样会加大4G基站的负荷，本来好好的够1头肥朵居住，突然之间加到了10头肥朵，想想也是有些吃不消的。 NSA7系 看到了7系你是不是有了对3系的对比，相比而言，7系有三点改进： 将3系4G基站升级为增强型4G基站； 将原有4G核心网淘汰掉，采用5G核心网； 最后一点改进是7x中，将原有4G基站对接5G核心网络升级为增强型4G基站只传输控制流，将数据流负荷直接转移到了5G基站上。 现在这种方式，特别是7x，对于运营商在初中期过度时期，这种方式又节省成本，同时又能在过渡期给用户提供高质量5G服务，相信现在XX运营商就这么搞的吧。 NSA4系 可以看到，到达4系阶段，把控制权交了出来，5G就距离SA架构只差一步了吧，这种状态应该是目前转型阶段后期的事情了吧！这样的架构方式同时能享受到4G的低费率，5G的高速率，你是不是有所期待！！！ ","date":"2019-08-17","objectID":"/about-5g-sa-nsa/:2:2","tags":["5g","sa","nsa"],"title":"关于5G的SA与NSA架构","uri":"/about-5g-sa-nsa/"},{"categories":["5g"],"content":"最后感悟 5G时代所谓的NSA与SA架构只不过是4G时代向5G时代过渡的不同方案，所谓的NSA又何尝不是对于SA的追求，5G时代大家的感觉是速度真快，然而在快的同时我们又怎么抓住机遇，获得5G时代的红利呢？ 今天做这个文章借鉴了不少前辈的文章及视频知识，并不是想借鉴5G这个热点，自己涉猎的知识面还是狭隘，所学所思才是真正的进步。 PS：举个栗子是我自己P图?，最后讲解方案的用图均引用至51CTO，看着画的不错自己就偷个懒，不自己构图了，感谢这个知识共享的年代，谢谢。 看到这里，你要是感觉此文对你有所帮助，希望你转发给更多的人看到，5G时代的我们，更应该知识共享。。。 ","date":"2019-08-17","objectID":"/about-5g-sa-nsa/:3:0","tags":["5g","sa","nsa"],"title":"关于5G的SA与NSA架构","uri":"/about-5g-sa-nsa/"},{"categories":["软件工程"],"content":"一、选择题 1、 下列关于使用用例的目的，正确的是（ B ）。 A．确定系统应具备哪些功能 B．为系统的功能提供清晰一致的描述，方便开发人员传递系统的需求 C．为系统验证工作打下基础 D．减少程序员的编码工作量，提高开发效率 2、 识别用例的最好方法是从哪里入手（ B ） A．系统边界 B．参与者 C．事件 D．用例 3、 参与者（Actor）与用例之间的关系是（ C ） （A）包含关系 （B）泛化关系 （C）关联关系 （D）扩展关系 4、 用户在银行员工的指导下，使用 ATM 机，查阅银行帐务系统的个人帐务数据，并打印其 个人用户账单。在上述过程中，对 ATM 机管理系统而言，哪个不是系统的参与者( B )。 A．用户 B．银行员工 C．打印系统 D．帐务系统 5、 用例从用户角度描述系统的行为。用例之间可以存在一定的关系。假设在“图书馆管理系 统”用例模型中，所有用户使用系统之前必须通过“身份验证”，“身份验证”可以有“密码 验证”和“智能卡验证”两种方式，则“身份验证”与“密码验证”和“智能卡验证”之间 是（ B ）关系。 A．关联 B．包含 C．扩展 D．泛化 6、 用例用来描述系统在事件做出响应所采取的行动。用例之间是具有相关性的。在一个“订单输入子系统”中，创建新订单和更新订单都需要检查用户账号是否正确。那么，用例“创建新订单”、“更新订单”与用例“检查用户账号”之间是（ A ）关系。 A．包含(include) B．扩展(extend) C．分类(classification) D．聚集(aggregation) 7、 如果用例 A 与用例 B 相似，但 A 的功能较 B 多，A 的动作序列是通过在 B 的动作序列中 的某些执行点上插入附加的动作序列而构成的，则称（ C ）。 A．用例 A 扩展用例 B B．用例 A 包含用例 B C．用例 A 泛化用例 B D．用例 A 实现用例 B 8、 如果用例 A 与用例 B 相似，但 A 的动作序列是通过改写 B 的部分或者扩展 B 的动作而获 得的，则称（ B ） A．用例 A 实现用例 B B．用例 A 泛化用例 B C．用例 A 扩展用例 B D．用例 A 包括用例 B 9、 如果用例 B 是用例 A 的某项子功能，并且建模者确切地知道在 A 所对应的动作序列中何 时将调用 B，则称（ C ） A．用例 A 扩展用例 B B．用例 A 泛化用例 B C．用例 A 包含用例 B D．用例 A 实现用例 B ","date":"2019-07-04","objectID":"/test-software-use-case/:1:0","tags":["软件工程"],"title":"软件工程 用例习题","uri":"/test-software-use-case/"},{"categories":["软件工程"],"content":"二、简答题 对于一个电子商务网站而言，以下哪些不是合适的用例，指出并说明理由。 输入支付信息 将商品放入购物车 结账 预订商品 用户登录 邮寄商品 查看商品详情 输入支付信息：太小 邮件商品：系统功能之外 查看商品详情：太小 ","date":"2019-07-04","objectID":"/test-software-use-case/:2:0","tags":["软件工程"],"title":"软件工程 用例习题","uri":"/test-software-use-case/"},{"categories":["软件工程"],"content":"三、分析题 1、 某电话公司决定开发一个管理所有客户信息的交互式网络系统。系统功能如下： 浏览客户信息：任何使用 Internet 的网络用户都可以浏览电话公司所有的客户信息（包括 姓名、住址、电话号码等）。 登录：电话公司授予每个客户一个账号。拥有授权账号的客户，可以使用系统提供的页 面设置个人密码，并使用该账号和密码向系统注册。 修改个人信息：客户向系统注册后，可以发送电子邮件或者使用系统提供的页面，对个 人信息进行修改。 删除客户信息：只有公司的管理人员才可以删除不再接受公司服务的客户的信息。 请绘制出相应的用例图 2、 档案管理系统功能性需求说明如下： 用户进入系统前，首先要求用户进行登录，验证通过后允许用户进入本系统操作。用户 的密码需要进行加密算法。 用户登录后可以修改自己的注册信息，包括修改用户密码、每页显示行数等信息，不允 许修改用户名、姓名和部门等信息。 系统管理员可以增加系统用户、删除系统用户、修改用户的相关属性、修改用户的权限 表。 档案室人员可以对档案文件信息或者档案案卷信息进行管理，删除时只是做删除标记。 档案借阅管理人员处理外借登记、归还记录和电子借阅申请两部分。外借模块实现档案 文件的借出登记和归还登记功能。一般用户提出借阅电子文档的请求后，被同意阅读后，文 件将被发送给申请人。 本系统需要实现数据的备份和恢复机制。数据备份操作可以按年度、档案种类等条件做 部分备份或完全备份。数据恢复就是将备份的数据恢复到数据库中。具有批量备份和恢复的 功能。 ","date":"2019-07-04","objectID":"/test-software-use-case/:3:0","tags":["软件工程"],"title":"软件工程 用例习题","uri":"/test-software-use-case/"},{"categories":["软件工程"],"content":"活动图绘图有开始结尾的标志，简称黑点开始、牛眼结束。 1、请应用活动图描述同学们每次参加考试的过程是怎么样的？ 开始。 学生进入考场。 监考教师核对检查证件，发放试卷。 学生对号入座。 学生开始答题。 学生交卷。 监考教师收取试卷。 结束。 2、 小张想去吃饭，如果必胜客有空位或最多只等待 15 分钟，则进必胜客吃饭，否则去肯德鸡吃 饭。请画出相应的活动图。 3、开工奠基流程如下： 如果资金到位，则准备施工现场。当领导也到场时，开工奠基开始 请画出相应的活动图 4、对于“远程网络教学系统”，学生登录后可以下载课件。在登录时，系统需要验证用户的登录 信息，如果验证通过系统会显示所有可选服务。如果验证失败，则登录失败。当用户看到系统显示的 所有可选服务后，可以选择下载服务，然后下载需要的课件。下载完成后用户退出系统，系统则会注 销相应的用户信息。画出学生下载课件的活动图。 5、在“远程网络教学系统”中，系统管理员登录后可以处理注册申请或者审核课件。在处理注册 申请后，需要发送邮件通知用户处理结果；在审核完课件后，需要更新页面信息以保证用户能看到最 新的课件，同时系统更新页面。当完成这些工作后，系统管理员退出系统，系统则注销系统管理员账号。画出系统管理员的工作活动图。 6、根据以下叙述，绘制打印社的“打印机”的状态图： 未接到工作命令时，打印机处于闲置状态。接到打印命令后，转入打印状态，完成打印后又回到 闲置状态，等待命令。 若打印时发现没纸，则进入缺纸状态。发出警告等待装纸。装纸完成后又进入闲置状态。 若打印时发现卡纸，则进入卡纸（故障）状态。发出警告等待排除故障。故障排除后又进入闲置 状态。 7、手机开机时，处于空闲状态；当用户开始呼叫某人时，手机进入拨号状态；如果呼叫成功， 进入通话状态；如果呼叫不成功，重新进入空闲状态。在空闲状态被呼叫，进入响铃状态；如果用户 接听，进入通话状态；如果一分钟不接听，重新进入空闲状态。请绘制手机的状态图。 8、用顺序图描述一位学生张三在 ATM 系统上取 100RMB 的“取款”流程，其过程要包括如下 需求。 ➢ 学生张三取款时向 ATM 系统插入银行卡。 ➢ ATM 系统的读卡机读取卡号信息。 ➢ 屏幕显示用户的操作界面。 ➢ 屏幕提示用户输入密码。 ➢ 用户根据提示输入密码。 ➢ 系统检测用户的密码是否有效。 ➢ 屏幕提示选择事务的操作，如查询、存款、取款等。 ➢ 张三选择取款事务。 ➢ 屏幕提示输入取款金额。 ➢ 张三根据提示输入 100RMB。 ➢ 系统准备向张三的账号执行取钱的操作。 ➢ 系统检测张三的余额是否大于等于 100RMB。 ➢ 系统从张三的账户上扣除 100RMB。 ➢ 吐钱机将 100RMB 吐出给学生。 ➢ 系统打印取款凭据。 ➢ 系统退卡。 ","date":"2019-07-04","objectID":"/test-software-figure/:0:0","tags":["软件工程"],"title":"软件工程 活动图、状态图、顺序图实验题","uri":"/test-software-figure/"},{"categories":["软件工程"],"content":"1、软件部署是（ B ） A：部署软件构件 B：部署软件程序 C：部署软件模型 D：部署软件制品 2、下面说法正确的是（ C ） A：制品就是制成品 B：制品是软件模块 C：制品是被部署的软件单元 D：制品是软件构件 3、下列说法不正确的是（ B ）。 A）在用例视图下可以创建类图 B）在逻辑视图下可以创建组件图 C）在逻辑视图下可以创建包 D）在构建试图下可以创建构件 4、在组件图中，（ D ）用于显示构件之间的关联关系。 A）依赖关系 B）构件 C）包 D）节点 5、 下面哪个符号代表部署图的节点（ C ） 6、下列不属于部署图中的设备类型的是：（ B ）。 A）打印机 B）计算机 C）扫描仪 D）路由器 7、在绘制部署图时，如果要描述处理器之间或处理器与设备之间通过以太网进行连接的关系时，使用下列哪一种构造型（ A ）。 A）《Ethernet》 B）《parallel》 C）《TCP/IP》 D）《Internet》 8、在UML中，____B_____图显示了一组类、接口、协作以及它们之间的关系。 A、状态图 B、类图 C、用例图 D、部署图 9、节点是存在于运行时并代表一项计算资源的物理元素，没有计算能力的节点称为___B____ A．处理器 B．规范 C．接口 D．设备 10、下图中，表示“节点”的图为_____C_______。 11、_____B_____图可以用来描述系统硬件的物理拓扑结构以及在此结构上运行的软件。 A、用例图 B、类图 C、部署图 D、活动图 12、____D_____是系统中遵从一组接口且提供实现的一个物理部件，通常指开发和运行时类的物理实现。 A、部署图 B、类 C、接口 D、构件 13、下列不属性构件的特征的是______A________。 A、可替换 B、通过接口实现或提供服务 C、可以被一个或多个实现 D、只能是代码的形式 14、对于比如源代码文件及数据文件，并不是直接地参与可执行系统，我们称这类构件为____C_____。 A、实施构件 B、工作产品构件 C、执行构件 D、质量构件 15、___B_______是可复用的，提供明确接口完成特定功能的程序代码块。 A、模块 B、函数 C、用例 D、构件 16、组件图用于对系统的静态实现视图建模，这种视图主要支持系统部件的配置管理，通常可以分为四种方式来完成，下面哪种不是其中之一（　B　） (A)对源代码建模 (B)对事物建模 (C)对物理数据库建模 (D)对可适应的系统建模 17、（ D ）由节点和节点之间的联系组成，描述了处理器、设备和软件构件运行时的体系结构。 A．组件图 B．状态图 C．顺序图 D．部署图 18、（ C ）的基本元素有节点、构件、对象、连接、依赖等。 A．组件图 B．状态图 C．部署图 D．顺序图 19、下面关于部署图的说法中，错误的是（ A ） A 部署图描述系统运行时的软件和硬件的物理结构，用于对系统的物理方面建模。(组件图) B 处理器和设备的区别在于是否具有计算能力。 C 部署图描述的是系统物理模型的布置，实际节点间的连接必须用一段导线、电缆或其它的方式连接。 D 一个系统可以有多个部署图。 20、部署图中的结点具有以下哪些方面的内容（ ABC ） （A）计算能力 （B）基本内存 （C）位置 （D）接口 21、当需要说明系统的静态实现视图时，应该选择（ A ）。 A．组件图 B．协作图 C．状态图 D．部署图 22、当需要说明体系结构的静态实施视图时，应该选择（ D ） A．协作图 B．对象图 C．活动图 D．部署图 23、（ D ）是系统中遵从一组接口且提供实现的一个物理部件，通常指开发和运行时类的物理实现 A．部署图 B．类 C．接口 D．组件 24、组件图用于对系统的静态实现视图建模，这种视图主要支持系统构件的配置管理，通常可以分为四种方式来完成，下面哪种不是其中之一（ B ）。 A．对源代码建模 B．对可执行组件建模 C．对数据库建模 D．对事物建模 25、（ A ）是用来反映代码的物理结构。 A、组件图 B、用例图 C、类图 D、状态机 ","date":"2019-07-04","objectID":"/test-software-interaction/:0:0","tags":["软件工程"],"title":"软件工程 交互预览、组件、部署习题","uri":"/test-software-interaction/"},{"categories":["软件工程"],"content":"1．请按下述要求绘制类图。 一个年级里有 3 到 5 个班级。 一个班级有 1 到 40 名学生。 1 个班级有 1 名担任班主任。 2．请按下述要求绘制出书橱的类图。 可以把书放到书橱里。 书橱的门有木制的门或玻璃制的门。 3．请按下述要求绘制出网上商店的类图。 为了一次可以购买多件商品，为每个顾客准备一个购物车。 购物车里可以装入 10 件商品。 顾客分会员及非会员两类。 4．看图回答下面问题 类 Student 和类 Course 之间是什么关系？并用文字性语言描述该类图表达意思。 答：关联关系 该图描述的是：学生和课程之间的选择关系，一个学生可以选择多门课程，一门课程可以被多个学生所选择。 ","date":"2019-07-04","objectID":"/test-software-class-diagram/:0:0","tags":["软件工程"],"title":"软件工程 类图实验题","uri":"/test-software-class-diagram/"},{"categories":["软件工程"],"content":" 依赖（Dependency）: 虚线箭头表示 关联（Association）：实线箭头表示 聚合（Aggregation）：带空心菱形头表示（整体和局部关系） 组合（Composition）：带实心菱形头的实线表示 泛化（Generalization）： 带空心箭头的实线线表示（ 继承关系） 实现（Realization）：空心箭头和虚线表示 ","date":"2019-07-03","objectID":"/test-software-class-diagram-exercises/:0:0","tags":["软件工程"],"title":"软件工程 类图习题","uri":"/test-software-class-diagram-exercises/"},{"categories":["软件工程"],"content":"一、选择题 1、在认识过程中，下面哪个不是对象的要素（ D ） A：认识的指向物 B：认识者 C：认识指向物在认识者主观中的反映 D：认识的背景 2、下面哪一个对对象的说法不正确（ B ） A：客观实体 B：事物的对立面 C：认识的指向物 D：软件的一个基本单位 3、下面属性命名不正确的是（ A ） A *BirthDay:Date B #studentBirthDay:Date=1999-10-21 C -price:float=12.01{R/W} D +studentName:String=“张敏” 4、指出下面不合适的类名（ B ） A：材料 B：事物 C：订单 D：会员 5、在类图中，下面哪个符号表示继承关系（ C ） 6、在类图中，“#”表示的可见性是（ B ） （A）Public （B）Protected （C）Private （D）Package 7、在类图中，下面哪个符号表示实现关系（ B ） 8、在类图中，哪种关系表达总体与局部的关系（ D ） （A）泛化 （B）实现 （C）依赖 （D）聚合 9、UML中类的有三种，下面哪个不是其中之一（ D ） A.实体类 B.边界类 C.控制类 D.主类 10、在UML中，类之间的关系有一种为关联关系，其中多重性用来描述类之间的对应关系，下面哪个不是其中之一（ D ） A. 0..1 B. 0..* C. 1..* D. *..* 11、通常对象有很多属性，但对于外部对象来说某些属性应该不能被直接访问，下面哪个不是UML中的类成员访问限定性（ C ） A.公有的（public） B.受保护的（protected） C.友员（friendly） D.私有的（private） 12、在一个课程注册系统中，定义了类CourseSchedule和类Course，并在类CourseSchedule中定义了方法add（c:Course）和方法remove（c:Course），则类CourseSchedule和类Course之间的关系是：（B） A、泛化关系 B、组成关系 C、依赖关系 D、包含关系 13、类A的一个操作调用类B的一个操作，且这两个类之间不存在其他关系，那么类A和类B之间是（ C ）关系。 A 实现 B、关联 C、 依赖 D、 泛化 14、在UML中下列图形代表什么关系？（A） A、组合关系 B、 依赖关系 C、聚合关系 D、泛化关系 15、在UML中下列图形代表什么关系？( D ) A、组成关系 B、 依赖关系 C、聚集关系 D、泛化关系 16、汽车（Car）由轮子、发动机、油箱、座椅、方向盘等组成。那么car类和其他类（Wheel、Engin、Tank、Chair、SteeringWheel）之间的关系是：（ A ） A、泛化关系 B、实现关系 C、包含关系 D、组合关系 17、在下面的图例中，哪个用来描述注释（ B ） 18、消息传递是对象间通信的手段，一个对象通过向另一个对象发送消息来请求其服务，一个消息通常包括：（ A ） A、发送消息的对象的标识、调用的发送方的操作名和必要的参数 B、发送消息的类名和接收消息的类名 C、接收消息的对象的标识、调用的接收方的操作名和必要的参数 D、接收消息的类名 19、在一个网络游戏系统中，定义了类Cowboy和类Castle，并在类Cowboy中定义了方法open（c：Castle）和方法Close（c：Castle），则类Cowboy和类Castle之间的关系是：……（ C ） A、依赖（dependency）关系 B、组成（composition）关系 C、泛化（generalization）关系 D、包含（include）关系 20、根据下面的代码，判断下面那些叙述是正确的？（ B ） public class HouseKeeper{ private TimeCard timecard; public void clockIn(){ timecard.punch(); } } A、类HouseKeeper和类TimeCard之间存在关联（Association）关系； B、类HouseKeeper和类TimeCard之间存在泛化（Generalization）关系； C、类HouseKeeper和类TimeCard之间存在实现（Realization）关系； D、类HouseKeeper和类TimeCard之间存在依赖（dependency）关系 21、UML关系包括关联、聚合、泛化、实现、依赖等5种类型，对应的编号分别为A、B、C、D和E，请将合适的关系填写在下列描述的（ ）中。 ① 用例及参与者之间是（ E ）关系。 ②类A的一个操作调用类B的一个操作，且这两个类之间不存在其他关系，那么类A和类B之间是（ C ）关系。 ③在学校中，一个学生可以选修多门课程，一门课程可以由多个学生选修，那么学生和课程之间是（ A ）关系。 ④森林和树木之间是（ B ）关系。 22、已知类A需要类B提供的服务，下列所描述的四种情况中，哪种情况不好把类A和类B之间的关系定义成依赖关系 （ C ） A、类A中存在两个操作都需要访问类B的同一个对象 B、类A的某个操作内部创建了类B的对象，而其他操作均与类B无关 C、类A的某个操作其参数是类B的对象，而其他操作均与类B无关 D、类B是一个全局变量 23、“一个研究生在软件学院做助教（teaching assistant），同时还在校园餐厅打工做收银员（cashier）。也就是说，这个研究生有3种角色：学生、助教、收银员，但在同一时刻只能有一种角色。” 根据上面的陈述，下面哪个设计是最合理的？（ C ） 24、类X与类Y有许多相同的属性和行为，但是它的行为与类Y稍微有所不同，这时可以认为类X是类Y的一种特例；则类X和类Y之间是（ A ）关系。 A 、泛化关系 B、 关联关系 C、 依赖关系 D、 实现关系 25、关于类和对象的关系，下列说法中哪个是错误的 （ C ） A、每个对象都是某个类的实例 B、每个类某一时刻必定存在对象实体 C、类是静态的描述 D、对象是动态的实例 ","date":"2019-07-03","objectID":"/test-software-class-diagram-exercises/:1:0","tags":["软件工程"],"title":"软件工程 类图习题","uri":"/test-software-class-diagram-exercises/"},{"categories":["软件工程"],"content":"二、填空题 1、 下图中类的名字是： _ Login_类中的成员属性是： _sName、sPass _ 类中的行为（方法）是：checkUser。 2、类描述具有相同性质的一组对象的（集合），类用（new）来表示。 3、在设计阶段，可以把类分为（控制类）、边界类和（实体类）等类型。 ","date":"2019-07-03","objectID":"/test-software-class-diagram-exercises/:2:0","tags":["软件工程"],"title":"软件工程 类图习题","uri":"/test-software-class-diagram-exercises/"},{"categories":["软件质量测试"],"content":"1、什么是软件、软件的特征有哪些？ 软件是计算机程序、规程以及可能的相关文档和运行计算机系统需要的数据。即计算机程序、规程、文档和软件系统运行所必需的数据。 软件的特征： 软件是由开发产生，不是用传统方法制造的； 软件不会像硬件那样有磨损； 软件不能通过已有构件组装，只能自己定义。 2、软件分为哪几类？ 系统软件、应用软件、WEB软件、工程和科学软件、嵌入式软件、产品线软件、人工智能软件等。 3、什么是软件质量、软件质量从哪几个方面看？ 软件质量 是指软件系统或系统中的软件部分的质量，既满足用户需求，也包括功能需求和性能需求的程度。 从哪几个方面来看软件质量？ 软件结构方面：软件应具有良好的结构； 功能和性能方面：其软件应能够按照既定的工作要求工作，并且与明确规定的功能、性能需求一直； 开发标准与文档方面：软件开发应用必须和明确沉稳的开发标准一致，遵循软件开发准则，做到软件文档资料齐全。 4、软件测试与软件调试的区别是什么？ 软件测试：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程； 软件调试：将编制的程序投入实际运行前，用手工或编译程序等方法进行测试，修正语法错误和逻辑错误的过程； 测试是为了发现软件中存在的错误，调试是为了证明软件开发的正确性； 测试以已知条件开始，使用预先定义的程序，且有预知的结果，不可预见的仅是程序是否通过测试. 调试一般是以不可预知的内部条件开始，除统计性调试外，结果是不可预见的； 测试是有计划性的，需要进行测试设计，调试是不受时间约束的； 测试经历发现错误、改正错误、重新测试的过程，调试是一个推理的过程。 5、软件测试的方法有哪些？ 静态方法和动态方法：静态方法分为代码检查、静态结构分析、代码质量度量，动态方法分为功能确认与接口测试、覆盖率分析及性能分析； 黑盒测试方法：主要有等价类划分、边值分析、因果图、错误推测、穷举输入测试方法； 白盒测试方法：逻辑覆盖、域测试、路径测试、程序插桩、程序编译； 灰盒测试，介于黑盒白盒测试之间； 软件开发阶段的测试方法：需求测试、单元测试、集成测试、性能测试、容量测试、配置测试、安装测试、安全性测试。 6、什么是黑盒测试、白盒测试和灰盒测试？ 黑盒测试也称功能测试或数据驱动测试，是已知软件所需功能，通过测试来检测每个功能是否都能正常使用。 白盒测试也称结构测试或逻辑驱动测试，知道软件内部的工作过程，可通过测试来检测软件内部的动作是否按照规格说明书所规定正常运行，并且按照软件内部的结构测试程序来检测程序中的每条道路是否都能按照预定要求进行正常工作，而不考虑功能是否正确。 灰盒测试介于黑盒与白盒之间，关注对于输入的正确性，同时也关注内部表现。 7、什么是软件质量控制模型TSQC？ TSQC过程是一个调节和控制那些影响软件质量的参数的过程。隐形软件质量的参数如下： 产品：所有可交付物； 过程：所有活动的集合； 资源：活动的物质基础（人力、技术、设备、时间、资金等）。 TSQC过程是PDCA的几个活动的循环。 计划Plan：确定参数要求； 实施Do：根据要求开展活动； 检查Check：通过评审、度量、测试确认满足要求； 改进Action：纠正参数要求再开发。 8、软件质量控制的实施过程有哪些？ 预开发阶段：主要活动包括买主与客户研究建立需求、发布招标请求、选择资源、与开发者签订合同； 开发阶段：涵盖从产品开发到移交产品别获得客户的满意度结束的全过程； 维护阶段：主要是对产品的及时更新。 9、软件质量保证模型有哪些？分别是啥？ McCall模型：分别面向软件产品的运行、修正、转移； Boehm模型：着手于软件总体功效，对于软件系统而言，除了有用性以外，开发过程必定是一个时间、金钱、能量的小号过程； FURPS模型：功能性、可用性、可靠性、性能及支持度评估； ISO 9126：功能性、可靠性、可用性、效率、可维护性及可移植性。 10、什么是冗余技术？又分为哪几种技术？ 冗余技术又称储备技术，有时也称容灾备份技术，它是利用系统的并联模型来提高系统可靠性的一种手段； 冗余技术分为工作冗余和后备冗余。 11、软件影响因素有哪些？ 需求分析定义错误； 设计错误； 编码错误； 测试错误； 文档错误。 12、软件的差错、故障和失效是什么？ 异常：偏离期望的状态（或预期值）的任何情形都称为异常； 缺陷：不符合使用要求，或与技术规格说明不一致的任何状态都称为缺陷； 差错： 计算的，观测的或测量的值与真实的规定的或理论上正确的值或者条件之间的差别； 一个不正确的步骤、过程、数据定义； 一个不正确的结果； 一次产生不正确的结果的人的活动； 故障：一个计算机程序中出现的不正确的步骤、过程、数据定义常称为故障； 失效：一个程序运行的外部结果与软件产品的要求出现不一致时称为失效。 13、什么是软件可靠性模型？都有哪些模型？ 为预计或估算软件的可靠性所建立的可靠性框图和数学模型 。 Musa模型，包括基本模型和对数模型； Shooman模型； aoel-oknmoto模型； 测试成功模型； 威布尔模型。 14、为什么需要软件评审？ 提高项目的生产率； 改善软件的质量； 在评审过程中使开发团队的其他成员更熟悉产品和开发过程； 通过评审标志软件开发的一个阶段的完成； 生产出更容易维护的软件。 15、软件评审有哪些内容？ 管理评审； 技术评审； 文档评审； 过程评审。 16、评审的方法及技术有哪些？ 评审的方法：特别检查、轮查、走查、团队评审、监视； 评审的技术：缺陷检查表、规则表、评审工具的使用、从不同角度理解产品、场景分析技术。 17、如何准备评审会议？ 何时召开评审会议； 选择那些评审材料； 打包分发评审材料； 合理安排评审活动进程。 18、召开评审会议有几个步骤？ 评审预备； 评审开始； 评审决议； 评审结果； 几个原则。 19、提高程序质量的技术有哪些？ 内存分配方式：从静态存储区域分配；在栈上创建；从堆上分配 面向对象的设计规则 1）开-闭原则 2）里氏代换原则 3）依赖倒转原则 4）合成/聚合复用原则 5）迪米特原则 6）接口隔离原则 7）基本的设计模式 20、软件测试的原则有哪些？ 在整个开发过程中要尽早地和不断的进行软件测试； 在开始测试时不应默认程序中不存在错误； 在设计测试用例时要给出测试的预期结果； 测试工作应避免由系统开发人员或开发机构本身来承担； 对合理和不合理的输入数据都要进行测试； 重点测试错误群集的程序区段； 除检查程序功能是否有多余； 用穷举例测试是不可能的； 长期完整的保留所有的测试用例和测试文件，直到该软件产品被废弃为止。 21、软件测试过程有哪些？ 单元测试、集成测试、系统测试、验收测试、在所有测试过程中始终贯穿着回归测试。 22、软件测试的种类有哪些？ 单元测试、集成测试、功能测试、压力/负载测试、验收测试。 23、白盒测试方法工具有哪些？ 1）静态测试方法 工具：logiscope软件，P.RQA软件，c++Test； 2）动态测试方法：代码检查法，静态结构分析法，静态质量度量法，逻辑覆盖法，基本路径测试法，域测试，符号测试，路径覆盖，程序变异； 工具：DevPartner软件、Purity系列、xUnit系列框架（单元测试工具）。 24、黑盒测试工具有哪些？ 1）功能测试工具：WinRunner，AutoIT，Twist 2）性能测试工具：LoadRunner 25、黑盒测试方法有哪些？ 等价类划分 边界值分析法 因果图法 功能图法 26、划分等价类的原则是什么？ 在输入条件规定了取值范围或值的个数和情况下可以确立一个有效等价类和两个无效等价类； 在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下可以确立一个有效等价类和一个无效等价类； 在输入条件是一个布尔量的情况下可以确定一个有效等价类和一个无效等价类； 在规定了输入数据的一组值（假设n个）并且程序要对每一个输入值分别处理的情况下可以确立n个有效等价类和一个无效等价类； 在规定了输入数据必须遵守的规则的情况下可以确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）； 在确知已划分的等价类中各元素在程序处理中的方式不同的情况下应将该等价类进一步划分为更小的等价类。 27、软件测试 经典测试用例三角形问题 软件质量测试 等价类划分 三角形问题 28、因果图测试用例问题 软件质量测试 因果图测试用例 自动售货机 29、白盒测试程序的结构有哪些？ 顺序结构、分支结构、循环结构 。 30、白盒测试方法的覆盖标准有哪些？ 逻辑覆盖，循环覆盖，基本路径测试。 31、逻辑覆盖包括那些？ 分支结构的测试和循环结构的测试、 分支结构的测试又包括语句覆盖 、分支覆盖 、条件覆盖、分支-条件覆盖、条件组合覆盖、路径覆盖。 32、集成测试策略有：非渐增式集成和渐增式集成。 33、什么是渐进增式集成？什么是非渐增式继承？ 光分别测试每个模块，再把所有模块按设计要求放在一起，结合所要的程序，这种方法称为非渐增式集成； 把一个要测试的模块与已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合起来进行测试，这种每次增加一个模块的方法称为渐增式集成。 34.渐增式集成分为：自顶向下增式集成测试，自底向上增式集成测试 35.面向对象的集成测试的步骤 先选定检测的类，仔细给出类的状态和相应的行为，类或成员函数间传递的消息，输入或输出的界定等 确定覆盖标准 利用结构关系图，确定待测类的所有关联 根据程序中类的对象构造测试用例，确认使用什么输入法激发类的状态，使用类的","date":"2019-07-03","objectID":"/test-software-quality/:0:0","tags":["软件质量测试"],"title":"软件质量测试知识点","uri":"/test-software-quality/"},{"categories":["软件质量测试"],"content":"问题描述 有一个饮料自动售货机（处理单价为5角钱）的控制处理软件，它的软件规格说明如下： 若投入5角钱的硬币，按下“橙汁”或“啤酒”的按钮，则相应的饮料就送出来。 若投入1元钱的硬币，同样也是按“橙汁”或“啤酒”的按钮，则自动售货机在送出相应饮料的同时退回5角钱的硬币。 ","date":"2019-07-03","objectID":"/test-software-vending-mechine/:1:0","tags":["软件质量测试"],"title":"软件质量测试 因果图测试用例 自动售货机","uri":"/test-software-vending-mechine/"},{"categories":["软件质量测试"],"content":"分析情况 怎么分析这种具有一定实际意义的情况呢？ 按照因果图的说法，我们先分析一下，把原因与结果先找出来： 原因是输入条件，在自动售货机里，硬币的投入、按钮的按下，都是输入，这样的话就有以下几个原因： （1）投入5角硬币 （2）投入1元硬币 （3）按下“橙汁”按钮 （4）按下“啤酒”按钮 结果有哪些呢？ (1）送出“橙汁”饮料 (2）送出“啤酒”饮料 (3）找5角硬币 按照因果关系，把因果图的雏形画出来： ","date":"2019-07-03","objectID":"/test-software-vending-mechine/:2:0","tags":["软件质量测试"],"title":"软件质量测试 因果图测试用例 自动售货机","uri":"/test-software-vending-mechine/"},{"categories":["软件质量测试"],"content":"因果测试图判定 再加上因果图的约束关系，那么图形就成为以下： 根据最终的因果图生成判定表： 最后把测试用例写出来： 转载自文章： 测试用例设计技术-因果图之二 ","date":"2019-07-03","objectID":"/test-software-vending-mechine/:3:0","tags":["软件质量测试"],"title":"软件质量测试 因果图测试用例 自动售货机","uri":"/test-software-vending-mechine/"},{"categories":["软件质量测试"],"content":"问题描述 一个程序读入3个整数，把这三个数值看作一个三角形的3条边的长度值。这个程序要打印出信息，说明这个三角形是不等边的、是等腰的、还是等边的。 我们可以设三角形的3条边分别为A，B，C。如果它们能够构成三角形的3条边，必须满足： A\u003e0，B\u003e0，C\u003e0，且A+B\u003eC，B+C\u003eA，A+C\u003eB。 如果是等腰的，还要判断A=B，或B=C，或A=C。 如果是等边的，则需判断是否A=B，且B=C，且A=C。 ","date":"2019-07-03","objectID":"/test-software-triangle-problem/:1:0","tags":["软件质量测试"],"title":"软件质量测试 等价类划分 三角形问题","uri":"/test-software-triangle-problem/"},{"categories":["软件质量测试"],"content":"等价类划分 ","date":"2019-07-03","objectID":"/test-software-triangle-problem/:2:0","tags":["软件质量测试"],"title":"软件质量测试 等价类划分 三角形问题","uri":"/test-software-triangle-problem/"},{"categories":["软件质量测试"],"content":"代码实现 float a, b, c; printf(\"请输入三角形三边\"); scanf(\"%f,%f,%f\",\u0026a,\u0026b,\u0026c); if (a==b||b==c||a==c) printf(\"等腰三角形\"); if (a==b\u0026\u0026b==c) printf(\"等边三角形\"); if (a*a+b*b==c*c||a*a+c*c==b*b||b*b+c*c==a*a) printf(\"直角三角形\"); else printf(\"普通三角形\"); 转载自文章： 软件测试-三角形问题 ","date":"2019-07-03","objectID":"/test-software-triangle-problem/:3:0","tags":["软件质量测试"],"title":"软件质量测试 等价类划分 三角形问题","uri":"/test-software-triangle-problem/"},{"categories":["软件工程"],"content":"1、（ A )是用于把元素组织成组的通用机制 A）包 B、类 C）接口 D）组件 2、下面哪个符号代表包图（ A ） 3、包内的元素可以被包内的元素、继承的子包元素所访问是指包的____B_____。 A．公有访问 B. 保护访问 C. 私有访问 D.通用访问 4、包内的元素可以被包外的元素所访问是指包的______A______。 A．公有访问 B. 保护访问 C. 私有访问 D.通用访问 5、包内的元素只能被属于同一个模型包的内含元素访问是指包的_____C______。 A．公有访问 B. 保护访问 C. 私有访问 D.通用访问 6、客户包依赖于提供者包是指包的____B____依赖关系。 A. use B. import C. access D. trace 《use》使用关系：是一种默认的依赖关系，说明客户包（发出者）中的元素以某种方式使用提供者包（箭头指向的包）的公共元素，也就是说客户包依赖于提供者包。 7、客户包中的元素也能够访问提供者包的所有公共元素是指包的____B____依赖关系。 A. use B. import C. access D. trace 《import》引用关系：最普遍的包依赖类型，说明提供者包(箭头指向的包)的命名空间（包本身代表命名空间）将被添加到客户包（发出者）的命名空间中，客户包中的元素也能够访问提供者包的所有公共元素 。 8、 客户包中的元素能够访问提供包中的所有公共元素，但客户包必须使用路径名，是指包的__C____关系。 A. use B. import C. access D. trace 《access》访问关系：只想使用提供者包中的元素，而不想将其命名空间合并则应使用该关系。 9、表示一个包到另一个包的历史发展，是指包的____D_____关系。 A. use B. import C. access D. trace 《trace》追溯关系：想表示一个包到另一个包的历史发展，则需要使用《trace》关系来表示 。 10、包元素可以拥有的元素包括(多选)A、C、D_。 A. 类 B. 构件 C. 用例 D. 包 包中拥有的元素可以是模型的各种元素，例如类、接口、组件、用力、也可以是其他包。 11、包的常见构造型包括(多选)A、B、C__。 A. 《subsystem》 B. 《facade》 C. 《framework》 D. 《node》 12、UML系统需求分析阶段产生的包图描述了系统的（ B ）。 A．状态 B．系统体系层次结构 C．静态模型 D．功能要求 13、（ A ）是一组用于描述类或组件的一个服务的操作 A、包 B、节点 C、接口 D、组件 14、如下选项所示，哪一种设计所包含的包之间的依赖关系是最不好的？（A） 15、下面哪一项不是包图中的关系（ D ） （A）«use» （B）«access» （C）«trace»（D）«stub» 16、建立模型时包的嵌套不宜过深，包的嵌套一般以（A）为宜。 A．2~3层 B.3~4层 C．1~2层 D.3~5层 17、下列对于创建包的说法不正确的是（A） A．在序列图和协作图中可以创建包 B．在类图中可以创建包 C．如果将包从模型中永久删除，包及包中的内容都将被删除 D．在创建包的依赖关系时，尽量避免循环依赖 18、关于包的描述，哪个不正确（ D ） A.和其他建模元素一样，每个包必须有一个区别于其他包的名字； B.包中可以包含其他元素，比如类、接口、组件、用例等等； C.包的可见性分为：public、protected、private； D.导出（export）使的一个包中的元素可以单向访问另一个包中的元素； 19、UML的（ B ）模型图由类图、对象图、包图、构件图和配置图组成。 A．用例 B．静态 C．动态 D．系统 20、（ A ）是用于把元素组织成组的通用机制 A．包 B．类 C．接口 D．组件 21、（ C ）是一组用于描述类或组件的一个服务的操作 A．包 B．节点 C．接口 D．组件 22、在UML中，以下( B )是可以应用于包的构造型 A、框架{《Framework》} B、虚包{《Facade》} C、子系统{《Subsystem》} D、系统{《system》} 23、UML系统需求分析阶段产生的包图描述了系统的（ C ）。 A．状态 B．系统体系层次结构 C．静态模型 D．功能要求 24、在UML中，（ B ）可以对模型元素进行有效组织，如类，用例，构件，从而构成具有一定意义的单元。 A、连接 B、包 C、构件 D、节点 ","date":"2019-07-02","objectID":"/test-software-package-diagram/:0:0","tags":["软件工程"],"title":"软件工程 包图习题","uri":"/test-software-package-diagram/"},{"categories":["软件工程"],"content":"1、UML图不包括 ( D ) A）用例图 B）类图 C）状态机图 D）流程图 2、下面中（ C ）图表示结束状态。 3、UML中，对象行为是通过交互来实现的，是对象间为完成某一目的而进行的一系列消息交换。消息序列可用两种类来表示，分别是（　D　）。 A）状态机图和顺序图 B）活动图和通信图 C）状态机图和活动图 D）顺序图和通信图 4、在UML提供的图中，（ D ）　用于按时间顺序描述对象间交互。 A）网络图 B）状态机图 C）通信图 D）顺序图 5、在状态图中不能表示下面哪些概念？（ D ） A）动作（Action） B）事件(event) C）转移 D）类 6、生命线是UML视图中哪个图形的组成部分（ D ） A）类图 B）状态机图 C）活动图 D）顺序图 7、顺序图由类角色，生命线，激活期和（ B ）组成。 A）关系 B）消息 C）用例 D）实体 8、下面哪种图最合适用来描述场景：（ B ）。 A）包图 B）交互图（顺序图、通信图） C）类图 D）用例图 9、UML中，对象行为是通过交互来实现的，是对象间为完成某一目的而进行的一系列消息交换。消息序列可用两种类来表示，分别是( D )。 A.状态图和顺序图 B.活动图和通信图 C.状态图和活动图 D.顺序图和通信图 10、顺序图由类角色，生命线，激活期和( B )组成 A、关系 B、消息 C、用例 D、实体 11、顺序图是强调消息随时间顺序变化的交互图，下面哪个不是用来描述顺序图的组成部分( A ) A.信号 B.生命线 C.激活期 D.类角色 12、关于通信图的描述，下列哪个不正确____B____ A.通信图作为一种交互图，强调的是参加交互的对象的组织； B.通信图是顺序图的一种特例 C.通信图中有消息流的顺序号 D.通信图和顺序图不能互换 13、请在下面选项目中选出两种可以互相转换的图(多选)A、B_。 A 顺序图 B 通信图 C活动图 D状态图 14、下面哪个不是UML中的静态视图（A） (A)状态图 (B)用例图 (C)对象图 (D)类图 15、顺序图的模型元素有（ A ）、消息、链接等，这些模型元素表示某个用例中的若干个对象和对象之间所传递的消息，来对系统的行为建模。 A．对象 B．箭头线 C．活动 D．状态 16、顺序图描述（ D ）对象之间消息的传递顺序。 A．某个 B．单个 C．一个类产生的 D．一组 17、顺序图和合作图建立了UML面向对象开发过程中的对象动态（ A ）模型。 A．交互 B．状态 C．体系结构 D．软件复用 18、状态图可以表现（ B ）在生存期的行为、所经历的状态序列、引起状态转移的事件以及因状态转移而引起的动作。 A．一组对象 B．一个对象 C．多个执行者 D．几个子系统 19、状态图描述一个对象在不同（ A ）的驱动下发生的状态迁移。 A．事件 B．对象 C．执行者 D．数据 20、 下面的状态图描述了一辆汽车的状态，指出哪种说法是错误的（ D ） A “运动”状态是一个组成状态，由多个简单状态组成。 B “前进”状态和“低速”状态有可能同时出现。 C 汽车在“前进”、“后退”、“高速”及“低速”任何一个子状态下，都有可能转到“停止”状态。 D “前进”状态和“低速”状态是两个顺序子状态。 21、下面哪个UML视图是描述一个对象的生命周期的（ B ） （A）类图 （B）状态图 （C）协作图 （D）顺序图 22、下面哪个视图属于UML语言的交互图（ B ） （A）行为图 （B）状态图 （C）实现图 （D）顺序图 23、顺序图主要可以为设计人员提供（A）信息。 A. 消息发送的顺序 B. 某个方法的执行流程 C. 类之间关联关系的多重性 D. 某个对象在不同状态之间的转移 ","date":"2019-07-01","objectID":"/test-software-stat-sequence-diagram/:0:0","tags":["软件工程"],"title":"软件工程 状态图、顺序图习题","uri":"/test-software-stat-sequence-diagram/"},{"categories":["数据挖掘实例"],"content":"安装Anaconda Python集成环境 ","date":"2019-06-17","objectID":"/python-decision-tree/:1:0","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"下载环境 官网： https://www.anaconda.com/ 下载： https://www.anaconda.com/distribution/ ","date":"2019-06-17","objectID":"/python-decision-tree/:1:1","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"安装环境 下载过程中使用默认，但有一个页面需要确认，如下图。 第一个勾是是否把 Anaconda 加入环境变量，这涉及到能否直接在 cmd中使用 conda、jupyter、 ipython 等命令，推荐打勾。 第二个是是否设置 Anaconda 所带的 Python 3.6 为系统默认的 Python 版本，可以打勾。 安装完成后，在开始菜单中显示“Anaconda2”如下图所示。 ","date":"2019-06-17","objectID":"/python-decision-tree/:1:2","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"安装第三方程序包 Graphviz 目的是在决策树算法中八进制最终的树结构。 1、打开 Anaconda Prompt ，输入 conda install python-graphviz，回车即可完成安装，如下图所示，本图所示已经安装 了 graphviz 包，若之前没有安装，这时会花点时间安装，安装不用干预。 安装完成后先输入 python，然后再输入 import graphviz，测试是否成功安装，如上图所示。 需要设置环境变量，才能使用新安装的 graphviz。 ","date":"2019-06-17","objectID":"/python-decision-tree/:1:3","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"Anaconda及依赖包环境变量设置 首先查看 anaconda 安装在哪个目录下，可以打开 Spyder 的属性，看一看目标是什么目 录。例如本机的 anaconda 安装路径为 C:\\Users\\lenovo\\Anaconda2。 下面设置环境变量 在用户变量“path”里添加 C:\\Users\\debuginn\\Anaconda2\\Library\\bin\\graphviz 在系统变量的“path”里添加 C:\\Users\\debuginn\\Anaconda2\\Library\\bin\\graphviz\\dot.exe 如果现在有正在打开的 anaconda 程序，例如正在 Spyder，那么关闭 Spyder，再启动，这 样刚才设置的环境变量生效。 ","date":"2019-06-17","objectID":"/python-decision-tree/:1:4","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"决策树分析 ","date":"2019-06-17","objectID":"/python-decision-tree/:2:0","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"格式化原始数据 将下图的表 demo 输入到 Excel 中，保存为.csv 文件（.csv 为逗号分隔值文件格式）。 注意将表 demo 中的汉字值转换成数据字值，例如“是否是公司职员”列中的“是”为“1”， “否”为“0”。转换后的表中数据如下图所示。 ","date":"2019-06-17","objectID":"/python-decision-tree/:2:1","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"编写数据分析代码 编写程序对上面的数据进行决策树分类，采用信息熵（entropy）作为度量标准。参考代码如下所示： from sklearn.tree import DecisionTreeClassifier,export_graphviz import graphviz import csv dataset = [] reader = csv.reader(open(\"demo.csv\")) for line in reader: if reader.line_num == 1: continue dataset.append(line) X = [x[0:4] for x in dataset] y = [x[4] for x in dataset] clf = DecisionTreeClassifier(criterion='entropy').fit(X, y) dot_data = export_graphviz(clf, out_file=None) graph = graphviz.Source(dot_data) graph.render(\"table\"); digraph Tree { node [shape=box] ; 0 [label=\"X[0] \u003c= 0.5\\nentropy = 0.94\\nsamples = 14\\nvalue = [9, 5]\"] ; 1 [label=\"X[1] \u003c= 1.5\\nentropy = 0.985\\nsamples = 7\\nvalue = [3, 4]\"] ; 0 -\u003e 1 [labeldistance=2.5, labelangle=45, headlabel=\"True\"] ; 2 [label=\"entropy = 0.0\\nsamples = 3\\nvalue = [0, 3]\"] ; 1 -\u003e 2 ; 3 [label=\"X[1] \u003c= 2.5\\nentropy = 0.811\\nsamples = 4\\nvalue = [3, 1]\"] ; 1 -\u003e 3 ; 4 [label=\"entropy = 0.0\\nsamples = 2\\nvalue = [2, 0]\"] ; 3 -\u003e 4 ; 5 [label=\"X[3] \u003c= 0.5\\nentropy = 1.0\\nsamples = 2\\nvalue = [1, 1]\"] ; 3 -\u003e 5 ; 6 [label=\"entropy = 0.0\\nsamples = 1\\nvalue = [1, 0]\"] ; 5 -\u003e 6 ; 7 [label=\"entropy = 0.0\\nsamples = 1\\nvalue = [0, 1]\"] ; 5 -\u003e 7 ; 8 [label=\"X[1] \u003c= 2.5\\nentropy = 0.592\\nsamples = 7\\nvalue = [6, 1]\"] ; 0 -\u003e 8 [labeldistance=2.5, labelangle=-45, headlabel=\"False\"] ; 9 [label=\"entropy = 0.0\\nsamples = 4\\nvalue = [4, 0]\"] ; 8 -\u003e 9 ; 10 [label=\"X[3] \u003c= 0.5\\nentropy = 0.918\\nsamples = 3\\nvalue = [2, 1]\"] ; 8 -\u003e 10 ; 11 [label=\"entropy = 0.0\\nsamples = 2\\nvalue = [2, 0]\"] ; 10 -\u003e 11 ; 12 [label=\"entropy = 0.0\\nsamples = 1\\nvalue = [0, 1]\"] ; 10 -\u003e 12 ; } ","date":"2019-06-17","objectID":"/python-decision-tree/:2:2","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"数据分析结果 程序运行结果在与该程序在同一目录下的 table.pdf 文件中，将每一个叶子结点转换成 IF-THEN 规则。 ","date":"2019-06-17","objectID":"/python-decision-tree/:2:3","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["数据挖掘实例"],"content":"IF-THEN分类规则 （1）IF\"不是公司员工\" AND \"年龄大于等于40\", THEN \"不买保险\"。 （2）IF\"不是公司员工\" AND \"年龄小于40\", THEN \"买保险\"。 （3）IF\"不是公司员工\" AND \"年龄大于50\" AND \"信用为良\", THEN \"不买保险\"。 （4）IF\"不是公司员工\" AND \"年龄大于40\" AND \"信用为优\", THEN \"买保险\"。 （5）IF\"是公司员工\" AND \"年龄小于50\", THEN \"不买保险\"。 （6）IF\"是公司员工\" AND \"年龄小于50\" AND \"信用为优\", THEN \"买保险\"。 （7）IF\"是公司员工\" AND \"年龄小于50\" AND \"信用为良\", THEN \"不买保险\"。 ","date":"2019-06-17","objectID":"/python-decision-tree/:2:4","tags":["数据挖掘实例"],"title":"Python 数据挖掘实例 决策树分析","uri":"/python-decision-tree/"},{"categories":["计算机网络"],"content":"端口定义 通信端口，又称为连接端口、端口、协议端口在计算机网络中是一种经由软件创建的服务，在一个计算机操作系统中扮演通信的端点。每个通信端口都会与主机的IP地址及通信协议关联。通信端口以16比特数字来表示，这被称为通信端口编号。 位于传输层的通信协议通常需要指定端口号，例如在TCP/IP协议族之下的TCP与UDP协议。 引用来源：维基百科 传输层协议，如传输控制协议（TCP）与用户数据包协议（UDP），在分组表头中，定义了来源端口号与目的端口号。 一个通信端口号使用16位无符号整数（unsigned integer）来表示，其范围介于0与65535之间。 在TCP协议中，端口号0是被保留的，不可使用。 1–1023 系统保留，只能由root用户使用。 1024—4999 由客户端程序自由分配。 5000—65535 由服务器端程序自由分配在UDP协议中，来源端口号是可以选择要不要填上，如果设为0，则代表没有来源端口号。 ","date":"2019-06-15","objectID":"/network-notes-port/:1:0","tags":["计算机网络"],"title":"网络笔记之端口及常见端口号","uri":"/network-notes-port/"},{"categories":["计算机网络"],"content":"常见端口对照表 端口号码 / 层 名称 注释 1 tcpmux TCP 端口服务多路复用 5 rje 远程作业入口 7 echo Echo 服务 9 discard 用于连接测试的空服务 11 systat 用于列举连接了的端口的系统状态 13 daytime 给请求主机发送日期和时间 17 qotd 给连接了的主机发送每日格言 18 msp 消息发送协议 19 chargen 字符生成服务；发送无止境的字符流 20 ftp-data FTP 数据端口 21 ftp 文件传输协议（FTP）端口；有时被文件服务协议（FSP）使用 22 ssh 安全 Shell（SSH）服务 23 telnet Telnet 服务 25 smtp 简单邮件传输协议（SMTP） 37 time 时间协议 39 rlp 资源定位协议 42 nameserver 互联网名称服务 43 nicname WHOIS 目录服务 49 tacacs 用于基于 TCP/IP 验证和访问的终端访问控制器访问控制系统 50 re-mail-ck 远程邮件检查协议 53 domain 域名服务（如 BIND） 63 whois++ WHOIS++，被扩展了的 WHOIS 服务 67 bootps 引导协议（BOOTP）服务；还被动态主机配置协议（DHCP）服务使用 68 bootpc Bootstrap（BOOTP）客户；还被动态主机配置协议（DHCP）客户使用 69 tftp 小文件传输协议（TFTP） 70 gopher Gopher 互联网文档搜寻和检索 71 netrjs-1 远程作业服务 72 netrjs-2 远程作业服务 73 netrjs-3 远程作业服务 73 netrjs-4 远程作业服务 79 finger 用于用户联系信息的 Finger 服务 80 http 用于万维网（WWW）服务的超文本传输协议（HTTP） 88 kerberos Kerberos 网络验证系统 95 supdup Telnet 协议扩展 101 hostname SRI-NIC 机器上的主机名服务 102 iso-tsap ISO 开发环境（ISODE）网络应用 105 csnet-ns 邮箱名称服务器；也被 CSO 名称服务器使用 107 rtelnet 远程 Telnet 109 pop2 邮局协议版本2 110 pop3 邮局协议版本3 111 sunrpc 用于远程命令执行的远程过程调用（RPC）协议，被网络文件系统（NFS）使用 113 auth 验证和身份识别协议 115 sftp 安全文件传输协议（SFTP）服务 117 uucp-path Unix 到 Unix 复制协议（UUCP）路径服务 119 nntp 用于 USENET 讨论系统的网络新闻传输协议（NNTP） 123 ntp 网络时间协议（NTP） 137 netbios-ns 在红帽企业 Linux 中被 Samba 使用的 NETBIOS 名称服务 138 netbios-dgm 在红帽企业 Linux 中被 Samba 使用的 NETBIOS 数据报服务 139 netbios-ssn 在红帽企业 Linux 中被 Samba 使用的NET BIOS 会话服务 143 imap 互联网消息存取协议（IMAP） 161 snmp 简单网络管理协议（SNMP） 162 snmptrap SNMP 的陷阱 163 cmip-man 通用管理信息协议（CMIP） 164 cmip-agent 通用管理信息协议（CMIP） 174 mailq MAILQ 177 xdmcp X 显示管理器控制协议 178 nextstep NeXTStep 窗口服务器 179 bgp 边界网络协议 191 prospero Cliffod Neuman 的 Prospero 服务 194 irc 互联网中继聊天（IRC） 199 smux SNMP UNIX 多路复用 201 at-rtmp AppleTalk 选路 202 at-nbp AppleTalk 名称绑定 204 at-echo AppleTalk echo 服务 206 at-zis AppleTalk 区块信息 209 qmtp 快速邮件传输协议（QMTP） 210 z39.50 NISO Z39.50 数据库 213 ipx 互联网络分组交换协议（IPX），被 Novell Netware 环境常用的数据报协议 220 imap3 互联网消息存取协议版本3 245 link LINK 347 fatserv Fatmen 服务器 363 rsvp_tunnel RSVP 隧道 369 rpc2portmap Coda 文件系统端口映射器 370 codaauth2 Coda 文件系统验证服务 372 ulistproc UNIX Listserv 389 ldap 轻型目录存取协议（LDAP） 427 svrloc 服务位置协议（SLP） 434 mobileip-agent 可移互联网协议（IP）代理 435 mobilip-mn 可移互联网协议（IP）管理器 443 https 安全超文本传输协议（HTTP） 444 snpp 小型网络分页协议 445 microsoft-ds 通过 TCP/IP 的服务器消息块（SMB） 464 kpasswd Kerberos 口令和钥匙改换服务 468 photuris Photuris 会话钥匙管理协议 487 saft 简单不对称文件传输（SAFT）协议 488 gss-http 用于 HTTP 的通用安全服务（GSS） 496 pim-rp-disc 用于协议独立的多址传播（PIM）服务的会合点发现（RP-DISC） 500 isakmp 互联网安全关联和钥匙管理协议（ISAKMP） 535 iiop 互联网内部对象请求代理协议（IIOP） 538 gdomap GNUstep 分布式对象映射器（GDOMAP） 546 dhcpv6-client 动态主机配置协议（DHCP）版本6客户 547 dhcpv6-server 动态主机配置协议（DHCP）版本6服务 554 rtsp 实时流播协议（RTSP） 563 nntps 通过安全套接字层的网络新闻传输协议（NNTPS） 565 whoami whoami 587 submission 邮件消息提交代理（MSA） 610 npmp-local 网络外设管理协议（NPMP）本地 / 分布式排队系统（DQS） 611 npmp-gui 网络外设管理协议（NPMP）GUI / 分布式排队系统（DQS） 612 hmmp-ind HMMP 指示 / DQS 631 ipp 互联网打印协议（IPP） 636 ldaps 通过安全套接字层的轻型目录访问协议（LDAPS） 674 acap 应用程序配置存取协议（ACAP） 694 ha-cluster 用于带有高可用性的群集的心跳服务 749 kerberos-adm Kerberos 版本5（v5）的“kadmin”数据库管理 750 kerberos-iv Kerberos 版本4（v4）服务 765 webster 网络词典 767 phonebook 网络电话簿 873 rsync rsync 文件传输服务 992 telnets 通过安全套接字层的 Telnet（TelnetS） 993 imaps 通过安全套接字层的互联网消息存取协议（IMAPS） 994 ircs 通过安全套接字层的互联网中继聊天（IRCS） 995 pop3s 通过安全套接字层的邮局协议版本3（POPS3） ","date":"2019-06-15","objectID":"/network-notes-port/:2:0","tags":["计算机网络"],"title":"网络笔记之端口及常见端口号","uri":"/network-notes-port/"},{"categories":["windows"],"content":"今天不经意间开启了windows7的虚拟机，用了半天，给出了下面的弹窗，一看，原来是微软最后做windows7的更新停止工作，想想用Windows7这个系统，记忆中从小学就开始使用了，用着它参加了我人生中的大考，山东省2016年春季高考，也算是圆了自己的一个大学梦，考上了本科院校，PS（自己学校实在是emm，一年出不了多少本科生），在这写着一篇文章纪念一下自己使用了近十年的系统。 社会的进步，同时又看出美帝国主义的险恶，不过好消息是华为要推出自己的操作系统，鸿蒙OS，比较期待，现如今我们只有软件、硬件强大起来，打破美帝的垄断，才能在互联网有得自己的一席之地，加油，中国、加油，新时代的程序猿、加油，华为，加油、中华民族，加油！！！ 最后给大家展示一下Windows7这个系统的告白网页吧，以后Windows家族何去何从，大家拭目以待，致敬Win7。 不得不说，最后还要推一波广告，哈哈，Windows10现在已经是我的主要使用的OS了！！ ","date":"2019-06-05","objectID":"/windows7-bye/:0:0","tags":["windows"],"title":"再见Windows7，中学时期的一代神器","uri":"/windows7-bye/"},{"categories":["微信小程序"],"content":" 最近两个星期在学习小程序，主要是应对“全国大学生计算机应用能力与信息素养比赛”，虽然最后没有取得一个比较好的成绩（PS：国家安慰奖），但是收获了不少，边学习边敲代码也是不错的，嘿嘿，下面就是我对这个学习小程序的代码笔记及我设计的小程序的演示图片，嘿嘿，在此处建立一个里程碑吧！ ","date":"2019-06-04","objectID":"/mini-program-notes/:0:0","tags":["微信小程序"],"title":"微信小程序入门笔记","uri":"/mini-program-notes/"},{"categories":["微信小程序"],"content":"小程序学习笔记 ","date":"2019-06-04","objectID":"/mini-program-notes/:1:0","tags":["微信小程序"],"title":"微信小程序入门笔记","uri":"/mini-program-notes/"},{"categories":["微信小程序"],"content":"设计小程序图例 ","date":"2019-06-04","objectID":"/mini-program-notes/:2:0","tags":["微信小程序"],"title":"微信小程序入门笔记","uri":"/mini-program-notes/"},{"categories":["微信小程序"],"content":"PPT 文稿 ","date":"2019-06-04","objectID":"/mini-program-notes/:3:0","tags":["微信小程序"],"title":"微信小程序入门笔记","uri":"/mini-program-notes/"},{"categories":["微信小程序"],"content":"总结 这个框架才用了ColorUI设计，界面个人感觉清新爽目，嘿嘿，，，，，遗憾的是没有做后台，相比其他学校终结了一下，缺少以下几点： 绝大部分作品与本学校教务处对接，已经运行上线； 后台设计及算法优化比较先进； 采用多种技术，只是采用小程序做显示及基本功能的实现，主要寄托于后台； 获得国一的作品用了Python进行爬虫及数据分析，膜拜大佬。。。 算了，以后就不比赛了，准备北漂工作了，加油！！！ ","date":"2019-06-04","objectID":"/mini-program-notes/:4:0","tags":["微信小程序"],"title":"微信小程序入门笔记","uri":"/mini-program-notes/"},{"categories":["蓝桥杯"],"content":"题目背景 在游戏《星际争霸II》中，高阶圣堂武士作为星灵的重要AOE 单位，在 游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对 一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的 刺蛇飞龙等低血量单位。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"问题描述 你控制着n 名高阶圣堂武士，方便起见标为1; 2; ...... ; n。每名高阶圣堂武士 需要一定的灵能来战斗，每个人有一个灵能值ai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了ai 点灵能，ai 为负则表示这 名高阶圣堂武士还需要-ai 点灵能才能到达最佳战斗状态）。现在系统赋予了 你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个i 属于2 [2; n - 1]，若 ai \u003e=0 则其两旁的高阶圣堂武士，也就是 i - 1、i + 1 这两名高阶圣堂武士会从 i 这名高圣堂武士这里各抽取ai 点灵能；若ai \u003c 0 则其两旁的高阶圣堂武士， 也就是i - 1;i + 1 这两名高阶圣堂武士会给i 这名高阶圣堂武士?ai 点灵能。形式化来讲就 灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂 武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武 士的不稳定度最小。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"输入格式 本题包含多组询问。输入的第一行包含一个正整数T 表示询问组数。 接下来依次输入每一组询问。 每组询问的第一行包含一个正整数n，表示高阶圣堂武士的数量。 接下来一行包含n 个数a1; a2; ……..; an。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"输出格式 输出T 行。每行一个整数依次表示每组询问的答案。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"样例输入 3 3 5 -2 3 4 0 0 0 0 3 1 2 3 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:4:1","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"样例输出 3 0 3 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:4:2","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"样例说明 对于第一组询问： 对2 号高阶圣堂武士进行传输操作后a1 = 3 对于第二组询问： 这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"样例输入 3 4 -1 -2 -3 7 4 2 3 4 -8 5 -1 -1 6 -1 -1 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:5:1","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"样例输出 5 7 4 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:5:2","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"样例输入 3 5 6 -4 2 -7 3 10 -99 -53 43 80 -83 72 99 78 -63 -9 100 373837389 225627048 -847064399 487662607 579717002 903937892 -89313283 134706789 259978604 399131737 298183518 62083619 -444218530 403702220 358088455 -973959249 -637339048 -736509394 -552801709 -98262597 -532577703 -393599463 762744971 -683270041 716127816 -991756495 734780346 27919355 -421469435 258728334 844409214 -270792553 -490888330 133696186 843888283 -35439761 -73481392 -118968548 269164182 978558860 522378250 -979427259 -330256906 235192566 -652699569 -708569352 -778693386 241745676 583226906 121065292 -503683097 599394257 405122877 437067802 238539735 -957745973 -843677563 -690555937 908484805 940157941 524765035 730436972 -17856720 -530595388 -727773574 617781285 491720304 -779040285 -298295760 -699402143 230749576 404009775 126806094 -140842651 198136484 681875881 997449600 898972467 -239590302 -62193410 866009412 -401154712 -276085482 593177187 -236793216 487533624 75511548 -446699920 -869912037 -330666015 268937148 -430325605 -635949275 361887555 -855294881 87004526 782523543 -69083645 -965396597 -880697065 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:5:3","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"样例输出 5 88 381470940 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:5:4","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"数据规模与约定 对于所有评测用例: 评测时将使用25 个评测用例测试你的程序，每个评测用例的限制如下： 注意：本题输入量较大请使用快速的读入方式。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-psionic-trans/:5:5","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 灵能传输","uri":"/lqb-19-b-cplus-psionic-trans/"},{"categories":["蓝桥杯"],"content":"问题描述 给定N 个加号、M 个减号以及N + M + 1 个整数A1; A2; ……; AN+M+1，小 明想知道在所有由这N 个加号、M 个减号以及N + M +1 个整数凑出的合法的 后缀表达式中，结果最大的是哪一个？请你输出这个最大的结果。 例如使用1 2 3 + -，则“2 3 + 1 -” 这个后缀表达式结果是4，是最大的。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-suffix-expression/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 后缀表达式","uri":"/lqb-19-b-cplus-suffix-expression/"},{"categories":["蓝桥杯"],"content":"输入格式 第一行包含两个整数N 和M。 第二行包含N + M + 1 个整数A1; A2; …… ; AN+M+1。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-suffix-expression/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 后缀表达式","uri":"/lqb-19-b-cplus-suffix-expression/"},{"categories":["蓝桥杯"],"content":"输出格式 输出一个整数，代表答案。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-suffix-expression/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 后缀表达式","uri":"/lqb-19-b-cplus-suffix-expression/"},{"categories":["蓝桥杯"],"content":"样例输入 1 1 1 2 3 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-suffix-expression/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 后缀表达式","uri":"/lqb-19-b-cplus-suffix-expression/"},{"categories":["蓝桥杯"],"content":"样例输出 4 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-suffix-expression/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 后缀表达式","uri":"/lqb-19-b-cplus-suffix-expression/"},{"categories":["蓝桥杯"],"content":"评测用例规模与约定 对于所有评测用例，0 \u003c= N; M \u003e= 100000，109 \u003e= Ai \u003c= 109。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-suffix-expression/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 后缀表达式","uri":"/lqb-19-b-cplus-suffix-expression/"},{"categories":["蓝桥杯"],"content":"问题描述 数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一 部分的数列，只记得其中N 个整数。 现在给出这N 个整数，小明想知道包含这N 个整数的最短的等差数列有几项？ ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-arithmetic-series/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 等差数列","uri":"/lqb-19-b-cplus-arithmetic-series/"},{"categories":["蓝桥杯"],"content":"输入格式 输入的第一行包含一个整数N。 第二行包含N 个整数A1; A2; …… ; AN。(注意A1 ~AN 并不一定是按等差数 列中的顺序给出) ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-arithmetic-series/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 等差数列","uri":"/lqb-19-b-cplus-arithmetic-series/"},{"categories":["蓝桥杯"],"content":"输出格式 输出一个整数表示答案。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-arithmetic-series/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 等差数列","uri":"/lqb-19-b-cplus-arithmetic-series/"},{"categories":["蓝桥杯"],"content":"样例输入 5 2 6 4 10 20 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-arithmetic-series/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 等差数列","uri":"/lqb-19-b-cplus-arithmetic-series/"},{"categories":["蓝桥杯"],"content":"样例输出 10 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-arithmetic-series/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 等差数列","uri":"/lqb-19-b-cplus-arithmetic-series/"},{"categories":["蓝桥杯"],"content":"样例说明 包含2、6、4、10、20 的最短的等差数列是2、4、6、8、10、12、14、16、 18、20。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-arithmetic-series/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 等差数列","uri":"/lqb-19-b-cplus-arithmetic-series/"},{"categories":["蓝桥杯"],"content":"评测用例规模与约定 对于所有评测用例，2 \u003c= N \u003c= 100000，0 \u003c= Ai \u003c= 109。 #include\u003ccstdio\u003e #include\u003ccstdlib\u003e #include\u003ccstring\u003e #include\u003ccmath\u003e #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cstring\u003e #include\u003cvector\u003e #include\u003cqueue\u003e #include\u003cmap\u003e #include\u003cset\u003e using namespace std; #define N 100005 int num[N]={0},d[N]={0}; int gcd(int a,int b) { return (b\u003e0)?gcd(b,a%b):a; } int main() { int n; scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++) scanf(\"%d\",\u0026num[i]); sort(num,num+n); bool zero=false; for(int i=0;i\u003cn-1;i++) { d[i]=num[i+1]-num[i]; if(d[i]==0) { zero=true; break; } } if(zero)//常数数列 printf(\"%d\\n\",n); else { int mind=gcd(d[0],d[1]); for(int i=2;i\u003cn-1;i++) mind=gcd(mind,d[i]); printf(\"%d\\n\",(num[n-1]-num[0])/mind+1); } return 0; } ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-arithmetic-series/:7:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 等差数列","uri":"/lqb-19-b-cplus-arithmetic-series/"},{"categories":["蓝桥杯"],"content":"问题描述 给定一棵包含N 个节点的完全二叉树，树上每个节点都有一个权值，按从 上到下、从左到右的顺序依次是A1, A2,…… AN，如下图所示： 现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点 权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。 注：根的深度是1。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-binary-tree/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 完全二叉树的权值","uri":"/lqb-19-b-cplus-binary-tree/"},{"categories":["蓝桥杯"],"content":"输入格式 第一行包含一个整数N。 第二行包含N 个整数A1, A2, …… AN 。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-binary-tree/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 完全二叉树的权值","uri":"/lqb-19-b-cplus-binary-tree/"},{"categories":["蓝桥杯"],"content":"输出格式 输出一个整数代表答案。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-binary-tree/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 完全二叉树的权值","uri":"/lqb-19-b-cplus-binary-tree/"},{"categories":["蓝桥杯"],"content":"样例输入 7 1 6 5 4 3 2 1 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-binary-tree/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 完全二叉树的权值","uri":"/lqb-19-b-cplus-binary-tree/"},{"categories":["蓝桥杯"],"content":"样例输出 2 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-binary-tree/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 完全二叉树的权值","uri":"/lqb-19-b-cplus-binary-tree/"},{"categories":["蓝桥杯"],"content":"评测用例规模与约定 对于所有评测用例，1 \u003c= N \u003c= 100000，100000 \u003c= Ai \u003c=100000。 #include\u003ccstdio\u003e #include\u003ccstdlib\u003e #include\u003ccstring\u003e #include\u003ccmath\u003e #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cstring\u003e #include\u003cvector\u003e #include\u003cqueue\u003e #include\u003cmap\u003e #include\u003cset\u003e using namespace std; #define INF 0x3f3f3f3f #define N 100005 int num[N]={0}; int main() { int n; scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++) scanf(\"%d\",\u0026num[i]); int ans=1,k=0,max=-INF; for(int i=1;i\u003c=ceil(log(n+1)/log(2));i++) { int sum=0; for(int j=0;j\u003cpow(2,i-1);j++) sum+=num[k++]; if(sum\u003emax) { max=sum; ans=i; } } printf(\"%d\\n\",ans); return 0; } ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-binary-tree/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 完全二叉树的权值","uri":"/lqb-19-b-cplus-binary-tree/"},{"categories":["蓝桥杯"],"content":"问题描述 小明对数位中含有2、0、1、9 的数字很感兴趣（不包括前导0），在1 到 40 中这样的数包括1、2、9、10 至32、39 和40，共28 个，他们的和是574。 请问，在1 到n 中，所有这样的数的和是多少？ ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-special-numbers-sum/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 特别数的和","uri":"/lqb-19-b-cplus-special-numbers-sum/"},{"categories":["蓝桥杯"],"content":"输入格式 输入一行包含两个整数n。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-special-numbers-sum/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 特别数的和","uri":"/lqb-19-b-cplus-special-numbers-sum/"},{"categories":["蓝桥杯"],"content":"输出格式 输出一行，包含一个整数，表示满足条件的数的和。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-special-numbers-sum/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 特别数的和","uri":"/lqb-19-b-cplus-special-numbers-sum/"},{"categories":["蓝桥杯"],"content":"样例输入 40 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-special-numbers-sum/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 特别数的和","uri":"/lqb-19-b-cplus-special-numbers-sum/"},{"categories":["蓝桥杯"],"content":"样例输出 574 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-special-numbers-sum/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 特别数的和","uri":"/lqb-19-b-cplus-special-numbers-sum/"},{"categories":["蓝桥杯"],"content":"评测用例规模与约定 对于20% 的评测用例，1\u003c= n \u003c= 10。 对于50% 的评测用例，1\u003c= n \u003c=100。 对于80% 的评测用例，1\u003c= n \u003c=1000。 对于所有评测用例， 1\u003c=n \u003c=10000。 #include\u003ccstdio\u003e #include\u003ccstdlib\u003e #include\u003ccstring\u003e #include\u003ccmath\u003e #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cstring\u003e #include\u003cvector\u003e #include\u003cqueue\u003e #include\u003cmap\u003e #include\u003cset\u003e using namespace std; bool check(int n) { while(n) { int t=n%10; if(t==2||t==0||t==1||t==9) return true; n/=10; } return false; } int main() { int n,ans=0; cin\u003e\u003en; for(int i=1;i\u003c=n;i++) { if(check(i)) ans+=i; } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-special-numbers-sum/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 特别数的和","uri":"/lqb-19-b-cplus-special-numbers-sum/"},{"categories":["蓝桥杯"],"content":"下图给出了一个迷宫的平面图，其中标记为1 的为障碍，标记为0 的为可 以通行的地方。 010000 000100 001001 110000 迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。 对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫， 一共10 步。其中D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（30 行50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。 请注意在字典序中D\u003cL\u003cR\u003cU。 01010101001011001001010110010110100100001000101010 00001000100000101010010000100000001001100110100101 01111011010010001000001101001011100011000000010000 01000000001010100011010000101000001010101011001011 00011111000000101000010010100010100000101100000000 11001000110101000010101100011010011010101011110111 00011011010101001001001010000001000101001110000000 10100000101000100110101010111110011000010000111010 00111000001010100001100010000001000101001100001001 11000110100001110010001001010101010101010001101000 00010000100100000101001010101110100010101010000101 11100100101001001000010000010101010100100100010100 00000010000000101011001111010001100000101010100011 10101010011100001000011000010110011110110100001000 10101010100001101010100101000010100000111011101001 10000000101100010000101100101101001011100000000100 10101001000000010100100001000100000100011110101001 00101001010101101001010100011010101101110000110101 11001010000100001100000010100101000001000111000010 00001000110000110101101000000100101001001000011101 10100101000101000000001110110010110101101010100001 00101000010000110101010000100010001001000100010101 10100001000110010001000010101001010101011111010010 00000100101000000110010100101001000001000000000010 11010000001001110111001001000011101001011011101000 00000110100010001000100000001000011101000000110011 10101000101000100010001111100010101001010000001000 10000010100101001010110000000100101010001011101000 00111100001000010000000110111000000001000000001011 10000001100111010111010001000110111010101101111000 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-maze/:0:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯-2019第十届蓝桥杯B组C++ 迷宫","uri":"/lqb-19-b-cplus-maze/"},{"categories":["蓝桥杯"],"content":"答案 DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR #include\u003ccstdio\u003e #include\u003ccstdlib\u003e #include\u003ccstring\u003e #include\u003ccmath\u003e #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cstring\u003e #include\u003cvector\u003e #include\u003cqueue\u003e #include\u003cset\u003e using namespace std; #define N 30 #define M 50 char map[N][M]; int dir[4][2]={{1,0},{0,-1},{0,1},{-1,0}};//D\u003cL\u003cR\u003cU char ch[4]={'D','L','R','U'}; int vis[N][M]={0}; struct point { int x,y; string road; point(int a,int b) { x=a; y=b; } }; void bfs() { queue\u003cpoint\u003e q; point p(0,0); p.road=\"\"; q.push(p); vis[0][0]=1; while(!q.empty()) { point t=q.front(); q.pop(); if(t.x==N-1\u0026\u0026t.y==M-1) { cout\u003c\u003ct.road\u003c\u003cendl; break; } for(int i=0;i\u003c4;i++) { int dx=t.x+dir[i][0]; int dy=t.y+dir[i][1]; if(dx\u003e=0\u0026\u0026dx\u003cN\u0026\u0026dy\u003e=0\u0026\u0026dy\u003cM) { if(map[dx][dy]=='0'\u0026\u0026!vis[dx][dy]) { point tt(dx,dy); tt.road=t.road+ch[i];//记录路径 q.push(tt); vis[dx][dy]=1; } } } } } int main() { for(int i=0;i\u003cN;i++) { for(int j=0;j\u003cM;j++) scanf(\"%c\",\u0026map[i][j]); getchar();//读掉回车 } bfs(); return 0; } ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-maze/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯-2019第十届蓝桥杯B组C++ 迷宫","uri":"/lqb-19-b-cplus-maze/"},{"categories":["蓝桥杯"],"content":"问题描述 把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法？ 注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和 1001+1000+18 被视为同一种。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-decom-of-num/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 数的分解","uri":"/lqb-19-b-cplus-decom-of-num/"},{"categories":["蓝桥杯"],"content":"答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-decom-of-num/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 数的分解","uri":"/lqb-19-b-cplus-decom-of-num/"},{"categories":["蓝桥杯"],"content":"答案 40785 #include\u003ccstdio\u003e #include\u003ccstdlib\u003e #include\u003ccstring\u003e #include\u003ccmath\u003e #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cstring\u003e #include\u003cvector\u003e #include\u003cqueue\u003e #include\u003cmap\u003e #include\u003cset\u003e using namespace std; bool check(int n) { while(n) { if(n%10==2||n%10==4) return false; n/=10; } return true; } int main() { int ans=0; for(int i=1;i\u003c2019;i++) { if(!check(i)) continue; for(int j=i+1;j\u003c2019;j++) { if(!check(j)) continue; for(int k=j+1;k\u003c2019;k++) { if(!check(k)) continue; if(i+j+k==2019) ans++; } } } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-decom-of-num/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 数的分解","uri":"/lqb-19-b-cplus-decom-of-num/"},{"categories":["蓝桥杯"],"content":"问题描述 给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求第 20190324 项的最后 4 位数字。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-sequence-sum/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 数列求值","uri":"/lqb-19-b-cplus-sequence-sum/"},{"categories":["蓝桥杯"],"content":"答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个 4 位整数（提示：答案的千位不为 0），在提交答案时只填写这个整数，填写多余的内容将无法得分。 ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-sequence-sum/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 数列求值","uri":"/lqb-19-b-cplus-sequence-sum/"},{"categories":["蓝桥杯"],"content":"答案 4659 #include\u003ccstdio\u003e #include\u003ccstdlib\u003e #include\u003ccstring\u003e #include\u003ccmath\u003e #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cstring\u003e #include\u003cvector\u003e #include\u003cqueue\u003e #include\u003cmap\u003e #include\u003cset\u003e using namespace std; #define MOD 10000 int num[20190324]={1,1,1}; int main() { for(int i=3;i\u003c20190324;i++) { num[i]=(num[i-3]+num[i-2])%MOD; num[i]=(num[i-1]+num[i])%MOD; } cout\u003c\u003cnum[20190323]\u003c\u003cendl; return 0; } ","date":"2019-04-01","objectID":"/lqb-19-b-cplus-sequence-sum/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 数列求值","uri":"/lqb-19-b-cplus-sequence-sum/"},{"categories":["蓝桥杯"],"content":"小明用字母A 对应数字1，B 对应2，以此类推，用Z 对应26。 对于27 以上的数字，小明用两位或更长位的字符串来对应，例如AA 对应27，AB 对 应28，AZ 对应52，LQ 对应329。 请问2019 对应的字符串是什么？ #include \u003ciostream\u003e using namespace std; void solve(int n) { if (!n) { return ; } solve(n / 26); cout \u003c\u003c (char)(n % 26 + 64); } int main() { solve(2019); return 0; } 答案：BYQ ","date":"2019-03-27","objectID":"/lqb-19-b-cplus-year-string/:0:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2019第十届蓝桥杯B组C++ 年号字串","uri":"/lqb-19-b-cplus-year-string/"},{"categories":["数据仓库与数据挖掘"],"content":"准备工作 AdventureWork各种版本下载链接： 此操作数据库版本为：2014版本。 ","date":"2019-03-27","objectID":"/data-mining-adventureworksdw/:1:0","tags":["数据仓库与数据挖掘"],"title":"数据仓库与数据挖掘 使用SQL语句实现AdventureWorksDW数据仓库的多维数据分析","uri":"/data-mining-adventureworksdw/"},{"categories":["数据仓库与数据挖掘"],"content":"切片操作 进行切片操作切片。选择地点维、产品维和时间维查看2012年3月份的销售额 SELECT DimProduct.EnglishProductName AS 产品名称, DimSalesTerritory.SalesTerritoryRegion AS 产品地区, MONTH(FactInternetSales.OrderDate) AS 月份, SUM(FactInternetSales.SalesAmount) AS 销售额 FROM DimProduct, DimSalesTerritory, FactInternetSales WHERE DimProduct.ProductKey = FactInternetSales.ProductKey AND DimSalesTerritory.SalesTerritoryKey = FactInternetSales.SalesTerritoryKey AND MONTH(FactInternetSales.OrderDate) = 3 AND YEAR(FactInternetSales.OrderDate) = 2012 GROUP BY DimProduct.EnglishProductName, DimSalesTerritory.SalesTerritoryRegion, MONTH(FactInternetSales.OrderDate); ","date":"2019-03-27","objectID":"/data-mining-adventureworksdw/:2:0","tags":["数据仓库与数据挖掘"],"title":"数据仓库与数据挖掘 使用SQL语句实现AdventureWorksDW数据仓库的多维数据分析","uri":"/data-mining-adventureworksdw/"},{"categories":["数据仓库与数据挖掘"],"content":"切块操作 切块操作切块。选择地点维、产品维和时间维查看2011年3月份和4月份的销售额 SELECT DimProduct.EnglishProductName AS 产品名称, DimSalesTerritory.SalesTerritoryRegion AS 产品地区, MONTH(FactInternetSales.OrderDate) AS 月份, SUM(FactInternetSales.SalesAmount) AS 销售额 FROM DimProduct, DimSalesTerritory, FactInternetSales WHERE DimProduct.ProductKey = FactInternetSales.ProductKey AND DimSalesTerritory.SalesTerritoryKey = FactInternetSales.SalesTerritoryKey AND MONTH(FactInternetSales.OrderDate)BETWEEN 5 and 7 AND YEAR(FactInternetSales.OrderDate) = 2012 GROUP BY DimProduct.EnglishProductName, DimSalesTerritory.SalesTerritoryRegion, MONTH(FactInternetSales.OrderDate); ","date":"2019-03-27","objectID":"/data-mining-adventureworksdw/:3:0","tags":["数据仓库与数据挖掘"],"title":"数据仓库与数据挖掘 使用SQL语句实现AdventureWorksDW数据仓库的多维数据分析","uri":"/data-mining-adventureworksdw/"},{"categories":["数据仓库与数据挖掘"],"content":"旋转操作 旋转操作旋转。选择地点维、产品维和时间维,以地区维为主视图查看销售额 SELECT DimSalesTerritory.SalesTerritoryRegion AS 产品地区, DimProduct.EnglishProductName AS 产品名称, YEAR(FactInternetSales.OrderDate) AS 年份, MONTH(FactInternetSales.OrderDate) AS 月份, SUM(FactInternetSales.SalesAmount) AS 销售额 FROM -- 产品表 DimProduct, -- 销售地区表 DimSalesTerritory, -- 销售量 FactInternetSales WHERE DimProduct.ProductKey = FactInternetSales.ProductKey AND DimSalesTerritory.SalesTerritoryKey = FactInternetSales.SalesTerritoryKey AND YEAR(FactInternetSales.OrderDate) = 2011 GROUP BY DimProduct.EnglishProductName, DimSalesTerritory.SalesTerritoryRegion, YEAR(FactInternetSales.OrderDate), MONTH(FactInternetSales.OrderDate); ","date":"2019-03-27","objectID":"/data-mining-adventureworksdw/:4:0","tags":["数据仓库与数据挖掘"],"title":"数据仓库与数据挖掘 使用SQL语句实现AdventureWorksDW数据仓库的多维数据分析","uri":"/data-mining-adventureworksdw/"},{"categories":["数据仓库与数据挖掘"],"content":"旋转+切块 SELECT DimSalesTerritory.SalesTerritoryRegion AS 产品地区, DimProduct.EnglishProductName AS 产品名称, YEAR(FactInternetSales.OrderDate) AS 年份, MONTH(FactInternetSales.OrderDate) AS 月份, SUM(FactInternetSales.SalesAmount) AS 销售额 FROM -- 产品表 DimProduct, -- 销售地区表 DimSalesTerritory, -- 销售量 FactInternetSales WHERE DimProduct.ProductKey = FactInternetSales.ProductKey AND DimSalesTerritory.SalesTerritoryKey = FactInternetSales.SalesTerritoryKey AND YEAR(FactInternetSales.OrderDate) BETWEEN 2011 AND 2014 GROUP BY DimProduct.EnglishProductName, DimSalesTerritory.SalesTerritoryRegion, YEAR(FactInternetSales.OrderDate), MONTH(FactInternetSales.OrderDate); ","date":"2019-03-27","objectID":"/data-mining-adventureworksdw/:5:0","tags":["数据仓库与数据挖掘"],"title":"数据仓库与数据挖掘 使用SQL语句实现AdventureWorksDW数据仓库的多维数据分析","uri":"/data-mining-adventureworksdw/"},{"categories":["数据仓库与数据挖掘"],"content":"上钻操作 上钻。选择地点维、产品维和时间维查看不同年份的销售额 SELECT DimProduct.EnglishProductName AS 产品名称, DimSalesTerritory.SalesTerritoryRegion AS 产品地区, MONTH(FactInternetSales.OrderDate) AS 月份, SUM(FactInternetSales.SalesAmount) AS 销售额 FROM DimProduct, DimSalesTerritory, FactInternetSales WHERE DimProduct.ProductKey = FactInternetSales.ProductKey AND DimSalesTerritory.SalesTerritoryKey = FactInternetSales.SalesTerritoryKey GROUP BY DimProduct.EnglishProductName, DimSalesTerritory.SalesTerritoryRegion, MONTH(FactInternetSales.OrderDate); ","date":"2019-03-27","objectID":"/data-mining-adventureworksdw/:6:0","tags":["数据仓库与数据挖掘"],"title":"数据仓库与数据挖掘 使用SQL语句实现AdventureWorksDW数据仓库的多维数据分析","uri":"/data-mining-adventureworksdw/"},{"categories":["数据仓库与数据挖掘"],"content":"下钻操作 下钻。选择地点维、产品维和时间维查看不同日期的销售额 SELECT DimProduct.EnglishProductName AS 产品名称, DimSalesTerritory.SalesTerritoryRegion AS 产品地区, MONTH(FactInternetSales.OrderDate) AS 月份, SUM(FactInternetSales.SalesAmount) AS 销售额 FROM DimProduct, DimSalesTerritory, FactInternetSales WHERE DimProduct.ProductKey = FactInternetSales.ProductKey GROUP BY DimProduct.EnglishProductName, DimSalesTerritory.SalesTerritoryRegion, MONTH(FactInternetSales.OrderDate); ","date":"2019-03-27","objectID":"/data-mining-adventureworksdw/:7:0","tags":["数据仓库与数据挖掘"],"title":"数据仓库与数据挖掘 使用SQL语句实现AdventureWorksDW数据仓库的多维数据分析","uri":"/data-mining-adventureworksdw/"},{"categories":["软件工程"],"content":" UML定义了5类，10种模型图： 1.用例图：从用户角度描述系统功能，并指各功能的操作者。 2.静态图：包括类图，包图，对象图。 类图：描述系统中类的静态结构 包图：是包和类组成的，表示包与包之间的关系，包图描述系统的分层结构 对象图：是类图的实例 3.行为图：描述系统动态模型和对象组成的交换关系。包括状态图和活动图 活动图：描述了业务实现用例的工作流程 状态图：是描述状态到状态控制流，常用于动态特性建模 4.交互图：描述对象之间的交互关系 顺序图：对象之间的动态合作关系，强调对象发送消息的顺序，同时显示对象之间的交互 合作图：描述对象之间的协助关系 5.实现图： 配置图：定义系统中软硬件的物理体系结构 1、下面哪个不是活动图中的基本元素（ D ） A）状态、分支 B）转移、汇合 C）泳道、转移 D）用例、状态 活动、起始状态与终止状态、状态转移、判断、分叉与汇和、泳道 活动图的基本要素 2、 在下面的图例中，哪个用来描述活动（activity）（A） 3、下面哪个不是UML中的静态视图_____B______。 A.用例图 B.活动图 C.对象图 D.类图 4、下列关于活动图的说法错误的是______C_______ A一张活动图从本质上说是一个流程图，显示从活动到活动的控制流 B 活动图用于对业务过程中顺序和并发的工作流程进行建模。 C活动图中的基本要素包括活动节点、分支、分叉和汇合、泳道、对象流。 D活动图是UML中用于对系统的静态建模图 5、______A______技术是将一个活动图中的活动状态进行分组，每一组表示一个特定的类、人或部门，他们负责完成组内的活动。 A、泳道 B、分叉汇合 C、分支 D、转移 6、活动图的建模关键是表示出____B______，其它的建模元素都是围绕这一宗旨所进行的补充 A、控制流 B、数据流 C、状态 D、对象之间的关系 7、活动图利用_____C_____和_________来用来建模并发活动 A、分叉 监护条件 B、分支 监护条件 C、分叉 汇合 D、分支 汇合 8、 C 是UML中对系统动态方面建模的两种主要形式 A、活动图 类图 B、交互图 类图 C、活动图 交互图 D、状态图 用例图 9、活动图的___B____元素代表活动连接输入、输出值的连接点 A、转换 B、引脚 C、起始节点 D、泳道 引脚是一个对象节点，代表活动连接输入、输出值的连接点 UML之活动图 10、一个活动图中开始状态能有__A___个，结束状态能有________个。 A、1个 多个 B、1个 1个 C、多个 多个 D、多个 1个 11、UML的（ C ）模型图由活动图、顺序图、状态图和合作图组成。 A．用例 B．静态 C．动态 D．系统 12、要对一个企业的工作流程建模，下面4种图中的（ B ）是最重要的。 A 交互图 B 活动图 C 状态图 D 类图 13、使用UML对系统进行动态建模，不能使用以下哪种图（ A ） A 类图 B 顺序图 C 状态图 D 活动图 静态图：包括类图，包图，对象图。 14、如果要对一个学校课程表管理系统的主要角色学生，老师的工作流程建模，需要使用的图是（C） A．序列图 B．状态图 C．活动图 D．协作图 15、下列对活动图的描述不正确的是（B） A．活动图是对象之间传送消息的时间顺序的可视化表示，目的在于描述系统中各个对象按照时间顺序的交互的过程 B．活动图是一种用于描述系统行为的模型视图，它可用来描述动作和动作导致对象状态改变的结果 C．活动图是模型中的完整单元，表示一个程序或工作流 ，常用于计算流程和工作流程建模 D．活动图可以算是状态图的一种变种并且活动图的符号与状态图的符号非常相似 16、活动图中结束状态使用（C ）表示 A．菱形 B．直线箭头 C．黑色实心圆 D．空心圆 17、下列说法不正确的是（B） A．对象流中的对象表示的不仅仅是对象自身，还表示了对象作为过程的一个状态存在 B．活动状态是原子性的，用来表示一个具有子结构的纯粹计算的执行 C．一个组合活动在表面上看是一个状态，但其本质确是一组子活动的概括 D．分支将转换路径分成多个部分，每一部分都有单独的监护条件和不同的结果 18、下面属于活动图组成要素的有（A） A．泳道 B．动作状态 C．转换 D．活动状态 ","date":"2019-03-21","objectID":"/test-software-activity-diagram/:0:0","tags":["软件工程"],"title":"软件工程 活动图习题","uri":"/test-software-activity-diagram/"},{"categories":["蓝桥杯"],"content":"最大公共子串长度问题就是： 求两个串的所有子串中能够匹配上的最大长度是多少。 比如：“abcdkkk” 和 “baabcdadabc”， 可以找到的最长的公共子串是\"abcd\",所以最大公共子串长度为4。 下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。 请分析该解法的思路，并补全划线部分缺失的代码。 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #define N 256 int f(const char* s1, const char* s2) { int a[N][N]; int len1 = strlen(s1); int len2 = strlen(s2); int i,j; memset(a,0,sizeof(int)*N*N); int max = 0; for(i=1; i\u003c=len1; i++){ for(j=1; j\u003c=len2; j++){ if(s1[i-1]==s2[j-1]) { a[i][j] = __________________________; //填空 if(a[i][j] \u003e max) max = a[i][j]; } } } return max; } int main() { printf(\"%d\\n\", f(\"abcdkkk\", \"baabcdadabc\")); return 0; } 注意：只提交缺少的代码，不要提交已有的代码和符号。也不要提交说明性文字。 代码答案 a[i-1][j-1] + 1 Congruent prime sequence ","date":"2019-03-20","objectID":"/lqb-19-b-cplus-max-common-substring/:0:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题6 最大公共子串","uri":"/lqb-19-b-cplus-max-common-substring/"},{"categories":["蓝桥杯"],"content":"求1个整数的第k位数字有很多种方法。 以下的方法就是一种。 // 求x用10进制表示时的数位长度 int len(int x){ if(x\u003c10) return 1; return len(x/10)+1; } // 取x的第k位数字 int f(int x, int k){ if(len(x)-k==0) return x%10; return _____________________; //填空 } int main() { int x = 23574; printf(\"%d\\n\", f(x,3)); return 0; } 对于题目中的测试数据，应该打印5。 请仔细分析源码，并补充划线部分所缺少的代码。 注意：只提交缺失的代码，不要填写任何已有内容或说明性的文字。 ","date":"2019-03-19","objectID":"/lqb-19-b-cplus-take-digits/:0:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题5 取数位","uri":"/lqb-19-b-cplus-take-digits/"},{"categories":["蓝桥杯"],"content":"解题算法 #include \"iostream\" #include \"algorithm\" // 求x用10进制表示时的数位长度 int len(int x){ if(x\u003c10) return 1; return len(x/10)+1; } // 取x的第k位数字 int f(int x, int k){ if(len(x)-k==0) return x%10; return f(x/10, k); //填空 } int main() { int x = 23574; printf(\"%d\\n\", f(x,3)); return 0; } ","date":"2019-03-19","objectID":"/lqb-19-b-cplus-take-digits/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题5 取数位","uri":"/lqb-19-b-cplus-take-digits/"},{"categories":["蓝桥杯"],"content":"解题答案 f(x/10, k) ","date":"2019-03-19","objectID":"/lqb-19-b-cplus-take-digits/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题5 取数位","uri":"/lqb-19-b-cplus-take-digits/"},{"categories":["蓝桥杯"],"content":"X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。 每块金属原料的外形、尺寸完全一致，但重量不同。 金属材料被严格地堆放成金字塔形。 7 5 8 7 8 8 9 2 7 2 8 1 4 9 1 8 1 8 8 4 1 7 9 6 1 4 5 4 5 6 5 5 6 9 5 6 5 5 4 7 9 3 5 5 1 7 5 7 9 7 4 7 3 3 1 4 6 4 5 5 8 8 3 2 4 3 1 1 3 3 1 6 6 5 5 4 4 2 9 9 9 2 1 9 1 9 2 9 5 7 9 4 3 3 7 7 9 3 6 1 3 8 8 3 7 3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 其中的数字代表金属块的重量（计量单位较大）。 最下一层的X代表30台极高精度的电子秤。 假设每块原料的重量都十分精确地平均落在下方的两个金属块上， 最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。 电子秤的计量单位很小，所以显示的数字很大。 工作人员发现，其中读数最小的电子秤的示数为：2086458231 请你推算出：读数最大的电子秤的示数为多少？ 注意：需要提交的是一个整数，不要填写任何多余的内容。 ","date":"2019-03-19","objectID":"/lpb-19-b-cplus-bear-pre-calc/:0:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题3 承压计算","uri":"/lpb-19-b-cplus-bear-pre-calc/"},{"categories":["蓝桥杯"],"content":"格式化金字塔 将金字塔转化为二维数组形式，见下图： {7}, {5,8}, {7,8,8}, {9,2,7,2}, {8,1,4,9,1}, {8,1,8,8,4,1}, {7,9,6,1,4,5,4}, {5,6,5,5,6,9,5,6}, {5,5,4,7,9,3,5,5,1}, {7,5,7,9,7,4,7,3,3,1}, {4,6,4,5,5,8,8,3,2,4,3}, {1,1,3,3,1,6,6,5,5,4,4,2}, {9,9,9,2,1,9,1,9,2,9,5,7,9}, {4,3,3,7,7,9,3,6,1,3,8,8,3,7}, {3,6,8,1,5,3,9,5,8,3,8,1,8,3,3}, {8,3,2,3,3,5,5,8,5,4,2,8,6,7,6,9}, {8,1,8,1,8,4,6,2,2,1,7,9,4,2,3,3,4}, {2,8,4,2,2,9,9,2,8,3,4,9,6,3,9,4,6,9}, {7,9,7,4,9,7,6,6,2,8,9,4,1,8,1,7,2,1,6}, {9,2,8,6,4,2,7,9,5,4,1,2,5,1,7,3,9,8,3,3}, {5,2,1,6,7,9,3,2,8,9,5,5,6,6,6,2,1,8,7,9,9}, {6,7,1,8,8,7,5,3,6,5,4,7,3,4,6,7,8,1,3,2,7,4}, {2,2,6,3,5,3,4,9,2,4,5,7,6,6,3,2,7,2,4,8,5,5,4}, {7,4,4,5,8,3,3,8,1,8,6,3,2,1,6,2,6,4,6,3,8,2,9,6}, {1,2,4,1,3,3,5,3,4,9,6,3,8,6,5,9,1,5,3,2,6,8,8,5,3}, {2,2,7,9,3,3,2,8,6,9,8,4,4,9,5,8,2,6,3,4,8,4,9,3,8,8}, {7,7,7,9,7,5,2,7,9,2,5,1,9,2,6,5,3,9,3,5,7,3,5,4,2,8,9}, {7,7,6,6,8,7,5,5,8,2,4,7,7,4,7,2,6,9,2,1,8,2,9,8,5,7,3,6}, {5,9,4,5,5,7,5,5,6,3,5,3,9,5,8,9,5,4,1,2,6,1,4,3,5,3,2,4,1} ","date":"2019-03-19","objectID":"/lpb-19-b-cplus-bear-pre-calc/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题3 承压计算","uri":"/lpb-19-b-cplus-bear-pre-calc/"},{"categories":["蓝桥杯"],"content":"解题算法 #include \"iostream\" #include \"algorithm\" double a[30][30]{ {7}, {5,8}, {7,8,8}, {9,2,7,2}, {8,1,4,9,1}, {8,1,8,8,4,1}, {7,9,6,1,4,5,4}, {5,6,5,5,6,9,5,6}, {5,5,4,7,9,3,5,5,1}, {7,5,7,9,7,4,7,3,3,1}, {4,6,4,5,5,8,8,3,2,4,3}, {1,1,3,3,1,6,6,5,5,4,4,2}, {9,9,9,2,1,9,1,9,2,9,5,7,9}, {4,3,3,7,7,9,3,6,1,3,8,8,3,7}, {3,6,8,1,5,3,9,5,8,3,8,1,8,3,3}, {8,3,2,3,3,5,5,8,5,4,2,8,6,7,6,9}, {8,1,8,1,8,4,6,2,2,1,7,9,4,2,3,3,4}, {2,8,4,2,2,9,9,2,8,3,4,9,6,3,9,4,6,9}, {7,9,7,4,9,7,6,6,2,8,9,4,1,8,1,7,2,1,6}, {9,2,8,6,4,2,7,9,5,4,1,2,5,1,7,3,9,8,3,3}, {5,2,1,6,7,9,3,2,8,9,5,5,6,6,6,2,1,8,7,9,9}, {6,7,1,8,8,7,5,3,6,5,4,7,3,4,6,7,8,1,3,2,7,4}, {2,2,6,3,5,3,4,9,2,4,5,7,6,6,3,2,7,2,4,8,5,5,4}, {7,4,4,5,8,3,3,8,1,8,6,3,2,1,6,2,6,4,6,3,8,2,9,6}, {1,2,4,1,3,3,5,3,4,9,6,3,8,6,5,9,1,5,3,2,6,8,8,5,3}, {2,2,7,9,3,3,2,8,6,9,8,4,4,9,5,8,2,6,3,4,8,4,9,3,8,8}, {7,7,7,9,7,5,2,7,9,2,5,1,9,2,6,5,3,9,3,5,7,3,5,4,2,8,9}, {7,7,6,6,8,7,5,5,8,2,4,7,7,4,7,2,6,9,2,1,8,2,9,8,5,7,3,6}, {5,9,4,5,5,7,5,5,6,3,5,3,9,5,8,9,5,4,1,2,6,1,4,3,5,3,2,4,1} }; int main(){ int i, j; double max=0, min=9999999; double result; for(i=1; i\u003c=29; i++){ for(j=0; j\u003c=i; j++){ //如果为首尾两个数值话，直接自身/2运算 if(j==0){ a[i][j] += a[i-1][0]/2.0; }else{ //正常两个数值进行向下除法加法运算 a[i][j] += a[i-1][j-1]/2.0 + a[i-1][j]/2.0; } } } for(i=0; i\u003c=29; i++){ if(a[29][i]\u003cmin){ min = a[29][i]; } if(a[29][i]\u003emax){ max = a[29][i]; } } printf(\"%lf\\n\",2086458231/min*max); return 0; } ","date":"2019-03-19","objectID":"/lpb-19-b-cplus-bear-pre-calc/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题3 承压计算","uri":"/lpb-19-b-cplus-bear-pre-calc/"},{"categories":["蓝桥杯"],"content":"题解答案 72665192664 ","date":"2019-03-19","objectID":"/lpb-19-b-cplus-bear-pre-calc/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题3 承压计算","uri":"/lpb-19-b-cplus-bear-pre-calc/"},{"categories":["蓝桥杯"],"content":"2,3,5,7,11,13,….是素数序列。 类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。 上边的数列公差为30，长度为6。 2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！ 有这一理论为基础，请你借助手中的计算机，满怀信心地搜索： 长度为10的等差素数列，其公差最小值是多少？ 注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。 ","date":"2019-03-19","objectID":"/lqb-19-b-cplus-con-prime-sequence/:0:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题2 等差素数列","uri":"/lqb-19-b-cplus-con-prime-sequence/"},{"categories":["蓝桥杯"],"content":"解题算法 #include \"iostream\" #include \"algorithm\" using namespace std; typedef long long ll; bool isprime(int n){ //如果数值小于等于1并且大于二且为偶数 if(n\u003c=1 || (n\u003e2 \u0026\u0026 n%2==0)){ return false; } //查找最小公倍数对应的偶数序列，是否满足条件 for(ll i=3; i*i\u003c=n; i+=2){ if(n%i==0){ return false; } } return true; } int main(){ for(int d = 2; d\u003c1000; d++){ for(ll n = 2; n\u003c1000; ++n){ if( isprime(n) \u0026\u0026 isprime(n + d) \u0026\u0026 isprime(n + 2*d) \u0026\u0026 isprime(n + 3*d) \u0026\u0026 isprime(n + 4*d) \u0026\u0026 isprime(n + 5*d) \u0026\u0026 isprime(n + 6*d) \u0026\u0026 isprime(n + 7*d) \u0026\u0026 isprime(n + 8*d) \u0026\u0026 isprime(n + 9*d) ){ cout \u003c\u003c d \u003c\u003cendl; break; } } } return 0; } ","date":"2019-03-19","objectID":"/lqb-19-b-cplus-con-prime-sequence/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题2 等差素数列","uri":"/lqb-19-b-cplus-con-prime-sequence/"},{"categories":["蓝桥杯"],"content":"题解答案 210 ","date":"2019-03-19","objectID":"/lqb-19-b-cplus-con-prime-sequence/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题2 等差素数列","uri":"/lqb-19-b-cplus-con-prime-sequence/"},{"categories":["蓝桥杯"],"content":"问题描述 小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。 这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。 小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。 现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。 取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。 你的任务是计算出，小明最少需要取多少现金。 以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。 ----------------- **** 180.90 88折 **** 10.25 65折 **** 56.14 9折 **** 104.65 9折 **** 100.30 88折 **** 297.15 半价 **** 26.75 65折 **** 130.62 半价 **** 240.28 58折 **** 270.62 8折 **** 115.87 88折 **** 247.34 95折 **** 73.21 9折 **** 101.00 半价 **** 79.54 半价 **** 278.44 7折 **** 199.26 半价 **** 12.97 9折 **** 166.30 78折 **** 125.50 58折 **** 84.98 9折 **** 113.35 68折 **** 166.57 半价 **** 42.56 9折 **** 81.90 95折 **** 131.78 8折 **** 255.89 78折 **** 109.17 9折 **** 146.69 68折 **** 139.33 65折 **** 141.16 78折 **** 154.74 8折 **** 59.42 8折 **** 85.44 68折 **** 293.70 88折 **** 261.79 65折 **** 11.30 88折 **** 268.27 58折 **** 128.29 88折 **** 251.03 8折 **** 208.39 75折 **** 128.88 75折 **** 62.06 9折 **** 225.87 75折 **** 12.89 75折 **** 34.28 75折 **** 62.16 58折 **** 129.12 半价 **** 218.37 半价 **** 289.69 8折 -------------------- 需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。 特别地，半价是按50%计算。 请提交小明要从取款机上提取的金额，单位是元。 答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。 ","date":"2019-03-18","objectID":"/lqb-19-b-cplus-shopping-list/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题1 购物单","uri":"/lqb-19-b-cplus-shopping-list/"},{"categories":["蓝桥杯"],"content":"解题思路 其实这题就是送分的，不过就是送分了也是很容易丢分的，一不小心就少算了一个，分就没了，所以还是需要谨慎的。这个题目其实有好多的解法。 ","date":"2019-03-18","objectID":"/lqb-19-b-cplus-shopping-list/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题1 购物单","uri":"/lqb-19-b-cplus-shopping-list/"},{"categories":["蓝桥杯"],"content":"解题思路一 笨办法，就是将数值一个一个的输入并且用for循环进行sum求和运算，最后输出结果，不过不推荐，比较麻烦。 ","date":"2019-03-18","objectID":"/lqb-19-b-cplus-shopping-list/:2:1","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题1 购物单","uri":"/lqb-19-b-cplus-shopping-list/"},{"categories":["蓝桥杯"],"content":"解题思路二 相信在考试的机器中都存在Office这个神奇的软件，那么恭喜你，有了Excel这个软件，哈哈，将数值复制进去，拆分单元格，之后sum函数求和，最后得到你的结果，试试吧！ ","date":"2019-03-18","objectID":"/lqb-19-b-cplus-shopping-list/:2:2","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题1 购物单","uri":"/lqb-19-b-cplus-shopping-list/"},{"categories":["蓝桥杯"],"content":"解题答案 5200 ","date":"2019-03-18","objectID":"/lqb-19-b-cplus-shopping-list/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 2017年省赛C++B组题1 购物单","uri":"/lqb-19-b-cplus-shopping-list/"},{"categories":["软件工程"],"content":"甘特图（Gantt chart ）又叫横道图、条状图(Bar chart)。它是以图示的方式通过活动列表和时间刻度形象地表示出任何特定项目的活动顺序与持续时间。它是在第一次世界大战时期发明的，以亨利·L·甘特先生的名字命名，他制定了一个完整地用条形图表进度的标志系统。由于甘特图形象简单，在简单、短期的项目中，甘特图都得到了最广泛的运用。 首先，建立基本的图表框架和时间刻度日期。您还可以选择如何设置任务栏、里程碑和其他图表元素的格式。 稍后，您可以更改日期，添加或删除任务和里程碑，以及创建任务间的依赖关系。您还可以应用配色方案，以及添加标题和图例。 在 Visio 的“文件”菜单上，依次指向“新建”和“日程”，然后单击“甘特图”。 单击“日期”选项卡，然后选择所需的选项。 注释：“主要单位”是您要在图表中使用的最长时间单位（如年或月），“次要单位”是最短时间单位（如日或小时）。 在“格式”选项卡中单击要在任务栏、里程碑和摘要栏上使用的形状和标签，然后单击“确定”。 注释：如果您不确定要选择何种格式，接受默认选项即可。您可以在以后更改该格式。 ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:0:0","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["软件工程"],"content":"完成图表框架 建立甘特图后，将显示一个通用的图表框架。 该框架就像一幅空白画布，您可以在其上添加日程的详细信息： 在“任务名称”列中，单击某个单元格，键入特定的任务名称来代替通用文字。随着项目进展，您可以添加更多任务。 最初，“开始时间”和“完成时间”列中的日期反映了您为项目指定的开始日期。要更改该日期，请单击单元格，然后键入新日期。 “工期”列将随您键入的新开始日期和完成日期自动更新。您还可以键入开始日期和完成日期之一以及工期来指示任务的时间长度。 在“时间刻度”（标有“2000”的其下显示有月份的区域）中，“主要单位”显示在顶部，“次要单位”显示在底部。 时间刻度始于您指定的开始日期，止于您指定的完成日期。当您添加任务的开始日期和结束日期或工期时，任务栏将出现在时间刻度下面的区域中，且该区域将展开。 提示 要记录与每一任务有关的其他数据，您可以添加更多的列。例如，您可以添加“资源”列，以便您的甘特图反映出每个任务的负责人。 ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:1:0","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["软件工程"],"content":"给甘特图添加数据 您可以将反映项目日程详细信息的数据填入框架。还可以添加并优化以下日程元素： ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:2:0","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["软件工程"],"content":"任务 甘特图中的每个任务在图表框架中占用一行。当您在“任务名称”列的单元格中键入任务名称时，任务工期将表示为时间刻度下方区域中的任务栏。 目的 采取的操作 更改任务名称 单击包含该任务的“任务名称”列中的单元格，然后键入新名称。 设置或更改任务工期 在包含要更改日期或工期的甘特图框架中，单击单元格，然后键入新信息。 注释 根据以下规则键入工期：1h 表示 1 小时 1d 表示 1 天 1w 表示 1 周 1m 表示 1 个月 在甘特图底部添加新任务 通过单击围绕图表的实线，选择甘特图框架。要创建新的任务行，请拖动位于框架底部中央的绿色选择手柄。 在两个现有任务之间添加新任务 右键单击要在其上方显示新任务行的行中的任意单元格，然后单击快捷菜单中的“新建任务”。 给任务添加完成百分比指示器 右键单击要显示完成百分比列的位置左侧的列顶部的阴影部分，然后单击快捷菜单中的“插入列”。 在“列类型”下，单击“完成百分比”，然后单击“确定”。 随着任务的进展，在新列中键入任务的完成百分比。完成百分比指示器便会出现在任务栏中。 删除任务 右键单击表示要删除的任务的行中的任意单元格，然后单击快捷菜单中的“删除任务”。 更改任务栏的显示方式 右键单击任务栏，然后单击快捷菜单中的“任务选项”。在列表中单击所需选项，然后单击“确定”。 ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:2:1","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["软件工程"],"content":"里程碑 当您要在一个总括任务下合并若干附属任务时，可以使用摘要任务。 目的 采取的操作 创建带有附属任务的摘要任务 给甘特图添加摘要任务和附属任务或里程碑。 要选择附属任务，请单击包含该任务名称的单元格。要选择多个任务，请在单击时按住 Shift。 右键单击其中一个选定的任务，然后单击快捷菜单中的“降级”。 设置摘要任务的工期 在表示第一个附属任务的行中，单击“开始时间”列中的单元格，然后键入该任务的开始日期。 对于同一个附属任务，单击“完成时间”列中的单元格，然后键入该任务的结束日期。 对每个附属任务重复第 1 步和第 2 步。 注释 在为所有附属任务添加任务工期信息后，摘要任务的工期会自动填入。 降低任务级别（降级） 右键单击要降级的任务的名称，然后单击快捷菜单中的“降级”。 提升任务级别（升级） 右键单击要提升的任务的名称，然后单击快捷菜单中的“升级”。 更改摘要任务栏的显示方式 右键单击要更改的摘要任务的任务栏，然后单击快捷菜单中的“任务选项”。 在“摘要栏”下，选择摘要栏开头和结尾要使用的符号，然后单击“确定”。 ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:3:0","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["软件工程"],"content":"依赖关系（链接任务） 当您在甘特图中创建依赖另一个任务的任务时，一个箭头将把两个任务栏连接起来。如果更改另一个任务所依赖的任务的日期或工期，则依赖任务的日期也会随之更改。 目的 采取的操作 设置任务之间的依赖关系 通过单击包含任务名称的单元格，选择要在其间建立依赖关系的任务和里程碑。要选择多个任务，请在选择时按住 Shift。 右键单击所选任务之一，然后单击快捷菜单中的“链接任务”。 中断任务之间的依赖关系 通过单击包含任务名称的单元格，选择带有要断开依赖关系的任务。要选择多个任务，请在选择时按住 Shift。 右键单击其中一个选定的任务，然后单击快捷菜单中的“取消链接任务”。 更改依赖关系箭头的样式 打开甘特图，右键单击绘图页，然后单击快捷菜单中的“S 型连接线”。 ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:4:0","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["软件工程"],"content":"数据列 项目日程是根据特定于任务的数据创建的。任务开始日期和工期这两个因素综合在一起决定项目的完成日期。在 Visio 甘特图中，任务数据存储在数据列中。如果要在甘特图中记录并显示其他任务数据，可以添加新列。例如，您可能要添加任务注释列，您可以在其中说明复杂的任务或独特的任务；添加资源列以列出负责完成每个任务的人员；或添加完成百分比列以跟踪每个任务已完成的百分比。 默认情况下，新的甘特图在创建时将包含“任务名称”列、“开始时间”列、“完成时间”列和“工期”列。您可以重新安排现有列、添加新列或删除不再需要的列。 目的 采取的操作 重命名现有列 单击要重命名列的标题，然后键入新名称。 添加预先设计的新数据列 右键单击要显示新列的位置左侧的列标题，然后单击快捷菜单中的“插入列”。 在“列类型”列表中，单击与要添加的数据类型相对应的列名称，然后单击“确定”。 添加您自己设计的新数据列 右键单击要显示新列的位置左侧的列标题，然后单击快捷菜单中的“插入列”。 在“列类型”列表中，单击与要使用的数据格式（例如，“用户定义的小数”、“用户定义的文本”或“用户定义的时间”）相对应的一个用户定义的列，然后单击“确定”。为列键入新的名称。 注释 如果添加多个文本列，请每次选择不同的用户定义文本选项。例如，为第一列单击“用户定义的文本 1”，为第二列选择“用户定义的文本 2”，依此类推。 删除（隐藏）数据列 右键单击要删除（隐藏）的列的标题，然后单击快捷菜单中的“隐藏列”。 注释 删除或隐藏图表中的列时，该列中的数据将保存到文件中。如果以后要再次显示该列，请右键单击列标题，然后单击快捷菜单中的“插入列”。在列表中选择要再次显示的列，然后单击“确定”。 移动数据列 单击移动的列的标题。 将列拖到新的位置。 请执行下列操作之一： 要将一列移到另一列的左侧，请将要移动列的中点放置在另一列中点的左侧。 要将一列移到另一列右侧，请将要移动列的中点放置在另一列中点的右侧。 要将一列移到时间刻度区域的右侧，请将要移动列的中点放置在时间刻度区域中点的右侧。 注释 如果时间线刻度区域很长，您可能必须缩小视图，以便可以将该列移过该区域的中点。要缩小视图，请在“视图”菜单上指向“缩放比例”，然后单击所需的缩放级别。 ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:5:0","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["软件工程"],"content":"时间刻度 时间刻度是主要时间单位和次要时间单位的刻度，它将从项目的开始日期延伸到结束日期。您可以定义时间刻度的时间单位、开始日期和结束日期以及非工作日。 您可以滚动至时间刻度上特定的日期或任务，还可以更改时间刻度区域的宽度并显示更多的日期。 目的 采取的操作 更改开始日期和/或结束日期 在甘特图中，右键单击时间刻度中的任何部分，然后单击快捷菜单中的“日期选项”。 在“时间刻度范围”下，选择新的开始日期/时间或结束日期/时间，然后单击“确定”。 更改时间单位 在甘特图中，右键单击时间刻度中的任何部分，然后单击快捷菜单中的“日期选项”。 在“时间单位”下，选择所需的“主要单位”和“次要单位”，然后单击“确定”。 设置非工作日 在甘特图中，右键单击时间刻度中的任何部分，然后单击快捷菜单中的“配置工作时间”。 为“工作日”和“工作时间”选择所需选项，然后单击“确定”。 滚动至特定的任务或里程碑 通过单击包含任务名称的单元格，选择要滚动至的任务或里程碑。 在“甘特图”工具栏上，单击“滚动至任务”按钮。 注释 如果看不到“甘特图”工具栏，请在“视图”菜单上指向“工具栏”，然后单击“甘特图”。 滚动至特定日期 在甘特图中，右键单击时间刻度中的任何位置，然后单击快捷菜单中的以下选项之一：“滚动至完成日期”- 滚动至时间刻度的结束位置。 “向左滚动一个单位”- 向左滚动一个次要单位。 “向右滚动一个单位”- 向右滚动一个次要单位。 “滚动至开始日期”- 滚动至时间刻度的开始位置。 更改时间刻度区域的宽度 在时间刻度区域顶部的灰色区域中单击一次，然后再次单击，选择时间刻度列。 向任一个方向拖动列右侧的绿色选择手柄，直到区域的宽度满足您的要求。 显示更多时间单位 单击甘特图框架周围的实线以选择该框架。 向右拖动位于框架中心偏右侧的绿色选择手柄。 注释 当您展开时间刻度以显示更多时间单位时，还可以更改与项目相关的结束日期。 ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:6:0","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["软件工程"],"content":"打印大型甘特图 除非是为小项目创建日程，否则，您的甘特图很可能超出一页标准打印纸的边界。下表说明了您可能遇到的一些打印问题，以及为了获得所预期的效果在打印前可以采取的相应措施。 问题 解决方案 采取的操作 只打印了部分甘特图。 请确保整个图表适合绘图页的大小。 在“文件”菜单上，单击“页面设置”。 单击“页面大小”选项卡，单击“调整大小以适应绘图内容”，然后单击“确定”。 打印纸和绘图页的方向不同。 更改打印纸方向。 在“文件”菜单上，单击“页面设置”。 单击“打印设置”选项卡，单击所需的方向，然后单击“确定”。 您不知道甘特图打印时会占几页。 在打印绘图前预览其打印效果。 在“文件”菜单上，单击“打印预览”。 不知道分页符将出现在什么位置。 启用分页符，查看图表将平铺跨越多少张打印纸。 在“视图”菜单上，单击“分页符”。图表上的灰线表示进行分页的位置。 打印纸断开的位置不理想。 更改边距设置，以控制各页间的重叠。边距越大，页间的重叠越大。 在“文件”菜单上，单击“页面设置”。 在“打印设置”选项卡上，单击“设置”。 键入所需的边距设置，然后单击两次“确定”。 ","date":"2019-03-13","objectID":"/test-software-build-gantt-chart/:7:0","tags":["软件工程"],"title":"软件工程 怎样建立甘特图","uri":"/test-software-build-gantt-chart/"},{"categories":["蓝桥杯"],"content":"问题描述 已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。 ","date":"2019-03-05","objectID":"/lqb-19-b-cplus-max-min-multiple/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 最大最小公倍数","uri":"/lqb-19-b-cplus-max-min-multiple/"},{"categories":["蓝桥杯"],"content":"输入格式 输入一个正整数N。 ","date":"2019-03-05","objectID":"/lqb-19-b-cplus-max-min-multiple/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 最大最小公倍数","uri":"/lqb-19-b-cplus-max-min-multiple/"},{"categories":["蓝桥杯"],"content":"输出格式 输出一个整数，表示你找到的最小公倍数。 ","date":"2019-03-05","objectID":"/lqb-19-b-cplus-max-min-multiple/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 最大最小公倍数","uri":"/lqb-19-b-cplus-max-min-multiple/"},{"categories":["蓝桥杯"],"content":"样例输入 9 ","date":"2019-03-05","objectID":"/lqb-19-b-cplus-max-min-multiple/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 最大最小公倍数","uri":"/lqb-19-b-cplus-max-min-multiple/"},{"categories":["蓝桥杯"],"content":"样例输出 504 ","date":"2019-03-05","objectID":"/lqb-19-b-cplus-max-min-multiple/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 最大最小公倍数","uri":"/lqb-19-b-cplus-max-min-multiple/"},{"categories":["蓝桥杯"],"content":"数据规模与约定 1 \u003c= N \u003c= 106。 ","date":"2019-03-05","objectID":"/lqb-19-b-cplus-max-min-multiple/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 最大最小公倍数","uri":"/lqb-19-b-cplus-max-min-multiple/"},{"categories":["蓝桥杯"],"content":"算法分析 如果 n \u003c= 2, 那么最小公倍数为 n 如果 n 是奇数，那么最小公倍数的最大值为末尾的三个数相乘 如果是偶数的话，如果同时出现两个偶数肯定会不能构成最大值了，因为会被除以2分两种情况： 如果 n 是偶数且不是三的倍数， 比如8，那么跳过n-2这个数而选择 8 7 5 能保证不会最小公倍数被除以2所以最小公倍数的最大值为n * (n – 1) * (n – 3) 如果 n 是偶数且为三的倍数，比如6，如果还像上面那样选择的话，6和3相差3会被约去一个3，又不能构成最大值了。那么最小公倍数的最大值为(n – 1) * (n – 2) * (n – 3) ","date":"2019-03-05","objectID":"/lqb-19-b-cplus-max-min-multiple/:7:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 最大最小公倍数","uri":"/lqb-19-b-cplus-max-min-multiple/"},{"categories":["蓝桥杯"],"content":"C++算法 #include \"iostream\" #include \"algorithm\" using namespace std; int main(){ long long n, ans; cin \u003e\u003e n; if(n \u003c= 2){ ans = n; }else if(n%2 == 1){ ans = n * (n-1) * (n-2); }else if(n%3 == 0){ ans = (n-1) * (n-2) * (n-3); }else{ ans = n * (n-1) * (n-3); } cout \u003c\u003c ans; return 0; } ","date":"2019-03-05","objectID":"/lqb-19-b-cplus-max-min-multiple/:8:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 最大最小公倍数","uri":"/lqb-19-b-cplus-max-min-multiple/"},{"categories":["蓝桥杯"],"content":"问题描述 给定一个序列，每次询问序列中第l个数到第r个数中第K大的数是哪个。 ","date":"2019-03-04","objectID":"/lqb-19-b-cplus-k-num-query/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 区间k大数查询","uri":"/lqb-19-b-cplus-k-num-query/"},{"categories":["蓝桥杯"],"content":"输入格式 第一行包含一个数n，表示序列长度。 第二行包含n个正整数，表示给定的序列。 第三个包含一个正整数m，表示询问个数。 接下来m行，每行三个数l,r,K，表示询问序列从左往右第l个数到第r个数中，从大往小第K大的数是哪个。序列元素从1开始标号。输出格式总共输出m行，每行一个数，表示询问的答案。 ","date":"2019-03-04","objectID":"/lqb-19-b-cplus-k-num-query/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 区间k大数查询","uri":"/lqb-19-b-cplus-k-num-query/"},{"categories":["蓝桥杯"],"content":"样例输入 5 1 2 3 4 5 2 1 5 2 2 3 2 ","date":"2019-03-04","objectID":"/lqb-19-b-cplus-k-num-query/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 区间k大数查询","uri":"/lqb-19-b-cplus-k-num-query/"},{"categories":["蓝桥杯"],"content":"样例输出 4 2 ","date":"2019-03-04","objectID":"/lqb-19-b-cplus-k-num-query/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 区间k大数查询","uri":"/lqb-19-b-cplus-k-num-query/"},{"categories":["蓝桥杯"],"content":"数据规模与约定 对于30%的数据，n,m\u003c=100； 对于100%的数据，n,m\u003c=1000； 保证k\u003c=(r-l+1)，序列中的数\u003c=106。 ","date":"2019-03-04","objectID":"/lqb-19-b-cplus-k-num-query/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 区间k大数查询","uri":"/lqb-19-b-cplus-k-num-query/"},{"categories":["蓝桥杯"],"content":"C++算法解析 #include \"iostream\" #include \"algorithm\" using namespace std; int a[1001], b[1001]; bool cmp(int a, int b){ return a\u003eb; } int main(){ int n, m; int l, r, k; int i, j; while(cin\u003e\u003en){ for(i=0; i\u003cn; i++){ cin \u003e\u003e a[i]; } cin \u003e\u003e m; while(m--){ cin \u003e\u003el\u003e\u003er\u003e\u003ek; for(j=l-1, i=0; j\u003cr; ++j,++i){ b[i] = a[j]; } sort(b, b+i, cmp); cout\u003c\u003cb[k-1]\u003c\u003cendl; } } return 0; } ","date":"2019-03-04","objectID":"/lqb-19-b-cplus-k-num-query/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 算法训练 区间k大数查询","uri":"/lqb-19-b-cplus-k-num-query/"},{"categories":["summary"],"content":"看到别人翻译的一篇文章，是讨论如何提高博客访问量的，提到的有几个方法蛮有新意，不过不赞成原文的“在聚合中只输出摘要”的方法。 十四个方法提高博客的页面访问量 作者：Darren Rowse，翻译：Lucifer 如何增加Blog的访问量已经是老生长谈了，其实对于blogger来说另一个统计数也至关重要：页面浏览量。 很多的网站流量统计服务会同时提供这两项数据- “访问量”计数的是访问者的数目，而页面浏览量算的则是这些访问者所浏览的你blog上的网页的数目。 对不同blog来说，每个访问者的页面浏览量会有所不同，但希望这个数字可以大一总不是件坏事： 回头率：读者浏览的页面越多，那么他再次造访的可能性也就更大。 收入：放在blog上的广告多是印象型的，也就是说被浏览的次数多了，被点击的可能性才越大。 写 blog 的目的不同，所以想不想把增加页面浏览量放在第一位悉听尊便。对于那些希望这项统计值上升的人，这里有14条建议： ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:0:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"1 内链到自己的文章 这可能是最简单的增加页面流量的办法，那就是在自己文章里加入链接，指向自己的其它文章。自卖自夸可能有点好笑，不过如果是链接到一些之前写过的相关或相同主题的文章的话，相信还是读者们所喜闻乐见的。很多的blogger在自己的blog上会多次写到同一主题，把这些文章都链到一起无疑会显出你对这个主题的探讨深度。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:1:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"2 高亮显示相关的文章 不想在文章内部加入指向之前文章的链接的话，专门独立出一个“相关文章”(Related post)的部分就不失为一个好的替代方法了(你可以在侧栏里看到我的相关文章(related entries)，而原文作者，ProbBlogger的主人的相关文章则放在了每篇文章之后，并以黄色为背景以突出显示)。Wordpress有专门的插件可以自动实现这一功能(名为related posts)。当然你要是想手动实现也是可以的，只要在文章结尾处加进一些和本文相关的可供读者参考的文章链接就可以了。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:2:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"3 加入一个邮件订阅或文章更新提提示服务 原文作者就尝到了通过邮件订阅来提高页面浏览量的甜头，凡是通过邮件订阅的读者在收到ProBlogger的最新消息的同时都会留意到一个叫作“hot posts”的部分，在这个部分中整理收入了一周当中的最受欢迎的5篇文章。因为不同读者所关注的文章不同，所以很可能一些人只看过其中的某几篇文章，加入“hot posts”之后，这部分读者就会对没看过的那些文章产生兴趣。这样一来就在增加“访问量”的同时也增加了“页面浏览量”。其它的一些通过邮件提示更新的订阅服务应该也很有效(比如Zookoda和Feedburner就都有这个功能)。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:3:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"4 在醒目位置高亮显示重要文章 ProBlogger在页面的上部有三个高亮显示的菜单栏，里面放置了一些介绍或提示性质的文章，比如什么是blog，blog设计的窍门之类。而通过作者的观察很多读者都会认真地把这里的文章看过一遍。这样一来无疑就提高了页面量。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:4:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"5 “几大……” 这种“最…”或是“几几大…”的链接到多个页面的文章似乎总是会勾起读者的兴趣。比如“二十大最受欢迎文章”往往就成为初次造访的读者必看的文章，而这又指引着他们挨着个地去看，不失为一个好办法。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:5:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"6 写一个系列 写一系列的文章来提高页面量有着两层意义。首先在写这个系列的这段时间里，读者会不时地被吸引回来，因为他们想看看你下一篇文章写了些什么； 其次，在你完成了这个系列之后，如果能很好的把这些文章都链在一起(参考1和2)，这样一来读者就会从头到尾读完整个系列(当然是由多个页面组成的)。原文作者就写过一个初学者blog指南的系列，而每个从头到尾看完这个系列的读者都要看上30到40篇文章(汗)。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:6:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"7 在首页上输出摘要 在首页上只输出摘要或是只输出文章的一部分，然后通过一个“阅读完整文章”的链接链到单独的页面，这样一来想看完整文章的就得再去单独的页面。不得不说这样一来会很烦人，所以很多人都不这么做。不过对于篇幅长的文章来说，这么做不仅使首页看起来更严谨，也在无形中增加了页面量。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:7:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"8 企划或专题 和之前的系列文章相类似，比如很多主题(theme)设计者的blog就是通过建立某个主题的企划，从而吸引关注这个主题的人不时地来看看工作的进展情况。类似的比如开展讨论或者竞赛也可以达到相同的效果。不过这些牛人做这个的首要目的并不是区区页面量，页面量不过是副产品罢了。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:8:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"9 在聚合中只输出摘要 这是为我所不耻的。就连原文作者也不这么做。尽管这样一来你的页面访问可能会有所上升，但我觉得无论是对于读者还是作者来说都是得不偿失。在这样一个“你有压力，我有压力”的社会，每个人的时间都很宝贵，用聚合的目的就是节省时间和资源。所以我看到只输出摘要的blog就一个反应，把它从我的bloglines里删除。强烈建议所有的blogger都在聚合里都输出完整的文章! ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:9:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"10 诱使聚合读者访问页面 相比起输出摘要的做法，我觉得这个更可取。不是通过强迫，而是通过一些技巧，比如投票，吸引读者参与评论，或是内部链接的方式来把读者带到你的页面上来。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:10:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"11 互动 读者参与的越多，回访的机率也就越大，同时页面量也就越多。参与了评论或是投票的读者很多都会回访，来看看其他人的回应。而回应本身就带来了两次页面访问量。就留言评论来说，看一遍文章就是一次页面访问，而留个言就是又一次。同样的，最好不要把这个当成吸引留言的首要目的，交流才是根本啊。互动主要发生在留言部分，当然投票以及其它的工具也应该有效果。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:11:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"12 吸引读者的评论 有几个方法可以有效地达到这个目的：比如通过插件实现在侧栏里显示最新的评论，为评论提供一个专门的聚合，或是提供邮件订阅评论的选项。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:12:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"13 搜索 通过加入搜索功能从而方便读者检索你之前写的文章也可以提高页面量。有很多方法可以实现这一功能。大多数的主题都内建了一个搜索引擎，Google的AdSense也提供了这样的一个服务，读者可以选择搜索本站或是整个网络，而且如果他们在搜索结果页面点击了广告，那么还可以给你带来一点小小的外块。 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:13:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["summary"],"content":"14 给你的读者留作业 原文作者举了他的一个提供摄影技巧的blog为例，因为是为读者提供一些摄影的窍门，所以在文章的结尾布置一些“作业”以便让读者可以亲自去尝试就显得十分自然了。这样一来读者就会经常回访，一方面这种窍门或是教学多是一步步的，所以他们会经常打开你的页面，反复按照你的指导一步步地去做；另一方面，很多人都会想要向你展示一下他们的作业成果。 在文章的结尾，我也学着作者的样子留个作业吧： 你的blog上应用了以上的哪一项方法? 看过这篇文章之后你有没有想试试哪一个的想法? 试试其中的一个(或者几个)方法，然后告诉回来告诉我们效果怎么样。 原文地址：How to Increase a Blog’s Page Views 译文地址：十四个方法提高博客的页面访问量 ","date":"2019-02-28","objectID":"/debuginn-increase-visit/:14:0","tags":["技术","博文"],"title":"怎样提高博客的页面访问量","uri":"/debuginn-increase-visit/"},{"categories":["NCRE"],"content":"在不同类型的操作系统中，批处理操作系统的缺点是： 缺少交互性 页式存储管理方案中，若一个进程的虚拟地址空间为2GB，页面大小为4KB，当用4字节标识物理页号时，页表需要占用多少个页面？ 一个进程的虚拟地址空间为2GB，页面大小为4KB，则共有2*1024*1024/4个页表项； 每个页面用4个字节标识物理块号，则需要210241024/4*4大小的页表，由于每个页表为4KB，即2*1024*1024/4*4/（4*1024）=512个页面。 假设某文件由100个逻辑记录组成，每个逻辑记录长度为80个字符。磁盘空间被划分为若干块，块大小为1024字符。在没有采用成组操作时，磁盘空间的利用率为多少？ 在没有成组操作时，每一个记录占用一个块，那么磁盘空间的利用率为80/1024=8%. 假设某文件由100个逻辑记录组成，每个逻辑记录文件长度为80个字符。磁盘空间被划分为若干块，块大小为1024个字符。若才作用成组操作，块因子为12，那么磁盘空间的利用率为多少？ 若采用成组操作时，每12个记录占用一个块，那么磁盘空间的利用率为80*12/1024=94%。 下列关于死锁与安全状态的描述中，那个事正确的？ 死锁状态一定是不安全状态 在可变分区存储管理方案中，为加快内存分配，当采用最佳适应算法时空闲区的组织应该是：按空闲区大小递增顺序排列。 假设某文件系统的物理结构采用类UNIX的二级索引结构。主索引表有12项，前10项给出文件前10块的磁盘地址，第11项给出一级索引表的地址，第12项给出二级索引表的地址。一级和二级索引表的大小均为一个磁盘块，可存放100个磁盘地址。在找到主索引表之后，要访问文件的第1000块，还需要启动多少次磁盘？ 1~10块采用的是直接索引，需要启动磁盘1次； 11~110块采用的是一级索引，需要启动磁盘2次； 111~10110块采用的是二级索引，需要启动磁盘3次。 第1000块访问时，找到主索引后，需要启动磁盘2次。 在文件系统中，文件的逻辑块与存储介质上物理块存放顺序一致的物理结构是：顺序结构。 打开文件时，系统主要完成以下工作： ①根据文件路径名查目录，找到FCB主部； ②根据打开方式，共享说明和用户身份检查访问合法性； ③根据文件号查系统打开文件表，看文件是否已被打开； ④在用户打开文件表中取一空表项，填写打开方式等，并指向系统打开文件表对应表项。系统返回用户文件描述符fd，用于以后读写文件。 假设某文件系统的物理结构采用类UNIX的二级索引结构。主索引表有12项，前10项给出文件前10块的磁盘地址，第11项给出一级索引表的地址，第12项给出二级索引表的地址。一级和二级索引表的大小均为一个磁盘块，可存放100个磁盘地址。针对以上描述的文件系统，一个文件最大为多少块 直接索引磁盘块有10个， 采用一级索引的磁盘块有100个， 采用二级索引的磁盘块有100*100个，合计为10000个。 假设某文件系统的物理结构采用类UNIX的二级索引结构。主索引表有12项，前10项给出文件前10块的磁盘地址，第11项给出一级索引表的地址，第12项给出二级索引表的地址。一级和二级索引表的大小均为一个磁盘块，可存放100个磁盘地址。在找到主索引表之后，要访问文件的第1000块，还需要启动多少次磁盘？ 1~10块采用的是直接索引，需要启动磁盘1次；11~110块采用的是一级索引，需要启动磁盘2次；111~10110块采用的是二级索引，需要启动磁盘3次。第1000块访问时，找到主索引后，需要启动磁盘2次。 进程从运行态转换为阻塞态的原因是（ A ）。 A) 需要的数据没有准备好 B) 需要的设备不存在 C) 分配给该进程的时间片用完 D) 运算过程中栈溢出 一个运行着的进程打开了一个新的文件，则指向该文件数据结构的关键指针存放在（ D ）。 A) 文件目录中 B) 文件句柄中 C) 进程头文件中 D) 进程控制块中 进程控制块中的进程资源清单，列出所拥有的除CPU外的资源记录，如拥有的I/O设备，打开的文件列表等。 在内存分区管理中，下列哪一种技术可以将零碎的空闲区集中为一个大的空闲区（ C ）。 A) 覆盖技术 B) 交换技术 C) 内存紧缩 D) 动态重定位 解决碎片问题的办法是在适当时刻进行碎片整理，通过移动内存中的程序，把所有空闲碎片合并成一个连续的大空闲区并且放在内存的一端，而把所有程序放在另一端，这技术称为“移动技术”或“紧缩技术”。 在内存分配方案中，下列哪一种方法使内存的利用率较高且管理简单（ B ）。 A) 段式分配 B) 页式分配 C) 可变分区分配 D) 固定分区分配 页式分配的优点有： ① 由于它不要求作业或进程的程序段和数据在内存中连续存放，从而有效地解决了碎片问题。 ② 动态页式管理提供了内存和外存统一管理的虚存实现方式，使用户可以利用的存储空间大大增加。这既提高了主存的利用率，又有利于组织多道程序执行。 在一个虚拟存储系统中，决定虚拟存储空间最大容量的要素是（ A ）。 A) 计算机系统地址位宽 B) 计算机系统数据字长 C) 内存和磁盘容量之和 D) 交换空间容量 实现虚拟存储器需要系统有容量足够大的外存、系统有一定容量的外存，最主要的是，硬件提供实现虚-实地址映射的机制。在一个虚拟存储系统中，决定虚拟存储空间最大容量的要素是计算机系统地址位宽。 在虚拟页式存储管理系统中，若采用请求调页方式，当用户需要装入一个新的页面时，其调入的页面来自（磁盘文件区）。 UNIX操作系统中，对文件系统中空闲区的管理通常采用 成组链接法。 对于FAT32文件系统，它采用的是哪一种文件物理结构 链接结构。 关于操作系统的结构，下列特性中，哪一个不是微内核结构的特点（清晰的单向依赖和单向调用性）。 程序局部性原理分为空间局部性和时间局部性，空间局部性是指（程序代码的顺序性）。 程序的并发执行产生了一些和程序顺序执行时不同的特性(并发程序与计算过程无法一一对应)。 在Pthread线程包关于条件变量的使用中，pthread_mutex_init()表示的是（创建一个互斥量）。 init是初始化变量，和git操作初始化一致，小技巧 程序的并发执行产生了一些和程序顺序执行时不同的特性，下列哪一个特性是正确的（并发程序在执行期间具有相互制约关系）。 为了保证计算机中临界资源的正确使用，进程在对临界资源访问前，必须首先调用下列哪一区的代码（ 进入区 ）。 ","date":"2019-02-26","objectID":"/test-ncre-os-single-topic/:0:0","tags":["NCRE"],"title":"【NCRE四级网络工程师】操作系统单选题","uri":"/test-ncre-os-single-topic/"},{"categories":["NCRE"],"content":"保存在进程控制块中的是 进程标识符 进程当前状态 代码段指针 PCB的内容可以分为调度信息和现场信息两大部分。调度信息供进程调度时使用。调度信息供进程调度时使用，描述了进程当前所处的状态，包括进程名、进程号、存储信息、优先级、当前状态、资源清单、家族关系、消息队列指针、当前打开文件等。 下列关于地址映射的叙述中，正确的是： 地址映射过程通常是有硬件完成的； 地址映射是将虚拟地址转换为物理地址； 页表项的一些内容是由硬件决定的； 根据页表项的有效位确定所需访问的页面时都已经在内存。 下列对于块表的叙述中，正确的是： 块表的另一个名称是TLB 当切换进程时，要刷新快表； 快表存放在高速缓存中； 对块表的查找是按内容并行进行的。 下列各项中，那些事文件控制块中必须保存的信息？ 文件名 文件大小 文件创建时间 磁盘块起始地址 文件控制块FCB包括：文件名、用户名、文件号、文件地址、文件长度、文件类型、文件属性、共享技术、文件的建立日期、保存期限、最后修改日期、最后访问日期、口令、文件文件物理结构等等。 设计文件系统时应尽量减少访问磁盘的次数，以提高文件系统的性能。下列各项措施中，哪些可以提高文件系统的性能？ 块高速缓存 磁盘驱动调度 目录项分解法 设备与CPU之间的数据传送和控制方式有多种，他们是： 程序直接控制方式 中断控制方式 DMA方式 通道控制方式 当前测到系统发生死锁之后，解除死锁的方法是？ 剥夺某些进程所占有的资源； 撤销某些进程 从新启动系统 测试与设置指令（Test\u0026Set）是解决互斥访问临界区的硬件方法。下列关于该指令功能的叙述中，哪些是正确的 A) 测试W的值，若W=1，则返回重新测试 B) 测试W的值，若W=0，置位W=1，进入临界区 C) 退出临界区时，复位W=0 TS指令实现互斥的算法是：测试锁变量的值，如为1，则重复执行本命令，不断重复测试变量的值；如为0，则立即将锁变量测值置为1，进入临界区；测试并设置指令是一条完整的指令，而在一条指令的执行中间是不会被中断的，保证了锁的测试和关闭的连续性；退出临界区时，将锁变量测试值设为0。 下列关于虚拟存储器的叙述中，哪些是正确的？ 在虚拟存储系统中，进程的部分程序装入后便可运行 虚拟存储技术允许用户使用比物理内存更大的存储空间 实现虚存必须有硬件支持 段页式存储管理为用户提供了一个二维地址空间，满足程序和信息的逻辑分段的要求。其基本思想是用页式方法来分配和管理内存空间，即把内存划分为若干大小相等的页面。内存是以页为基本单位分配给每个用户程序的，逻辑上相邻的页面在物理内存中不一定相邻。内存空间最小的单位是页而不是段。页式存储管理的特征是等分内存，有效的克服了碎片，提高了存储器的利用率。 下列文件的物理结构中，哪些结构适合文件的随机存取 连续结构 索引结构 多级索引结构 在程序控制I/O方式中，若输出设备向处理机返回“准备就绪”信号，则表示（）。 输出缓冲区已空 可以向输出缓冲区写数据 在设备分配中，预防死锁的策略包括（）。 A) 建立SPOOLing系统 B) 一次分配所有资源 C) 有序分配资源 D) 剥夺其他进程的资源 在设计系统时确定资源分配算法，限制进程对资源的申请，从而保证不发生死锁。具体的做法是破坏产生死锁的四个必要条件之一： ①破坏“互斥条件”：可以通过采用假脱机（SPOOLing）技术，允许若干个进程同时输出； ②破坏“不可剥夺”条件：如果资源没有被等待进程占有，那么该进程必须等待，在其等待过程中，其资源也有可能被剥夺； ③破坏“请求和保持”条件：可以采用静态分配资源策略，将满足进程条件的资源一次性分配给进程，也可以采用动态资源分配，即需要资源时才提出申请，系统在进行分配； ④破坏“循环等待”条件：进程申请资源时，必须严格按照资源编号的顺序进行，否则系统不予分配。 下列关于进程的叙述中，哪些是正确的（ BC ）。 A) 一个进程的状态变化必定会引起另一个进程的状态变化 B) 信号量的初值一定大于等于零 C) 进程是资源分配的基本单位，线程是处理机调度的基本单位 D) 进程被挂起后，它的状态一定为阻塞态 E) 操作系统中引入P、V操作主要是为了解决死锁问题 在下列存储管理方案中，能支持多道程序设计的是（ ）。 A) 可变分区存储管理 B) 页式存储管理 C) 单一分区存储管理 D) 固定分区存储管理 E) 段页式存储管理 单一分区存储器管理，只充许一道程序独占内存空间，因此不能支持多道程序设计技术。 在计算机系统中，形成死锁的必要条件是（ ABCD ）。 A) 资源互斥使用 B) 部分分配资源 C) 已分配资源不可剥夺 D) 资源申请形成环路 E) 系统资源不足 当前Android操作系统应用广泛，它具有下列哪些特性（ BC ）。 A) 批处理 B) 移动应用 C) 支持网络 D) 分布式 E) 兼容性 下列关于进程控制块的叙述中，哪些是正确的（ ABC ）。 A) 进程控制块的英文缩写是PCB B) 每个进程都拥有自己的进程控制块 C) 进程控制块必须常驻内存 D) 进程控制块必须指明其兄弟进程的进程号 E) 进程创建完毕后，系统将其进程控制块插入等待队列 下列关于信号量使用的叙述中，哪些是正确的（ ABD ）。 A) 信号量初始化后，只能实施P、V原语操作 B) 在互斥信号量与同步信号量都使用的进程中，应先执行同步信号量的P操作 C) 在互斥信号量与同步信号量都使用的进程中，应先执行同步信号量的V操作 D) 信号量的初值不能小于0 E) 互斥信号量的变化范围只能是正整数 下列页面置换算法中，哪些算法需要用到访问位（引用位）（ CDE ）。 A) 先进先出算法FIFO B) 最佳置换算法OPT C) 最近最久未使用算法LRU D) 时钟算法CLOCK E) 最近未使用算法NRU 从简单页式存储管理方案发展到虚拟页式存储管理方案，页表项中通常需要增加的信息有：有效位，修改位，访问位。 SPOOLing系统的主要组成部分是（ ABC ）。 A) 输入井和输出井 B) 输入缓冲区和输出缓冲区 C) 输入进程和输出进程 D) 输入控制器和输出控制器 E) 输入分配器和互斥分配器 下列关于死锁的叙述中，哪些是正确的（ ABC ）。 A) 死锁产生的原因是进程推进顺序不当 B) 环路是死锁产生的必要条件 C) 采用银行家算法能有效地实现死锁避免 D) 当系统中只有一个进程时也可能会产生死锁 E) 系统出现死锁是因为进程调度不当 进程（线程）调度的主要功能有（ ABCD ）。 A) 根据一定的调度算法选择被调度的进程（线程） B) 将CPU分配给选中的进程（线程） C) 将换下CPU的进程（线程）的现场信息保存到进程控制块中 D) 将选中的进程（线程）的现场信息送入到相应寄存器中 E) 将阻塞的进程（线程）唤醒并置为就绪状态 下列哪一种存储管理方案以一个进程为单位分配一组连续的内存单元（ AB ）。 A) 固定分区 B) 可变分区 C) 页式 D) 段式 E) 段页式 在虚拟页式存储方案中，当判断一个页面是否已调入内存时需要用到页表表项的哪些位（ AB ）。 A) 驻留位 B) 中断位 C) 修改位 D) 访问位 E) 保护位 下列哪些文件是按照文件的组织形式划分的文件类型（ BDE ）。 A) 系统文件 B) 普通文件 C) 临时文件 D) 目录文件 E) 特殊文件 ","date":"2019-02-26","objectID":"/test-ncre-os-multiple-choice/:0:0","tags":["NCRE"],"title":"【NCRE四级网络工程师】操作系统多选题","uri":"/test-ncre-os-multiple-choice/"},{"categories":["NCRE"],"content":"如果交换机的总带宽为14.4Gbps，它具有12个百兆的全双工端口，则其千兆的全双工端口数量最多为？ 全双工交换机的带宽计算方法是：端口数端口速率2。 12个百兆的全双工端口占用的带宽为122100=2400 Mbps，则剩余带宽 为14400-2400=12000Mbps。用于千兆的全双工端口，则12000/(2*1000)=6。 Ethernet网卡使用的物理地址的长度为（48位）。 每个物理网络都有自己的MTU，MTU主要规定:一个帧最多能够携带的数据量 在客户机/服务器模型中，服务器响应客户机的请求有两种实现方案，它们是并发服务器方案和（重复服务器）。 在DNS系统中，如果解析器收到一条“非授权的”服务器响应，那么解析器可以认为（该响应提供的信息可能不准确）。 在POP3协议中，查询报文总数和长度可以使用的命令为（STAT）。 关于即时通信系统的描述中，正确的是（RFC2778规定了其通讯模型）。 即时通信IM是一种基于Internet的通信服务，由以色列Mirabils公司最早提出，它提供近实时的信息交换和用户状态跟踪。文件 RFC2778，描述了即时通信系统的功能，正式为即时通信系统勾勒出了模型框架。IM系统一般采用两种通信模式，一种是客户机/服务器模式，另一种采用用户/用户模式，IM软件的文本消息大多使用客户机/服务器模式，而文件传送等大数据量业务使用的是用户/用户模式。在聊天通信中，聊天信息通过加密的方式传输。 关于即时通信协议的描述中，正确的是（XMPP基于JABBER）。 目前，很多即时通信系统都采用服务提供商自己设计开发的IM协议，如微软MSN采用自己的MSNP协议，AOL采用OSCAR协议，QQ采用自己的私有 协议。目前IM通用的协议主要由两个代表：基于SIP协议框架的SIMPLE协议簇及基于Jabber协议框架的XMPP协议簇。SIP协议称为会话发起协议，它是一种在IP网络上实现实时通信的应用层的控制（信令）协议。 即时通信系统通常需要支持两种基本的服务，它们是：呈现服务和即时消息服务 关于P2P文件共享系统的描述中，错误的是（A）。 A) BitTorrent不使用Tracker服务器 B) Maze系统含有搜索引擎 C) 早期的Napster是一个音乐分享系统 D) eDonkey2000采用哈希信息进行文件定位 BitTorrent协议要求文件的发布者制作一个.torrent文件，被称为“种子”文件，种子文件中包含了Tracker服务器的相关信息和发布者共享的 文件的信息。 搜索引擎主要由4个关键部分组成，它们是搜索器、检索器、用户接口和（索引器）。 利用公钥加密和数字签名技术建立的安全服务基础设施称为（PKI）。 关于对称加密的描述中，正确的是（C）。 A) 加密密钥与解密密钥不同 B) 加密算法与密钥可以公开 C) DES属于对称加密方法 D) DSA属于对称加密方法 对称加密技术使用相同的密钥对信息进行加密和解密。由于通信双方加密与解密使用同一个密钥，所以密钥在加密方和解密方之间的传递和分发必须通过安全通道进行。常用的对称加密算法有DES（数字加密算法）、IDEA算法、RC2算法、RC4算法与Skipjack算法等。 关于MD5的描述中，错误的是（C）。 A) 是一种单向散列函数 B) 可用于判断数据完整性 C) 属于对称加密方法 D) 不能从散列值计算出原始数据 散列函数MD5属于一种认证函数，不属于对称加密方法。 关于P2P文件共享的描述中，正确的是（理论基础是六度分割）。 **P2P文件共享的基础是“六度分割”理论。**一般认为P2P文件共享起源于Napster，采用集中式结构，利用 点对点下载过程下载软件，随后另一种P2P文件共享网络Gnutella出现，采用分布式网络共享。BitTorrent即比特洪流，种子文件的扩展名为.torrent。 在网络管理服务中，定义管理对象结构的是（管理信息库（MIB））。 管理信息库（MIB）是TCP/IP网络管理协议标准框架的内容之一，MIB定义了受管设备必须保存的数据项、允许对每个数据 项进行的操作及其含义，即管理系统可访问的受管设备的控制和状态信息等数据变量都保存在MIB中。所以在网络管理服务中，定义管理对象结构的是MIB。 关于CMIP协议的描述中，正确的是（）。 A) 由IETF制定 B) 针对TCP/IP环境 C) 是网络管理的事实标准 D) 采用委托监控机制 国际标准化组织（ISO）最先在1979年对网络管理通信进行标准化工作，主要针对OSI（开放系统互联）模型而设计。ISO的成果是CMIS和CMIP。 CMIP提供管理信息传输服务的应用层协议，而CMIS支持管理进程和管理代理之间的通信要求，二者规定了OSI系统的网络管理标准。在网络管理过程中，CMIP不是通过轮询而是通过事件报告进行工作的。 瓦特斯利用电子邮件验证“小世界假设”理论时，邮件平均被转发多少次即可到达接收者手中（6）。 IP数据报是IP协议单元使用的数据单元，它的格式可以分为报头区和数据区两大部分，其中数据区包括高层需要传输的数据，而报头区是为了正确传输高层数据而增加的控制信息。 在域名系统中，解析器收到一个“非权威性”的映射时，解析器可以认为（响应服务器不是该域名的授权管理者）。 如果一个IP数据报的报头长度为256b，那么该数据报报头长度字段的值为（ 8 ）。 头部的IHL域指明了该头部有多长（以32位字的长度为单位），所以256/32=8。 ","date":"2019-02-26","objectID":"/test-ncre-network-single-topic/:0:0","tags":["NCRE"],"title":"【NCRE四级网络工程师】计算机网络单选题","uri":"/test-ncre-network-single-topic/"},{"categories":["NCRE"],"content":"在以下几种帧中，属于IEEE 802.11管理帧的是（BC）。 A) 信标帧 B) 探测帧 C) 认证帧 D) RTS帧 E) ACK帧 属于IEEE 802.11管理帧的是探测帧和认证帧。 关于千兆以太网物理层标准的描述中，错误的是（ABE）。 A) 1000Base-T使用屏蔽双绞线 B) 1000Base-CX使用非屏蔽双绞线 C) 1000Base-LX使用单模光纤 D) 1000Base-SX使用多模光纤 E) 1000Base-W使用无线传输介质 1000Base-T使用5类非屏蔽双绞线作为传输介质，双绞线长度可达100m。1000Base-CX使用的是屏蔽双绞线，双绞线长度可达25m。 1000Base-LX使用波长为1300nm的单模光纤，光纤长度可达3000m。1000Base-SX使用波长为250nm的多模光纤，光纤长度可达300~500m。 千兆类型以太网中没有1000Base-W类型。 关于Internet接入方式的描述中，正确的是（ACD）。 A) HFC采用共享信道传输方式 B) HFC发展与电话网普及密不可分 C) ADSL需要进行调制解调 D) ADSL 的上、下行速率可以不同 E) HFC的上、下行速率必须相同 Internet的接入方式主要有4种：通过电话线网接入、利用ADSL（非对称数字用户线路）接入、使用HFC（混合光纤同轴电缆网）接入、通过数据通信线路接入。 HFC是在有线电视网的基础上发展起来的。与ADSL类似，HFC也采用非对称的数据传输速率。一般的上行速率在10Mbps左右，下行速率在10~40Mbps左右。HFC采用共享式的传输方式，所有通过Cable Modem的发送和接收使用同一个上行和下行信道。 在ADSL用户端，用户需要使用一个ADSL终端（传统的调制解调器类似）来连接电话线路。通常ADSL可以提供最高1Mbps的上行速率和最高8Mbps的下行速率。 为了解决慢收敛问题，RIP协议可以采用的策略为（BDE）。 A) 加密传输 B) 水平分割 C) 用户认证 D) 毒性逆转 E) 触发刷新 为了解决慢收敛问题，RIP协议采用限制路径最大“距离”对策、水平分隔对策、保持对策、带触发刷新的毒性逆转对策。 在VoIP系统中，网关的主要功能包括（）。 A) 号码查询 B) 信号调制 C) 路由寻址 D) 呼叫控制 E) 身份验证 IP电话网关位于公用交换电话网与IP网的接口处，它是电话用户使用IP电话的接入设备。它的主要功能为号码查询、建立通信连接、信号调制、信号压缩和解压、路由寻址。 网络故障管理的功能主要包括（ABD）。 A) 维护错误日志 B) 执行诊断检测 C) 生成用户账单 D) 跟踪错误 E) 发布安全事件报告 网络故障管理包括检测故障、隔离故障和纠正故障3个方面，应包括典型的功能有维护并检测错误日志、接收错误检测报告并作出响应、跟踪与辨认错误、执行诊断测试、纠正错误。 关于IPSec的描述中，正确的是（ABDE）。 A) 在网络层提供安全服务 B) 主要协议包括AH和ESP C) SPI使用64位连接标识符 D) AH头位于原IP数据报数据和IP头之间 E) SA定义的逻辑连接是单向的 关于无线局域网的描述中，正确的是（）。 A) 以无线电波作为传输介质 B) 协议标准是IEEE 802.11 C) 可采用直接序列扩频技术 D) 可作为有线局域网的补充 无线局域网络利用微波、激光和红外线等无线电波作为传输介质，它是有线局域网的补充。按采用的传输技术可以分为3类：红外线局域网、扩频局域网（调频扩频或直接序列扩频）、窄带微波局域网，采用IEEE 802.11标准，支持基于漫游访问（Nomadic Access）和无线访问接入点（Wireless Access Point，AP）访问模式。 在以下P2P网络中，哪些采用了分布式结构化拓扑（）。 Pastry Tapestry Chord CAN P2P中采用了分布式结构化拓扑有Pastry、Tapestry、Chord和CAN，Napster采用集中式结构。 关于RSA算法的描述中，正确的是（）。 A) 安全性建立在大素数分解的基础上 B) 常用于数字签名中 C) Rivest是发明人之一 E) 加密强度取决于密钥长度 RSA公钥加密算法是1977年由罗纳德•李维斯特（Ron Rivest）、阿迪•萨莫尔（Adi Shamir）和伦纳德•阿德曼（Leonard Adleman）一起提出的一种公钥密码，也是一种分组密码，也是一种既能用于数据加密和数字签名的算法，RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明。RSA密钥长度随着保密级别提高，增加很快。 在Internet中，IP路由器应具备的主要功能包括（ ABD ）。 A) 转发所收到的IP数据报 B) 为投递的IP数据报选择最佳路径 C) 分析IP数据报所携带的TCP内容 D) 维护路由表信息 E) 解析用户的域名 路由器是Internet种最重要的设备，它是网络与网络之间连接的桥梁。它主要的功能是：维护路由表信息（路由表决定着IP数据报发往何处），转发所收到的IP数据报，为投递的IP数据报选择最佳路径。 在IP数据报分片后，分片报头中的哪些字段与原数据报中的字段一定相同（ AC ）。 A) 标识 B) 标志 C) 目的地址 D) 片偏移 E) 头部校验和 提高域名系统解析效率的技术包括（ ADE ）。 A) 解析从本地域名服务器开始 B) 减小资源记录的TTL值 C) 拒绝使用”非权威性的”映射报告 D) 本地主机上采用高速缓冲技术 E) 域名服务器中使用高速缓冲技术 关于Ethernet帧结构的描述中，错误的是（ ABCD ）。 A) 前导码字段的长度是1字节 B) 源地址字段使用的是IP地址 C) 数据字段的最小长度为64字节 D) 类型字段指出应用层协议类型 E) 帧校验字段采用的是CRC校验 关于VLAN技术的描述中，正确的是（ BCDE ）。 A) 可利用集线器组建VLAN B) 可基于广播组定义VLAN C) 可基于IP地址划分VLAN D) 可基于MAC地址划分VLAN E) 可基于交换机端口划分VLAN 关于浏览器安全性的描述中，正确的是（ BD ）。 A) 为了避免非安全软件的危害，可在浏览器中加载自己的证书 B) 为了验证站点的真实性，可要求站点将它的证书传送过来 C) 为了避免他人假冒自己，可将Internet分成几个区域 D) 为了避免传送过程中第三方偷看，可使用SSL技术 E) 为了防止传送过程中第三方篡改，可使用base64编码技术 ","date":"2019-02-26","objectID":"/test-ncre-network-multiple-choice/:0:0","tags":["NCRE"],"title":"【NCRE四级网络工程师】计算机网络多选题","uri":"/test-ncre-network-multiple-choice/"},{"categories":["数据仓库与数据挖掘"],"content":"当今互联网行业中，大大小小几百万公司成立，相对而来的就是成百上千的官方网站的陆续建立，但是怎样使自己公司的官网在百度、谷歌、必应等大牌搜索引擎中被收录，同时提高公司官网访问数量及知名度？ 提高官网服务质量是第一位的，但是还需要对网站做SEO优化，但是怎样做SEO优化？ 大公司的SEO优化都是形成体系的，提高网站的被搜索权重，同时增加特色关键字，增加网站访问量、加大网站被搜索引擎的索引等等方式。 作为一个计算机系的学生，对CSDN网站的需求量在浏览器中算是有着比较大的权重，接下来我借用CSDN网站的大数据网站分析，通过站长之家平台数据进行阐述个人对于大数据在SEO优化领域的具体应用。 上图是通过站长平台获取的对程序员网站CSDN的搜索排名，可以从图中得知CSDN占中文网站排名158、技术编程排名3、北京市排名85、百度权重6、Google权重7、反链数：4278，可以看出，此网站网络排名是较同等网站排名还是比较靠前的，同时由上图可以看到整站日均IP访问量达到100万响应之多，其数据承载量及SEO优化量还是比较大的。 上图可以看到CSDN中网站百度流量统计达到了1万2900，同时网站关键词库有着6196的热门关键词，其中索引量达到了234万7195，可见网站索引量都是比较大额的。 接下来我们看一下网站的收录及反链情况，见下图： 收录：百度占155万、谷歌占62万、360占140万、搜狗占341万； 反链：百度占171万、谷歌占3万左右、360占416万。 上图可以看到CSDN网站的热门标题及优化建议，CSDN全程“CSDN-专业IT技术社区”，这一标题占据着网站整体SEO关键词搜索，其中站长之家提供了对搜索的优化建议：一般不超过80个字符，这样来说对搜索引擎来说是比较友好的，便于搜索引擎的搜录及索引。 通过站长之家云平台可以看到，CSDN的百度权重走势、Alexa排名趋势、百度收录量变化趋势、整体来看，CSDN网站数据流量是稳步上升，众所周知，CSDN的文章来源至中国绝大部分程序员的技术经验及感受等文章，并呈现稳步增长趋势。 CSDN网站的关键词由上图可以看到主要是技术类的关键字，例如“HTTP、a-b、或与非、程序、下载”等关键词，这些词索引量搜录量都在100000000之中。 根据CSDN网站得出SEO优化的途径，主要优化来源有以下几点： 主动使网站让百度、Google、必应、360搜索引擎索引； 用户数量提升、访问数量提升，基数做大，访问量才会稳定； 关键词尽量不要和大牌网站关键词冲突，发掘新颖关键词； 升级网站为HTTPS协议，使网站安全且不会被挂马； 必要时购买百度、360权重，提升搜索时展示位置； 购买信用产品，提升网站信用值，吸引浏览者访问； 适当做网站分享，引流，提升访问量； 搜索体验及用户体验优化。 ","date":"2019-02-25","objectID":"/data-mining-seo-in-website/:0:0","tags":["数据仓库与数据挖掘"],"title":"数据仓库与数据挖掘 - 大数据在SEO网站优化领域的具体应用案例","uri":"/data-mining-seo-in-website/"},{"categories":["蓝桥杯"],"content":"问题描述 输入一个正整数n，输出n!的值。 其中n!=1*2*3*…*n。 ","date":"2019-02-07","objectID":"/lqb-base-practice-factorial-calc/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 阶乘计算","uri":"/lqb-base-practice-factorial-calc/"},{"categories":["蓝桥杯"],"content":"算法描述 n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。 将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。 首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。 ","date":"2019-02-07","objectID":"/lqb-base-practice-factorial-calc/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 阶乘计算","uri":"/lqb-base-practice-factorial-calc/"},{"categories":["蓝桥杯"],"content":"输入格式 输入包含一个正整数n，n\u003c=1000。 ","date":"2019-02-07","objectID":"/lqb-base-practice-factorial-calc/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 阶乘计算","uri":"/lqb-base-practice-factorial-calc/"},{"categories":["蓝桥杯"],"content":"输出格式 输出n!的准确值。 ","date":"2019-02-07","objectID":"/lqb-base-practice-factorial-calc/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 阶乘计算","uri":"/lqb-base-practice-factorial-calc/"},{"categories":["蓝桥杯"],"content":"样例输入 10 ","date":"2019-02-07","objectID":"/lqb-base-practice-factorial-calc/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 阶乘计算","uri":"/lqb-base-practice-factorial-calc/"},{"categories":["蓝桥杯"],"content":"样例输出 3628800 ","date":"2019-02-07","objectID":"/lqb-base-practice-factorial-calc/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 阶乘计算","uri":"/lqb-base-practice-factorial-calc/"},{"categories":["蓝桥杯"],"content":"C++算法 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #define MAX 10000 #define mod 10000 #define baselen 4 #define in(a) scanf(\"%d\",\u0026a) #define out1(a) printf(\"%d\",a) #define out2(a) printf(\"%04d\",a) typedef int type; struct bint{ type dig[MAX], len; bint(){len = 0, dig[0] = 0;} }; void by(bint a, type b, bint\u0026 c){ type i, carry; for( i = carry = 0; i \u003c= a.len || carry; i++){ if( i \u003c= a.len ) carry += b*a.dig[i]; c.dig[i] = carry%mod; carry /= mod; } i--; while( i \u0026\u0026 !c.dig[i] )i--; c.len = i; } bool input(bint\u0026 a){ type i, j, w, k, p; char data[MAX*baselen+1]; if(scanf(\"%s\",data)==EOF)return false; w = strlen(data) - 1, a.len = 0; for(p=0;p\u003c=w\u0026\u0026data[p]=='0';p++); while(1){ i = j = 0, k = 1; while(i\u003cbaselen\u0026\u0026w\u003e=p){ j = j+ (data[w--] - '0')*k; k *= 10, i++; } a.dig[a.len++] = j; if(w\u003cp)break; } a.len--; return true; } void output(bint\u0026 a){ type i; i = a.len - 1; out1(a.dig[a.len]); while(i\u003e=0)out2(a.dig[i--]); } void give(type a, bint\u0026 b){ b.dig[0] = a%mod; a /= mod; if(a\u003e0)b.dig[1] = a, b.len = 1; else b.len = 0; } int main() { bint a;int b,i;scanf(\"%d\",\u0026b);give(1,a); for(i=2;i\u003c=b;i++)by(a,i,a); output(a);printf(\"\\n\"); return 0; } ","date":"2019-02-07","objectID":"/lqb-base-practice-factorial-calc/:7:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 阶乘计算","uri":"/lqb-base-practice-factorial-calc/"},{"categories":["蓝桥杯"],"content":"问题描述 输入两个整数a和b，输出这两个整数的和。a和b都不超过100位。 ","date":"2019-02-05","objectID":"/lqb-base-high-pre-sub/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 高精度加法","uri":"/lqb-base-high-pre-sub/"},{"categories":["蓝桥杯"],"content":"算法描述 由于a和b都比较大，所以不能直接使用语言中的标准数据类型来存储。对于这种问题，一般使用数组来处理。 定义一个数组A，A[0]用于存储a的个位，A[1]用于存储a的十位，依此类推。同样可以用一个数组B来存储b。 计算c=a+b的时候，首先将A[0]与B[0]相加，如果有进位产生，则把进位（即和的十位数）存入r，把和的个位数存入C[0]，即C[0]等于(A[0]+B[0])%10。然后计算A[1]与B[1]相加，这时还应将低位进上来的值r也加起来，即C[1]应该是A[1]、B[1]和r三个数的和．如果又有进位产生，则仍可将新的进位存入到r中，和的个位存到C[1]中。依此类推，即可求出C的所有位。 最后将C输出即可。 ","date":"2019-02-05","objectID":"/lqb-base-high-pre-sub/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 高精度加法","uri":"/lqb-base-high-pre-sub/"},{"categories":["蓝桥杯"],"content":"输入格式 输入包括两行，第一行为一个非负整数a，第二行为一个非负整数b。两个整数都不超过100位，两数的最高位都不是0。 ","date":"2019-02-05","objectID":"/lqb-base-high-pre-sub/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 高精度加法","uri":"/lqb-base-high-pre-sub/"},{"categories":["蓝桥杯"],"content":"输出格式 输出一行，表示a+b的值。 ","date":"2019-02-05","objectID":"/lqb-base-high-pre-sub/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 高精度加法","uri":"/lqb-base-high-pre-sub/"},{"categories":["蓝桥杯"],"content":"样例输入 20100122201001221234567890 2010012220100122 ","date":"2019-02-05","objectID":"/lqb-base-high-pre-sub/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 高精度加法","uri":"/lqb-base-high-pre-sub/"},{"categories":["蓝桥杯"],"content":"样例输出 20100122203011233454668012 ","date":"2019-02-05","objectID":"/lqb-base-high-pre-sub/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 高精度加法","uri":"/lqb-base-high-pre-sub/"},{"categories":["蓝桥杯"],"content":"C++算法 #include \u003ccstdio\u003e #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; int a[401], alen, b[401], blen, c[400], clen; char st[400]; int main() { int i, j, n, len; scanf( \"%s\", st ); alen = strlen( st ); for ( i = 1; i \u003c= alen; i++ ) a[i] = st[alen - i] - 48; scanf( \"%s\", st ); blen = strlen( st ); for ( i = 1; i \u003c= blen; i++ ) b[i] = st[blen - i] - 48; if ( alen \u003e blen ) clen = alen; else clen = blen; for ( i = 1; i \u003c= clen; i++ ) c[i] = a[i] + b[i]; for ( i = 1; i \u003c= clen; i++ ) { if ( c[i] \u003e= 10 ) { c[i + 1] = c[i + 1] + c[i] / 10; c[i] = c[i] % 10; } } if ( c[clen + 1] \u003e 0 ) clen++; for ( i = clen; i \u003e= 1; i-- ) { printf( \"%d\", c[i] ); } printf( \"\\n\" ); return(0); } ","date":"2019-02-05","objectID":"/lqb-base-high-pre-sub/:7:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 高精度加法","uri":"/lqb-base-high-pre-sub/"},{"categories":["蓝桥杯"],"content":"问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0,p1, …,pn-1}，用这列数构造Huffman树的过程如下： 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa+pb。 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 ","date":"2019-02-04","objectID":"/lqb-base-huffman-tree/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Huffuman树","uri":"/lqb-base-huffman-tree/"},{"categories":["蓝桥杯"],"content":"输入格式 输入的第一行包含一个正整数n（n\u003c=100）。 接下来是n个正整数，表示p0,p1, …,pn-1，每个数不超过1000。 ","date":"2019-02-04","objectID":"/lqb-base-huffman-tree/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Huffuman树","uri":"/lqb-base-huffman-tree/"},{"categories":["蓝桥杯"],"content":"输出格式 输出用这些数构造Huffman树的总费用。 ","date":"2019-02-04","objectID":"/lqb-base-huffman-tree/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Huffuman树","uri":"/lqb-base-huffman-tree/"},{"categories":["蓝桥杯"],"content":"样例输入 5 5 3 8 2 9 ","date":"2019-02-04","objectID":"/lqb-base-huffman-tree/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Huffuman树","uri":"/lqb-base-huffman-tree/"},{"categories":["蓝桥杯"],"content":"样例输出 59 ","date":"2019-02-04","objectID":"/lqb-base-huffman-tree/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Huffuman树","uri":"/lqb-base-huffman-tree/"},{"categories":["蓝桥杯"],"content":"C++算法 #include\u003ciostream\u003e #include\u003cqueue\u003e using namespace std; priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e \u003e pq; //构造从小到大的优先队列 int main() { int n; cin \u003e\u003e n; while (!pq.empty()) pq.pop(); int x, s; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e x; pq.push(x); } int sum = 0; while (pq.size() \u003e 1) { s = pq.top(); pq.pop(); s += pq.top(); pq.pop(); sum += s; pq.push(s); } cout \u003c\u003c sum \u003c\u003c endl; } ","date":"2019-02-04","objectID":"/lqb-base-huffman-tree/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Huffuman树","uri":"/lqb-base-huffman-tree/"},{"categories":["蓝桥杯"],"content":"问题描述 给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 ","date":"2019-02-03","objectID":"/lqb-base-2n-queen/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 2n皇后问题","uri":"/lqb-base-2n-queen/"},{"categories":["蓝桥杯"],"content":"输入格式 输入的第一行为一个整数n，表示棋盘的大小。 接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 ","date":"2019-02-03","objectID":"/lqb-base-2n-queen/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 2n皇后问题","uri":"/lqb-base-2n-queen/"},{"categories":["蓝桥杯"],"content":"输出格式 输出一个整数，表示总共有多少种放法。 ","date":"2019-02-03","objectID":"/lqb-base-2n-queen/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 2n皇后问题","uri":"/lqb-base-2n-queen/"},{"categories":["蓝桥杯"],"content":"样例输入 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ","date":"2019-02-03","objectID":"/lqb-base-2n-queen/:3:1","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 2n皇后问题","uri":"/lqb-base-2n-queen/"},{"categories":["蓝桥杯"],"content":"样例输出 2 ","date":"2019-02-03","objectID":"/lqb-base-2n-queen/:3:2","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 2n皇后问题","uri":"/lqb-base-2n-queen/"},{"categories":["蓝桥杯"],"content":"样例输入 4 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ","date":"2019-02-03","objectID":"/lqb-base-2n-queen/:3:3","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 2n皇后问题","uri":"/lqb-base-2n-queen/"},{"categories":["蓝桥杯"],"content":"样例输出 0 ","date":"2019-02-03","objectID":"/lqb-base-2n-queen/:3:4","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 2n皇后问题","uri":"/lqb-base-2n-queen/"},{"categories":["蓝桥杯"],"content":"C++算法 #include\u003ccstdio\u003e using namespace std; int n; int sum; bool g[9][9]; bool wh[9]; bool wd[17]; bool wu[17]; bool bh[9]; bool bd[17]; bool bu[17]; void white(int h){ if(h==n){ sum++; }else{ for(int i=0;i\u003cn;i++){ if(!g[h][i])continue; if(wh[i])continue; if(wd[i+h])continue; if(wu[(i-h)+n])continue; wh[i]=wd[i+h]=wu[(i-h)+n]=1; white(h+1); wh[i]=wd[i+h]=wu[(i-h)+n]=0; } } } void black(int h){ if(h==n){ white(0); }else{ for(int i=0;i\u003cn;i++){ if(!g[h][i])continue; if(bh[i])continue; if(bd[i+h])continue; if(bu[(i-h)+n])continue; g[h][i]=0; bh[i]=bd[i+h]=bu[(i-h)+n]=1; black(h+1); g[h][i]=1; bh[i]=bd[i+h]=bu[(i-h)+n]=0; } } } int main(){ int i; int x; sum=0; scanf(\"%d\",\u0026n); for(i=0;i\u003cn;i++){ wh[i]=bh[i]=0; wd[i]=bd[i]=0; wu[i]=bu[i]=0; for(int j=0;j\u003cn;j++){ scanf(\"%d\",\u0026x); g[i][j]=(bool)x; } } for(;i\u003c2*n;i++){ wd[i]=bd[i]=0; wu[i]=bu[i]=0; } black(0); printf(\"%d\\n\",sum); return 0; } ","date":"2019-02-03","objectID":"/lqb-base-2n-queen/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 2n皇后问题","uri":"/lqb-base-2n-queen/"},{"categories":["蓝桥杯"],"content":"问题描述 给定当前的时间，请用英文的读法将它读出来。 时间用时h和分m表示，在英文的读法中，读一个时间的方法是： 如果m为0，则将时读出来，然后加上“o’clock”，如3:00读作“three o’clock”。 如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。 时和分的读法使用的是英文数字的读法，其中0~20读作： 0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen, 15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。 30读作thirty，40读作forty，50读作fifty。 对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。 按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。 ","date":"2019-02-02","objectID":"/lqb-base-time-telling/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 报时助手","uri":"/lqb-base-time-telling/"},{"categories":["蓝桥杯"],"content":"输入格式 输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。 ","date":"2019-02-02","objectID":"/lqb-base-time-telling/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 报时助手","uri":"/lqb-base-time-telling/"},{"categories":["蓝桥杯"],"content":"输出格式 输出时间时刻的英文。 ","date":"2019-02-02","objectID":"/lqb-base-time-telling/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 报时助手","uri":"/lqb-base-time-telling/"},{"categories":["蓝桥杯"],"content":"样例输入 0 15 ","date":"2019-02-02","objectID":"/lqb-base-time-telling/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 报时助手","uri":"/lqb-base-time-telling/"},{"categories":["蓝桥杯"],"content":"样例输出 zero fifteen ","date":"2019-02-02","objectID":"/lqb-base-time-telling/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 报时助手","uri":"/lqb-base-time-telling/"},{"categories":["蓝桥杯"],"content":"C++算法 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmap\u003e using namespace std; int main(int argc, char** argv) { map\u003cint,string\u003e maptime; maptime[0]=\"zero\"; maptime[1]=\"one\"; maptime[2]=\"two\"; maptime[3]=\"three\"; maptime[4]=\"four\"; maptime[5]=\"five\"; maptime[6]=\"six\"; maptime[7]=\"seven\"; maptime[8]=\"eight\"; maptime[9]=\"nine\"; maptime[10]=\"ten\"; maptime[11]=\"eleven\"; maptime[12]=\"twelve\"; maptime[13]=\"thirteen\"; maptime[14]=\"fourteen\"; maptime[15]=\"fifteen\"; maptime[16]=\"sixteen\"; maptime[17]=\"seventeen\"; maptime[18]=\"eighteen\"; maptime[19]=\"nineteen\"; maptime[20]=\"twenty\"; maptime[30]=\"thirty\"; maptime[40]=\"forty\"; maptime[50]=\"fifty\"; int h,m; cin\u003e\u003eh\u003e\u003em; if(m==0) { if(h\u003c=20) { cout\u003c\u003cmaptime[h]\u003c\u003c\" o'clock\"; } else { cout\u003c\u003cmaptime[20]\u003c\u003c\" \"\u003c\u003cmaptime[h-20]\u003c\u003c\" o'clock\"; } } else { if(h\u003c=20) { cout\u003c\u003cmaptime[h]\u003c\u003c\" \"; } else { cout\u003c\u003cmaptime[20]\u003c\u003c\" \"\u003c\u003cmaptime[h-20]\u003c\u003c\" \"; } if(m\u003c=20) { cout\u003c\u003cmaptime[m]\u003c\u003c\" \"; } else { int k=m%10; cout\u003c\u003cmaptime[m-k]\u003c\u003c\" \"\u003c\u003cmaptime[k]\u003c\u003c\" \"; } } return 0; } ","date":"2019-02-02","objectID":"/lqb-base-time-telling/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 报时助手","uri":"/lqb-base-time-telling/"},{"categories":["蓝桥杯"],"content":"问题描述 回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。 ","date":"2019-02-01","objectID":"/lqb-base-fetch-number/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 回形取数","uri":"/lqb-base-fetch-number/"},{"categories":["蓝桥杯"],"content":"输入格式 输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。 ","date":"2019-02-01","objectID":"/lqb-base-fetch-number/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 回形取数","uri":"/lqb-base-fetch-number/"},{"categories":["蓝桥杯"],"content":"输出格式 输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。 ","date":"2019-02-01","objectID":"/lqb-base-fetch-number/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 回形取数","uri":"/lqb-base-fetch-number/"},{"categories":["蓝桥杯"],"content":"样例输入 3 3 1 2 3 4 5 6 7 8 9 ","date":"2019-02-01","objectID":"/lqb-base-fetch-number/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 回形取数","uri":"/lqb-base-fetch-number/"},{"categories":["蓝桥杯"],"content":"样例输出 1 4 7 8 9 6 3 2 5 ","date":"2019-02-01","objectID":"/lqb-base-fetch-number/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 回形取数","uri":"/lqb-base-fetch-number/"},{"categories":["蓝桥杯"],"content":"样例输入 3 2 1 2 3 4 5 6 ","date":"2019-02-01","objectID":"/lqb-base-fetch-number/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 回形取数","uri":"/lqb-base-fetch-number/"},{"categories":["蓝桥杯"],"content":"样例输出 1 3 5 6 4 2 ","date":"2019-02-01","objectID":"/lqb-base-fetch-number/:7:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 回形取数","uri":"/lqb-base-fetch-number/"},{"categories":["蓝桥杯"],"content":"C++算法 #include\u003cstdio.h\u003e int main() { int m,n; scanf(\"%d %d\",\u0026m,\u0026n); int s[200][200]; int a[200][200]; int i,j; for(i=0;i\u003cm;i++) for(j=0;j\u003cn;j++) { scanf(\"%d\",\u0026s[i][j]); a[i][j]=-1; } int k=0,b=m-1,c=n-1; int h=0; for(i=j=h;a[i][j]==-1\u0026\u0026k\u003c=m*n;) { if(k\u003cm*n) printf(\"%d \",s[i][j]); else printf(\"%d\",s[i][j]); k++; a[i][j]=0; if(i\u003cb\u0026\u0026a[i+1][j]==-1\u0026\u0026j==n-1-c) { i++; continue; } if(i==b\u0026\u0026a[i][j+1]==-1) { j++; continue; } if(j==c\u0026\u0026a[i-1][j]==-1) { i--; continue; } if(i==m-1-b\u0026\u0026a[i][j-1]==-1) { j--; continue; } i=j=(++h); b--;c--; } return 0; } ","date":"2019-02-01","objectID":"/lqb-base-fetch-number/:8:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 回形取数","uri":"/lqb-base-fetch-number/"},{"categories":["蓝桥杯"],"content":"问题描述 话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。 然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。 ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"输入格式 输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2\u003c=100;t\u003c=300;s\u003c=10;l\u003c=10000且为v1,v2的公倍数) ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"输出格式 输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"样例输入 10 5 5 2 20 ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"样例输出 D 4 ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"样例输入 10 5 5 1 20 ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"样例输出 R 3 ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:7:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"样例输入 10 5 5 3 20 ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:8:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"样例输出 T 4 ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:9:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"C++算法 #include\u003ccstdio\u003e #include\u003ciostream\u003e using namespace std; int main() { int v1,v2,t,s,L,L1=0,L2=0,ans=0,i,j; bool bk=true; scanf(\"%d%d%d%d%d\",\u0026v1,\u0026v2,\u0026t,\u0026s,\u0026L); while(1) { if(L1-L2\u003e=t\u0026\u0026L1\u003cL\u0026\u0026L2\u003cL) { for(i=1;i\u003c=s;i++) { if(L1\u003cL\u0026\u0026L2\u003cL) { L2+=v2; ans++; } } } else { L2+=v2; L1+=v1; ans++; } if(L1\u003e=L) break; if(L2\u003e=L) break; } if(L1\u003e=L\u0026\u0026L2\u003e=L){printf(\"D\\n%d\\n\",ans);return 0;} if(L1\u003e=L) {printf(\"R\\n%d\\n\",ans); return 0;} if(L2\u003e=L) {printf(\"T\\n%d\\n\",ans); return 0;} return 0; } ","date":"2019-01-31","objectID":"/lqb-base-tortoise-and-rabbit/:10:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 龟兔赛跑预测","uri":"/lqb-base-tortoise-and-rabbit/"},{"categories":["蓝桥杯"],"content":"问题描述 最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。 不妨设 An=sin(1–sin(2+sin(3–sin(4+…sin(n))…) Sn=(…(A1+n)A2+n-1)A3+…+2)An+1 FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。 ","date":"2019-01-30","objectID":"/lqb-base-sine-dance/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Sine之舞","uri":"/lqb-base-sine-dance/"},{"categories":["蓝桥杯"],"content":"输入格式 仅有一个数：N\u003c201。 ","date":"2019-01-30","objectID":"/lqb-base-sine-dance/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Sine之舞","uri":"/lqb-base-sine-dance/"},{"categories":["蓝桥杯"],"content":"输出格式 请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 ","date":"2019-01-30","objectID":"/lqb-base-sine-dance/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Sine之舞","uri":"/lqb-base-sine-dance/"},{"categories":["蓝桥杯"],"content":"样例输入 3 ","date":"2019-01-30","objectID":"/lqb-base-sine-dance/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Sine之舞","uri":"/lqb-base-sine-dance/"},{"categories":["蓝桥杯"],"content":"样例输出 ((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1 ","date":"2019-01-30","objectID":"/lqb-base-sine-dance/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Sine之舞","uri":"/lqb-base-sine-dance/"},{"categories":["蓝桥杯"],"content":"C++算法 #include\u003cstdio.h\u003e void An_Output(int n, int t) { if(n == t) { printf(\"sin(%d)\", t); return ; } char c; c = t % 2 == 1 ? '+' : '-'; printf(\"sin(%d%c\", t, c); An_Output(n, ++t); printf(\")\"); } void Sn_Output(int n, int t) { //　Sn=(...(A1+n)A2+n-1)A3+...+2)An+1 if(n == t) { return ; } printf(\"(\"); Sn_Output(n, t+1); if(t != n - 1) { printf(\")\"); } An_Output(n - t, 1); printf(\"+%d\", t+1); } int main() { int n; scanf(\"%d\", \u0026n); Sn_Output(n, 1); if(n!=1) printf(\")\"); An_Output(n, 1); printf(\"+1\\n\"); return 0; } ","date":"2019-01-30","objectID":"/lqb-base-sine-dance/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 Sine之舞","uri":"/lqb-base-sine-dance/"},{"categories":["蓝桥杯"],"content":"问题描述 FJ在沙盘上写了这样一些字符串： A1 = “A” A2 = “ABA” A3 = “ABACABA” A4 = “ABACABADABACABA” … … 你能找出其中的规律并写所有的数列AN吗？ ","date":"2019-01-30","objectID":"/lqb-base-fj-string/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 FJ的字符串","uri":"/lqb-base-fj-string/"},{"categories":["蓝桥杯"],"content":"输入格式 仅有一个数：N ≤ 26。 ","date":"2019-01-30","objectID":"/lqb-base-fj-string/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 FJ的字符串","uri":"/lqb-base-fj-string/"},{"categories":["蓝桥杯"],"content":"输出格式 请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 ","date":"2019-01-30","objectID":"/lqb-base-fj-string/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 FJ的字符串","uri":"/lqb-base-fj-string/"},{"categories":["蓝桥杯"],"content":"样例输入 3 ","date":"2019-01-30","objectID":"/lqb-base-fj-string/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 FJ的字符串","uri":"/lqb-base-fj-string/"},{"categories":["蓝桥杯"],"content":"样例输出 ABACABA ","date":"2019-01-30","objectID":"/lqb-base-fj-string/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 FJ的字符串","uri":"/lqb-base-fj-string/"},{"categories":["蓝桥杯"],"content":"C++算法 #include\u003ciostream\u003e #include\u003ccstdio\u003e using namespace std; void dfs(int k,int p) { if (k==1) { printf(\"%c\",p+'A'); return; } dfs(k/2,p-1);dfs(1,p);dfs(k/2,p-1); } int main() { int n; scanf(\"%d\",\u0026n); int sum=1; n--; for (int i=1;i\u003c=n;i++) sum=sum*2+1; dfs(sum,n); return 0; } ","date":"2019-01-30","objectID":"/lqb-base-fj-string/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 FJ的字符串","uri":"/lqb-base-fj-string/"},{"categories":["蓝桥杯"],"content":"问题描述 有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。 每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。 给出所有芯片的测试结果，问哪些芯片是好芯片。 ","date":"2019-01-30","objectID":"/lqb-base-chip-test/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 芯片测试","uri":"/lqb-base-chip-test/"},{"categories":["蓝桥杯"],"content":"输入格式 输入数据第一行为一个整数n，表示芯片个数。 第二行到第n+1行为n*n的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行第j列（1≤i, j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本身进行测试）。 ","date":"2019-01-30","objectID":"/lqb-base-chip-test/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 芯片测试","uri":"/lqb-base-chip-test/"},{"categories":["蓝桥杯"],"content":"输出格式 按从小到大的顺序输出所有好芯片的编号 ","date":"2019-01-30","objectID":"/lqb-base-chip-test/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 芯片测试","uri":"/lqb-base-chip-test/"},{"categories":["蓝桥杯"],"content":"样例输入 3 1 0 1 0 1 0 1 0 1 ","date":"2019-01-30","objectID":"/lqb-base-chip-test/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 芯片测试","uri":"/lqb-base-chip-test/"},{"categories":["蓝桥杯"],"content":"样例输出 1 3 ","date":"2019-01-30","objectID":"/lqb-base-chip-test/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 芯片测试","uri":"/lqb-base-chip-test/"},{"categories":["蓝桥杯"],"content":"C++算法 #include\u003ciostream\u003e #include\u003ccstdio\u003e #include\u003ccstring\u003e using namespace std; bool a[25][25]; bool v[25]; int n; bool dfs(int k) { if (k==n) { int sum=0; for (int i=1;i\u003c=n;i++) if (v[i]) sum++; if (sum\u003en-sum) for (int i=1;i\u003c=n;i++) if (v[i]) printf(\"%d \",i); return true; } if (v[k]==true) { int len=0,s[25]; for (int i=1;i\u003c=n;i++) if (!a[k][i] \u0026\u0026 v[i]) { s[++len]=i; v[i]=false; } if (dfs(k+1)) return true; for (int i=1;i\u003c=len;i++) v[s[i]]=true; } if (dfs(k+1)) return true; } int main() { scanf(\"%d\",\u0026n); memset(v,true,sizeof(v)); for (int i=1;i\u003c=n;i++) for (int j=1;j\u003c=n;j++) { int c; scanf(\"%d\",\u0026c); if (c) a[i][j]=1; else a[i][j]=0; } dfs(1); return 0; } ","date":"2019-01-30","objectID":"/lqb-base-chip-test/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 芯片测试","uri":"/lqb-base-chip-test/"},{"categories":["蓝桥杯"],"content":"问题描述 Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。 比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。 所以，他迫切地需要一个系统，然后当他输入12 3456 7009时，会给出相应的念法： 十二亿三千四百五十六万七千零九 用汉语拼音表示为 shi er yi san qian si bai wu shi liu wan qi qian ling jiu 这样他只需要照着念就可以了。 你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。 注意必须严格按照规范，比如说“10010”读作“yi wan ling yi shi”而不是“yi wan ling shi”，“100000”读作“shi wan”而不是“yi shi wan”，“2000”读作“er qian”而不是“liang qian”。 ","date":"2019-01-29","objectID":"/lqb-base-reading-numbers/:1:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 数的读法","uri":"/lqb-base-reading-numbers/"},{"categories":["蓝桥杯"],"content":"输入格式 有一个数字串，数值大小不超过2,000,000,000。 ","date":"2019-01-29","objectID":"/lqb-base-reading-numbers/:2:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 数的读法","uri":"/lqb-base-reading-numbers/"},{"categories":["蓝桥杯"],"content":"输出格式 是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。 ","date":"2019-01-29","objectID":"/lqb-base-reading-numbers/:3:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 数的读法","uri":"/lqb-base-reading-numbers/"},{"categories":["蓝桥杯"],"content":"样例输入 1234567009 ","date":"2019-01-29","objectID":"/lqb-base-reading-numbers/:4:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 数的读法","uri":"/lqb-base-reading-numbers/"},{"categories":["蓝桥杯"],"content":"样例输出 shi er yi san qian si bai wu shi liu wan qi qian ling jiu ","date":"2019-01-29","objectID":"/lqb-base-reading-numbers/:5:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 数的读法","uri":"/lqb-base-reading-numbers/"},{"categories":["蓝桥杯"],"content":"C++算法 #include\u003ciostream\u003e #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003ccstdlib\u003e using namespace std; char df[][10]={\"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\"}; char s[15]; int main() { scanf(\"%s\",s); int lens=strlen(s); bool bk=false; for (int i=0;i\u003clens;i++) { int p,lendf; p=s[i]-'0'; if (p!=0) { bk=false; lendf=strlen(df[p]); if (s[i-1]-'0'==0) printf(\"ling \"); if ((lens-i)%4==2 \u0026\u0026 p==1 /*\u0026\u0026 s[i-1]-'0'==0 \u0026\u0026 s[i-2]-'0'==0*/ \u0026\u0026 i==0) { printf(\"shi \"); continue; } for (int j=0;j\u003clendf;j++) printf(\"%c\",df[p][j]); printf(\" \"); if ((lens-i)%4==2) printf(\"shi \"); if ((lens-i)%4==3) printf(\"bai \"); if ((lens-i)%4==0) printf(\"qian \"); } if ((lens-i)%4==1) { if ((lens-i)/4==2) { bk=true; printf(\"yi \"); } if (bk==false \u0026\u0026 (lens-i)/4==1) printf(\"wan \"); } } return 0; } ","date":"2019-01-29","objectID":"/lqb-base-reading-numbers/:6:0","tags":["蓝桥杯","algorithm"],"title":"蓝桥杯 基础练习 数的读法","uri":"/lqb-base-reading-numbers/"},{"categories":["os"],"content":"中央处理器CPU 单机系统： 一个计算机系统只有一个处理器。 多处理器系统： 一个计算机系统有多个处理器。 ","date":"2017-11-20","objectID":"/os-runtime/:1:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"CPU的构成与基本工作方式 处理器一般由运算器、控制器、寄存器以及高速缓存构成。 运算器 实现任何指令中的算术和逻辑运算，是计算机的核心; 控制器 负责控制程序运行的流程，包括取指令、维护CPU状态、CPU与内存的交互等; 寄存器 是指令在CPU内部做处理的过程中能够张村数据、地址以及指令信息的存储设备; 高速缓存 处于CPU和物理内存之间，一般由控制器中的内存管理单元MMU管理; ","date":"2017-11-20","objectID":"/os-runtime/:2:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"处理器中的寄存器 用户可见存储器：对于高级语言来说，编译器通过一定的算法分配并使用这些寄存器，以最大限度地减少程序运行过程中的访问存储器的次数，这对程序运行速度的影响很大。 控制和状态存储器：用于控制处理器的操作。 数据寄存器：又称为通用寄存器，主要用于各种算术逻辑指令和访存指令，对具有浮点能力和多媒体能力处理能力的处理器来说，浮点处理过程的数据寄存器和整数处理时的数据寄存器一般是分离的。 地址寄存器：用于存储数据及指令的物理地址、线性地址、有效地址。 条形码寄存器：保存CPU操作结果的各种标记位。 作用：控制处理器的操作。 控制和状态寄存器包括了程序计数器、指令寄存器和程序状态字。 程序计数器（PC）：记录了将要取出的指令的地址。 指令寄存器（IR）：包含了最近取出的指令。 程序状态字（PSW）：记录了处理器的运行模式信息。 ","date":"2017-11-20","objectID":"/os-runtime/:2:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"指令执行的基本过程 处理指令的最简单的方式包括两种步骤：处理器先从存储器中每次读取一条指令，然后执行这条指令。 这些指令大致分为以下五类： 访问存储器指令：负责处理器和存储器之间的数据传送。 I/O指令：负责处理器与I/O模块之间的数据传输及命令发送。 算术逻辑指令：又称为数据处理指令，用以执行有关数据的算术与逻辑操作。 控制转移指令：可以指令一个新的指令的执行起点。 处理器控制指令：用于修改处理器状态，改变处理器工作方式。 例： 假设程序计数器PC正指向2000h地址处的指令，指令机器描述如下： 地址 指令 2000h MOVE [3340h], R1 2004h ADD R1, 1 2008h MOVE R1, [3340h] …… …… …… …… 指令MOVE被送入指令寄存器IR中，同时将自增一个指令的长度，（4个字节），取指之后PC为2004h。 这是一条访问内存的指令，树3340h所指定的双字地址单元中的数据取到通用寄存器R1中来。 CPU又从PC（地址为2004h）处取出指令ADD到IR中，PC变为2008h。 CPU根据指令将R1寄存器和立即数1相加。 访存指令MOVE被取到IR中，PC变为2004h。 ","date":"2017-11-20","objectID":"/os-runtime/:2:2","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"特权指令与非特权指令 单用户单任务下使用计算机指令系统中的全部命令。 多用户多任务中，分为：特权模式和非特权模式。 特权指令 ：是指指令系统中那些只能用操作系统使用的指令，这些特权指令是不允许一般的用户所使用的。 用户只能使用非特权指令，因为只有操作系统才能使用所有的指令。 ","date":"2017-11-20","objectID":"/os-runtime/:2:3","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"处理器的状态 ","date":"2017-11-20","objectID":"/os-runtime/:3:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"管态与目态 管态 ：指操作系统管理程序运行的状态，具有较高的特权级别，又称特权态、系统态。 目态： 指用户程序运行时的状态，具有较低的特权级别，又称普通态、用户态。 例： 英特尔X86系列处理器特权级别 R0：运行操作系统的核心代码 R1：运行关键设备驱动程序和I/O处理例程 R2：运行其他受保护的贡献代码 R3：运行各种用户程序 R0到R3特权能力依次降低，R0相当于双状态系统的管态，R3相当于目态，而R1和R2则介于两者之间。 ","date":"2017-11-20","objectID":"/os-runtime/:3:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"CPU 状态的转换 目态到管态的转换，权限提升 管态到目态的转换，可以通过设置PSW指令（修改程序状态字），实现从操作系统向用户程序的转换。 ","date":"2017-11-20","objectID":"/os-runtime/:3:2","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"限制用户程序执行特权指令 ","date":"2017-11-20","objectID":"/os-runtime/:3:3","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"程序状态字 PSW 程序状态字PSW：用程序计数器PC这个专门的寄存器来指示下一条要执行的指令。 PSW包括以下状态代码： CPU的工作状态码 条件码 中断屏蔽码 某些常见标志位： CF：进位标志位 ZF：结构为零标志位 SF：符号标志位 OF：溢出标志位 TF：陷阱标志位 IF：中断使能标志位 VIF：虚拟中断标志位 VIP：虚拟中断带决标志位 IOPL：IO特权级别 ","date":"2017-11-20","objectID":"/os-runtime/:4:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"存储体系 一个作业必须把它的程序和数据存放在主存储器中才能运行。 ","date":"2017-11-20","objectID":"/os-runtime/:5:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"存储器的层次结构 设计主要考虑三方面：容量、速度和成本。 容量是存储系统的基础。 速度存储系统的速度则要能匹配处理器的速度。 存储器的成本和其他部件相比应该在一个合适的范围内。 ","date":"2017-11-20","objectID":"/os-runtime/:5:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"容量、速度和成本的匹配 存储速度越快，平均每比特价格越高，容量越小，平均每比特的价格越低，同时容量也增大。 ","date":"2017-11-20","objectID":"/os-runtime/:5:2","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"存储访问局部性原理 ","date":"2017-11-20","objectID":"/os-runtime/:5:3","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"存储保护 ","date":"2017-11-20","objectID":"/os-runtime/:6:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"界地址寄存器（界限寄存器） 在CPU中设置一队界限寄存器来存放用户作业在主存中的下限和上限地址，分别称为下限寄存器和上限寄存器。指出程序在内存的存放位置。 越界中断又称存储保护中断，每当CPU要访问主存时，硬件自动被访问的主存地址与界限存储器的内容进行比较，以判断是否越界。如果未越界，则按此地址访问主存，否则将产生程序中断。 ","date":"2017-11-20","objectID":"/os-runtime/:6:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"存储键 每个存储块都有一个与其相关的由二进位组成的存储保护键。 每当一个用户作业被允许进入主存时，操作系统分给他一个唯一的、不与其他作业相同的存储键号；并将分配该作业的各存储快的存储键，也设置成同样的键号。操作系统同时将该作业的存储键号存放到程序状态字PSW的存储键域中，这样，每当CPU访问主存时，都将对主存块的存储键与PSW中的钥匙进行比较。如果相比配，则允许访问；否则，拒绝并报警。 ","date":"2017-11-20","objectID":"/os-runtime/:6:2","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"中断和异常机制 ","date":"2017-11-20","objectID":"/os-runtime/:7:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"中断与异常 中断 指CPU对系统中或者系统外发生的异步事件的响应。 异步事件 是指无一定时间关系的随机发生的事件。 中断是所有要打断处理器的正常工作次序，并要求其去处理某一事件的一种手段。 中断事件：又称中断源，引起中断的事件。 中断请求：中断源向处理器发出的请求信号。 中断处理程序：处理中断事件的程序。 中断断点：处理器暂时当前程序转而处理中断的过程。 中断响应：处理器暂停当前程序转而处理中断的过程。 中断返回：中断处理结束后恢复原来程序的执行。 中断字一个计算机系统提供的中断源的有序集合。 中断向量表：中断处理程序入口地址映射表。 中断向量：表中的每一项，主要是由程序状态字PSW和指令计数器PC的值组成。 中断是由外部事件引发的。 异常则是由正在执行的指令引发的。 ","date":"2017-11-20","objectID":"/os-runtime/:7:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"中断与异常的分类 中断 时钟中断：是由处理器内部的计时器产生。 输入输出（I/O）中断：正常完成或则发生的错误。 控制台中断：如系统操作员通过控制台发出的命令。 硬件故障中断：由掉电、存储器校验错等硬件故障引起的。 异常 程序性中断：由指令执行结果产生。 访问指令异常：要求操作系统提供系统服务。 ","date":"2017-11-20","objectID":"/os-runtime/:7:2","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"中断系统 中断系统：是由硬件及软件相互配合、相互渗透而使得计算机系统得以充分发挥能力的计算机模式。 中斷系統的硬件中断装置和软件中断处理程序。硬件终端装置负责捕获中断源发出的中断请求，并以一定的方式响应中断源，然后将处理器的控制权移交给特定的中断处理程序.中断处理程序就是针对中断事件的性质而执行的一系列操作。 ","date":"2017-11-20","objectID":"/os-runtime/:8:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"中断请求的接受 中断请求的接受是通过在计算机硬件上的终端逻辑线路和中断寄存器实现的。 触发器的值为1时，表示该触发器接收到了中断信号，为0时表示无中断信号。 中断响应 响应机制：处理器控制不见中的设置有中断信号扫描结构，它在每条指令执行周期内的最后时刻扫描出中断寄存器，查看是否有中断信号的到来。 有中断到来=》处理器结构硬件终端装置发来的中断向量代号。 无中断到来=》处理器就继续执行下一条指令。 中断请求响应的工作过程： 处理器接受中断信号 保护现场个，将中断断点的程序状态字PSW和程序计数器PC值存入系统堆栈。 分析中断向量，取得中断向量程序的入口程序。 将处理器的PC值置为中断处理程序的入口地址。 调解中断处理程序。 中断处理 接受和响应中断。 保护中断现场。 分析中断向量。 调用中断处理程序。 中断处理结束恢复现场。 原有程序继续执行。 几种典型的中断的处理 I/O中断：一般是由I/O设备的控制器或者通道发出。 时钟中断 维护软件时钟 处理器调度 控制系统定时任务 实时处理 硬件故障中断：一般是由硬件的问题引起的。例如复位硬件或者更换设备。 程序性中断：程序指令出错、指令越权或者指令寻址越界而引发的系统保护。 系统服务请求（访管中断）：应用程序设计接口API。 ","date":"2017-11-20","objectID":"/os-runtime/:8:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"中断优先级与终端屏蔽 多级中断与中断优先级 硬件上，多级中断系统表现为有多根中断请求线从不同设备连接到中断逻辑线路上。 各类中断信号依据其紧急程度和重要性划分级别。 解决如果有重要程度相当的多个中断信号同时到达时，如何选择首个被处理的中断信号的问题。 中断屏蔽 在整个中断系统中，可以允许或则禁止中断系统对某些类别中断的响应。 在程序状态字PSW中设计有中断屏蔽位，主机是否允许响应或禁止某些中断，则由PSW中的中断屏蔽位决定，这些屏蔽位标识了那些被屏蔽中断类或者中断。 例：在一个计算机系统中，CD-ROM到硬盘的数据传输的优先级低于硬盘内部的数据传输操作。 内存奇偶检验错，以及掉电等使得机器无法继续操作的一类故障。一旦发生这类不可屏蔽的中断，不管程序状态字的屏蔽位是否建立，处理器都要立即相应这类中断，并进行处理。 ","date":"2017-11-20","objectID":"/os-runtime/:8:2","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"系统调用 ","date":"2017-11-20","objectID":"/os-runtime/:9:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"系统调用 系统调用就是用户在程序中调用操作系统所提供的一系列子功能。 有特殊的机器指令实现的，由汇编语言直接访问。 系统调用与一般过程调用的区别 运行在不同的系统状态：调用程序运行在用户态，而被调用程序则运行在系统态。 状态的转换：通过软中断机制先由用户态转换为核心态，在操作系统核心分析之后，转向相应的系统调用处理子程序。 返回问题：让优先级最高的进程优先执行。 嵌套调用：在一个被调用的过程执行期间，还可在利用系统调用命令在去调用另一个系统调用。 系统调用的分类 进程控制类系统调用：对进程的控制，如创建和终止进程的系统调用。 文件操作类系统调用：对文件进行操作的系统调用，如创建、打开、关闭、读写文件等操作。 进程通信类系统调用：被用在进程之间传递信息和信号。 设备管理类系统调用：系统调用被用来请求和释放有关设备，以及启动设备操作。 信息维护类系统调用：有关信息维护的系统调用。 系统调用命令是作为扩充机器指令，增强系统的功能，方便用户使用而提供的。 “广义指令”：系统调用命令的过程。软件实现的 ","date":"2017-11-20","objectID":"/os-runtime/:9:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"系统调用的处理过程 在系统中为控制系统调用服务的机构称为陷入（TRAP）或异常处理机构。 由于系统调用引起的处理机中断的指令称为陷入或异常指令（或称访管指令）。 一种是由陷入指令自带的参数。 另一种是通过有关通用寄存器来传递参数。 处理机在用户程序中执行称为用户态，而把处理机在系统程序中执行称为系统态（或管态）。 ","date":"2017-11-20","objectID":"/os-runtime/:9:2","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"I/O技术 ","date":"2017-11-20","objectID":"/os-runtime/:10:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"I/O结构 通道 通道是独立于中央处理器的，专门负责数据I/O传输工作的处理单元。 I/O处理机通道对外部设备实行统一的管理，代替CPU对I/O设备操作进行控制。 工作原理： 按程序规定的顺序执行一条条指令，按指令中给定的参数启动指定的设备。 控制权转移到通道 信息传送，由通道控制，而中央处理器则继续执行程序。 产生一个“输入输出操作结束”的I/O中断事件。 ","date":"2017-11-20","objectID":"/os-runtime/:10:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"DMA 技术 直接存储器访问DMA技术通过系统总线中的一个独立的控制单元，自动的控制成块的数据在内存和I/O单元之间的传送， DMA控制单元命令包含了I/O设备的编址、开始读或写的主存编址、需要传送的数据长度、是否请求一次读和写等信息。 ","date":"2017-11-20","objectID":"/os-runtime/:10:2","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"缓冲技术 缓冲技术实在外部设备于其他硬件之间的一种数据暂存技术，他利用存储器件在外部设备中设置了数据的一个存储区域，称为缓冲区。 两种用途： 在外部设备与外部设备之间的通信上。 在外部设备和处理器之间。 最根本原因：CPU处理数据的速度与设备传输数据速度不相匹配，需要缓冲区缓解其间的速度矛盾。 ","date":"2017-11-20","objectID":"/os-runtime/:10:3","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"时钟 ","date":"2017-11-20","objectID":"/os-runtime/:11:0","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["os"],"content":"时钟的作用 在多道程序运行的环境中，防止时机的浪费。 在分时系统中，用时钟间隔来实现各个作业按时间片轮转运行。 在实时系统中，按要求的时间间隔输出争取的时间信号给相关的实时控制设备。 定时唤醒哪些要求按照事先给定的时间执行的各个外部事件。 记录用户使用各种设备的时间和记录某外部事件发生的时间间隔。 记录用户和系统所需要的绝对时间，即年月日。 时钟一般分为硬件时钟和软件时钟。 硬件时钟工作原理：在电路中的晶体震荡器，每个一定的时间间隔产生固定的脉冲频率，时钟电路中的时钟寄存器依据时钟电路所产生的脉冲数，对时钟寄存器进行加1操作。 软件时钟工作原理：主要是利用内存单元模拟时钟寄存器，并采用一段程序来计算相应的脉冲数，对内存时钟寄存器进行加1或减1操作。 时钟的用途可以分为绝对时钟和相对时钟。 绝对时钟是在计算机系统中不受外界干扰、独立运行的一种时钟。 相对时钟又称“间隔时钟”，它只计算从某一个时间初值开始的一段时间间隔。 ","date":"2017-11-20","objectID":"/os-runtime/:11:1","tags":["os","runtime","操作系统","学习笔记"],"title":"操作系统 运行机制","uri":"/os-runtime/"},{"categories":["algorithm"],"content":"算法原理 先确定待查记录所在的范围（区间），然后逐步缩小范围指导找到或找不到该记录为止。 ","date":"2017-11-18","objectID":"/structure-half-search/:1:0","tags":["笔记","数据结构"],"title":"数据结构 折半查找法","uri":"/structure-half-search/"},{"categories":["algorithm"],"content":"算法性能 时间复杂度： log 2 n + 1 平均查找长度： log 2 n + 1 – 1 ","date":"2017-11-18","objectID":"/structure-half-search/:2:0","tags":["笔记","数据结构"],"title":"数据结构 折半查找法","uri":"/structure-half-search/"},{"categories":["algorithm"],"content":"注意事项 折半查找法必须为有序数列。 可以是逆序的，但是必须得提前定义遍历对比对象。 ","date":"2017-11-18","objectID":"/structure-half-search/:3:0","tags":["笔记","数据结构"],"title":"数据结构 折半查找法","uri":"/structure-half-search/"},{"categories":["algorithm"],"content":"算法实现 include \"stdio.h\" //折半查找函数 int binarySearch(int a[], int n, int key){ //定义数组的第一个数 int low = 0; //定义数组的最后一个数 int high = n-1; //定义中间的数值 int mid; //存放中间的数值的变量 int midVal; //当左边的值小于等于右边的值的时候 while(low \u003c= high){ mid = (low + high)/2; midVal = a[mid]; //如果中间值小于用户查找到的数值，最低的数字到中间数值+1位置上 if(midVal \u003c key){ low = mid + 1; }else if(midVal \u003e key){ //如果中间值大于用户查找到的数值，最高的数字到中间数值-1位置上 high = mid - 1; } else return mid; } return -1; } int main(){ int i, val, ret; int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //打印数组 for(i=0; i\u003c10; i++) printf(\"%d \\t\", a[i]); printf(\"\\n请你输入你要进行查找的元素\\n\"); scanf(\"%d\", \u0026val); ret = binarySearch(a, 10, val); if(ret == -1){ printf(\"查找失败！\\n\"); } else{ printf(\"查找成功！\\n\"); } return 0; } ","date":"2017-11-18","objectID":"/structure-half-search/:4:0","tags":["笔记","数据结构"],"title":"数据结构 折半查找法","uri":"/structure-half-search/"},{"categories":["os"],"content":"操作系统的概念 ","date":"2017-11-18","objectID":"/os-introduction/:1:0","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"计算机系统 计算机系统包括硬件子系统及软件子系统。 各种程序和数据组成了计算机的软件系统。 操作系统：在计算机系统中，集中了资源管理功能和控制程序执行功能的一种软件。 ","date":"2017-11-18","objectID":"/os-introduction/:1:1","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"操作系统的定义 “有效”是指根据用户的不同的要求，在管理计算机资源时考虑到系统运行的效率及资源的利用率。 “合理”是指操作系统要“公平对待”不同的用户程序，保证系统不发生“死锁”及“饥饿”现象。 ","date":"2017-11-18","objectID":"/os-introduction/:1:2","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"操作系统的特征 并发性 是指在计算机系统中同时存在若干个运行的程序。计算机的并发行体现在下面两个方面： 用户程序与用户程序之间并发执行 用户程序与操作系统之间并发执行 共享性 随机性 ","date":"2017-11-18","objectID":"/os-introduction/:1:3","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"研究操作系统的观点 软件的观点 操作系统就是一种大型的软件系统，它是多种功能程序的集合。 外在特性 操作系统是一种软件，它的外部表现形式，即它的操作命令定义集和它的界面，完全确定了炒作系统这个软件的使用方式。 内在特性 操作系统既然是臃肿软件，他就具有一般软件的结构特点。 资源管理的观点操作系统就是负责记录谁在使用什么样的资源。 操作系统要提供一些机制去协调程序间的竞争与同步，提供机制对资源进行合理使用，对其保护，一机采取虚拟技术来“扩充”资源等。 进程的观点 操作系统就死看作是由多个可以独立运行的程序和一个对这些程序进行协调的核心所组成的。 虚拟机的观点 服务提供者的观点 ","date":"2017-11-18","objectID":"/os-introduction/:1:4","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"操作系统的功能 进程管理 对中央处理器进行管理。 进程管理分为一下几个方面： 进程控制进程控制的主要任务就是创建进程、撤销结束的进程以及控制进程进行时候的各种状态的转换。 进程同步 互斥 ：是指多个进程对临界资源访问时采用互斥的形式。 同步 ：是在相互协作共同完成任务进程之间，用同步机制协调他们之间的执行顺序。 进程间通讯进程通讯主要发生在相互协作的进程之间。由操作系统提供给的进程间的通讯机制是协作的进程之间相互交换数据和消息的手段。 调度 调度又称处理器调度，通常包括进程调度、线程调度及作业调度。 进程调度 任务就是从进程（线程）的就绪队列中按照一定的算法挑选出一个，吧处理器资源分配给他，并准备好特定的执行上下文让他执行起来。 作业调度 依照作业说明书为他们分配一定的资源，把他们装进内存并未每个作业建立相应的进程。 存储管理存储管理的任务就是管理计算机内存的资源。 文件管理 文件管理的任务就是有效的支持文件的存储、检索及修改等操作，解决文件的共享、保密及保护问题，以使用户方便、安全的访问文件。 设备管理 用户接口 用户计算机系统之间的接口。 ","date":"2017-11-18","objectID":"/os-introduction/:1:5","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"操作系统的发展 ","date":"2017-11-18","objectID":"/os-introduction/:2:0","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"手工操作 通过在插板上的硬连接线来控制计算机的基本功能。 ","date":"2017-11-18","objectID":"/os-introduction/:2:1","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"监控程序（早期批处理） ","date":"2017-11-18","objectID":"/os-introduction/:2:2","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"多道批处理 多道 是指允许多个程序同时存在于内存之中，由CPU以切换的方式为之服务，使得多个程序可以同时执行。 ","date":"2017-11-18","objectID":"/os-introduction/:2:3","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"分时系统 分时系统 是指多个用户通过终端设备与计算机交互作用来运行自己的作业，并且共享一个计算机系统而互不干扰。 ","date":"2017-11-18","objectID":"/os-introduction/:2:4","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"UNIX通用操作系统 C语言编写。 ","date":"2017-11-18","objectID":"/os-introduction/:2:5","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"个人计算机操作系统 ","date":"2017-11-18","objectID":"/os-introduction/:2:6","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"Android操作系统 ","date":"2017-11-18","objectID":"/os-introduction/:2:7","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"操作系统分类 批处理操作系统 批处理操作系统特点就是成批处理。 作业吞吐率：在单位时间内计算机系统处理作业的个数。 设计思想 在监控程序启动之前，操作员有选择的把若干作业合并成一批作业，将这些作业安装在输入设备之上，然后自动监控程序，监控程序将自动控制这批作业执行。 一般指令与特权指令 运行模式通常分为用户模式和特权模式。 目态： 为用户服务的用户模式。 管态： 为系统专用的特权模式。 系统调用的过程 系统调用时，通常是中断或者异常处理，将处理器模式转变成特权模式。 由监控程序执行被请求的功能代码。 处理结束之后，监控程序恢复系统调用之前的现场；把运行模式从特权模式恢复成为用户方式；最后将控制权转移到原来的用户程序。 SPOOLing技术（假脱技术） 基本思想： 用磁盘设备作为主机的直接输入/输出设备，主机直接从磁盘上选取作业运行，作业的执行结果也存在磁盘上；相应的，通道则负责将用户作业从卡片机上动态写入磁盘，而这一操作与主机并行。 ","date":"2017-11-18","objectID":"/os-introduction/:2:8","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"分时系统 基本工作方式 在分时系统中，一台计算机主机连接了若干个终端，每个终端可有一个用户使用。 设计思想 分时系统将CPU的时间划分成若干个小片段，称为时间片。操作系统以时间片为单位，轮流为每个终端用户服务。 特点 多路性： 只有多个用户在使用同一台计算机。 交互性： 指用户根据系统响应的结果提出下一个请求。 独占性： 指每个用户感觉不到计算机在为其他人服务。 及时性： 指系统能够对用户提出的请求及时给予响应。 分时操作系统追求的目标 ：及时响应用户输入的交互命令。 分时与批处理的处理原则 ：分时优先，批处理在后。 ","date":"2017-11-18","objectID":"/os-introduction/:2:9","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"实时操作系统 实时操作系统（RTOS）是指计算机能在规定的时间内及时响应外部事件的请求，同时完成对该事件的处理，并能够控制所有实时设备和实时任务协调一致の工作的操作系统。 硬实时系统 对关键外部事件的响应和处理时间有着极为严格的要求，系统必须满足这种严格的时间要求，否则会产生严重的不良后果。 软实时系统 对事件的响应和处理时间有一定的时间范围要求，不能满足相关的要求会影响系统的服务质量，但是通常不会引发灾难性后果。 实时时钟管理 主要设计目标：对实时任务能够进行实时处理。 依据时间要求 定时任务： 依据用户定时启动并按照严格的时间间隔重复运行。 延时任务： 非周期运行，允许被延后执行，但往往有一个严格的时间线界限。 依据功能划分 主动式任务： 依据时间间隔主动运行，多用于实时监控。 从动式任务： 运行以来于外部时间的发生，但外部事件出现时，这种实时任务应尽可能地进行处理，并且保证不丢失现象。 过载防护 实时任务的启动时间和数量具有很大的随机性，突发的大量实时任务极有可能超出系统的处理能力，从而发生过载。 高可靠性 ","date":"2017-11-18","objectID":"/os-introduction/:2:10","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"嵌入式操作系统EOS 嵌入式操作系统就是运行在嵌入式环境芯片中，对整个芯片以及它所操作的、控制的各种部件装置等资源进行统一协调、调度、指挥和控制的系统软件。 优点 具有高可靠性、实时性、占用资源少、智能化能源管理、易于连接、低成本等优点。 个人计算机操作系统PCOS 个人计算机操作系统是一种单用户多任务的操作系统。 网络操作系统NOS 网络操作系统：为计算机网络配置的操作系统。 分布式操作系统DOS 将大量计算机通过网络连接在一起，可以获得极高的运算能力及广泛的数据共享。 特征： 是一个统一的操作系统。 实现资源的深度共享。 透明性。 自治性。 集群 Cluster是分布式系统的一种，一个集群通常由一群处理器密集构成，集群操作系统专门服务于这样的集群。用低成本的微型计算机和以太网设备等产品，构造出性能相当于超级计算机运行性能的集群。 智能卡操作系统COS 四个基本功能：资源管理、通信管理、安全管理和应用管理。 ","date":"2017-11-18","objectID":"/os-introduction/:2:11","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["os"],"content":"操作系统结构 操作系统结构就是指操作系统各部分程序存在方式及相互关系。 模块结构： 以程序模块方式存在。 进程结构： 以进程的方式存在。 整体式结构 模块 将总功能分解成若干个子功能，实现每个子功能的程序。 优点：结构紧密，接口简单直接，系统效率较高。 模块组合法 （又称无需模块法，模块接口法），系统中的模块不是根据程序和数据本身的特性而是根据他们完成的功能来划分的，数据基本上作为全称量使用。 层次结构 层次结构就是把操作系统的所有功能模块，按照功能流程图的调用次序，分别将这些模块排列成若干层，各层之间的模块只能是单项依赖或则单先调用 。 全序的层次关系： 每一层中的同层模块之间不存在相互调用的关系。 优点： 整体问题局部化 各模块之间的组织架构和依赖关系清晰明了。 分层原则： 可适应性，方便于系统一直，可放在仅靠硬件的最底层。BIOS但硬件系统环境改变时只需要修改这一层模块就可以。 多种操作方式， 共同要使用的基本部分放在内层，而改变的部分放在外层。 微内核结构（C/S结构） 采用C/S结构的操作系统适宜于应用在网络环境下分布式处理的计算环境。 特点： 运行在核心态的内核：线程调度、虚拟内存、信息传递、设备驱动以及内核的原语操作集中中断处理等。 运行在用户态的并以C/S方式运行的进程层：除内核部分外，操作系统所有的其他部分被分成若干个相对独立的进程，每一个进程实现一组服务，称为服务进程。 这些服务进程可以提供各种系统功能、文件系统服务以及网络服务等。 好处： 可靠： 每一个分支是独立的，不会引起其他组成部分的损坏或崩溃。 灵活： 是自包含的，且接口规范，可维护性好。 分布式处理：具有分布式处理的能力。 缺点： 效率较低。 ","date":"2017-11-18","objectID":"/os-introduction/:2:12","tags":["os","system"],"title":"操作系统 概论","uri":"/os-introduction/"},{"categories":["tools"],"content":"安装 Sublime text3 软件 官方网址：https://www.sublimetext.com/3 选择Windows - also available as a portable version一项，点击下载安装。 ","date":"2017-11-12","objectID":"/sublime-text/:1:0","tags":["sublime","tools"],"title":"Sublime Text 崇高的文本编辑器","uri":"/sublime-text/"},{"categories":["tools"],"content":"安装 packagecontrol 插件 官方网址：https://packagecontrol.io/ 选择 Installation 项 选择 SUBLIME TEXT3 代码进行复制 打开 sublime text3 软件，选择 View-\u003eShow Console 选项（或者按 Ctrl+~组合键），调出命令行，将代码粘贴至命令行，回车，进行安装 packagecontrol 插件； 安装好之后在菜单栏Preferences栏目中会有packagecontrol选项，即安装成功。 ","date":"2017-11-12","objectID":"/sublime-text/:2:0","tags":["sublime","tools"],"title":"Sublime Text 崇高的文本编辑器","uri":"/sublime-text/"},{"categories":["tools"],"content":"安装汉化插件 ChineseLocalization 安装 sublime 汉化插件 ChineseLocalization 在弹出的框中，由于网速原因，请耐心等待…… 输入插件名称ChineseLocalization，回车[enter]进行安装 ","date":"2017-11-12","objectID":"/sublime-text/:3:0","tags":["sublime","tools"],"title":"Sublime Text 崇高的文本编辑器","uri":"/sublime-text/"},{"categories":["tools"],"content":"各类插件安装推荐 其他插件均和 ChineseLocalization 插件安装过程一样，在此不再重复操作，只推荐几款插件。 ","date":"2017-11-12","objectID":"/sublime-text/:4:0","tags":["sublime","tools"],"title":"Sublime Text 崇高的文本编辑器","uri":"/sublime-text/"},{"categories":["tools"],"content":"必备的插件安装 (初学者推荐安装) Emmet Emmet 的前身是大名鼎鼎的 Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿 CSS 选择器的语法来生成代码，大大提高了 HTML/CSS 代码编写的速度。 PySide PySide 是跨平台的应用程序框架 Qt 的 Python 绑定版本。 AutoFileName 一款在 Sublime Text 中可以自动补全文件路径及名称的插件。 DocBlockr DocBlockr 是一款 Sublime Text 2 \u0026 3 都可以使用的代码快注释插件。支持的语言有：JavaScript (including ES6), PHP, ActionScript, Haxe,CoffeeScript, TypeScript, Java, Groovy, Objective C, C, C++ and Rust. BracketHighlighter BracketHighlighter 是一款 Sublime 下匹配标签高亮的小插件，可以把匹配到的如 {}、()、”、””等对应的符号或者标签高亮显示。 Browser Refresh 通过一个快捷键可以实现保存文件，切换到浏览器并自动刷新浏览器来查看更改结果。 ConvertToUTF8 解决文档保存编码问题。 ColorPicker 一个多平台的颜色选择器插件。默认情况下，十六进制颜色代码使用大写字母插入。 ","date":"2017-11-12","objectID":"/sublime-text/:4:1","tags":["sublime","tools"],"title":"Sublime Text 崇高的文本编辑器","uri":"/sublime-text/"},{"categories":["tools"],"content":"进阶的程序猿推荐插件安装 a file icon 美化插件。可以更清楚了解每个文件的类型，一目了然。 git 版本控制仓库，推荐学习使用。 ","date":"2017-11-12","objectID":"/sublime-text/:4:2","tags":["sublime","tools"],"title":"Sublime Text 崇高的文本编辑器","uri":"/sublime-text/"}]