---
title: "操作系统 进程线程模型 线程模型"
date: 2017-12-10T22:57:38+08:00
keywords: "os,introduction"
comments: true
tags: ["os", "system"]
categories: ["OS"]
image: "https://webp.debuginn.com/202302221853276.jpg"
---

## 线程模型

**线程**：能够独立运行的基本单位，试图用它来提高系统内程序并发执行的程度。

### 线程的引入

**基本属性**：进程是一个可拥有资源的独立单位，又是一个可以独立调度和分派的基本单位。

1. 创建进程：必须为其分配所有资源（除CPU外），包括内存空间、I/O设备以及建立相应的数据结构PCB。 
2. 撤销进程：必须先对这些资源进行回收操作，然后在撤销PCB。 
3. 进程切换：由于要保留当前进程的CPU环境和设置新选中进程的CPU环境，为此需要花费不少的CPU时间。

进程是一个资源拥有者，因而在进程的创建、撤销和切换中，系统必须为之付出较大的时空开销。

创建背景：如果将作为调度和分派的经本单位不同时作为独立分配资源的单位，以使轻快运行；而对拥有资源的基本单位，又不频繁地对之进行切换。

### 线程的基本概念

线程是进程中的一个实体，是CPU调度和分派的基本单位。

一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。

线程也同样有就绪、等待和运行三种基本状态。

### 线程的属性

- 每一个线程有一个唯一的标识符和一张线程描述表，记录了线程执行的寄存器和栈等现场状态。 
- 不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时操作系统为它创建不同的线程。 
- 同一个进程中的各个线程共享进程的内存地址空间。 
- 线程是处理器的独立调度单位，多个线程是可以并发执行的，在单个CPU的计算机系统中，各个线程可交替的占用CPU；在多个CPU计算机系统中，各个线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各种线程服务是可以缩短进程的处理时间。 
- 一个线程被创建后便开始了它的生命周期，直至终止，县城在生命周期内会经历等待、就绪和运行等各种状态变化。

### 引入线程的好处

- 创建一个新的进程花费的时间少，不需另行分配资源，创建线程的速度比创建进程的速度快，且系统的开销也少。 
- 两个线程的切换花费时间少。 
- 由于同一个进程内的线程共享内存和文件，线程之间相互通信无须调用内核。 
- 线程能独立运行，能充分利用和发挥处理器与外围设备并行工作能力。

### 线程与进程的比较

线程具有许多传统进程所具有的特征，故又称为轻量级进程或者是进程元，把床听的进程称为重量级进程。

1. 调度：在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。而在引入县城的操作系统中，则把线程作为调度和分派的基本单位。同一进程中，线程切换不会引起进程切换；而在由一个进程中的线程切换到另一个进程中的线程时，将会引起进程切换。 
2. 并发性：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行。很有效的使用系统资源和提高系统的吞吐量。 
3. 拥有资源：线程的自己不拥有系统资源，但它可以访问其隶属进程的资源，可供同一进程的其他所有线程共享。 
4. 系统开销：由于在创建或撤销进程时，系统都要为之分配或回收资源。因此，操作系统所付出的开销将显著地大于在创建或撤销线程时的开销。

## 线程实现机制

### 用户级线程

用户级线程不依赖于内核。用户级线程只存在于用户态中，对它的创建、撤销和切换不会通过系统调用来实现，因而这种线程与内核无关。内核也并不知道有用户级线程的存在，从内核角度考虑，就是按正常的方式管理即单线程进程。

支持用户级进程的典型操作系统就是Linux。

在用户空间管理线程时，每个进程都需要有其专用的线程表。用来跟踪该进程中的线程。该线程表由运行时系统管理。但一个线程转换到就绪状态或阻塞状态时，在该进程表中存放着从新启动该线程所需要的信息，于内核在进程表中存放进程的信息完全一样。

### 内核级线程

内核级线程依赖于内核，无论是在用户进程中的线程，还是系统进程中的线程，他们的创建、撤销和切换都是有内核实现的。在内核中保留一个线程控制块，系统根据该控制块而感知该线程的存在并对县城进行控制。

支持内核级线程的典型操作系统是Windows。

内核的线程表保存了每个线程的仅存表、状态和其他信息。所以能够阻塞线程的表用都以系统调用的形式实现。当一个线程阻塞时，内核可以选择运行的同一个进程中的另一个线程（若有一个就绪进程）或者运行另一个进程中的线程。而在用户及线程中，运行时系统时钟运行自己进程中的线程，直到内核剥夺它的CPU（或者没有可运行的线程存在了）为止。

**用户级线程和内核级线程比较**

1. 线程的调度与切换速度：核心级线程的调度与切换与进程的调度和切换十分相似。在线程调度时的调度方式，同样也是采用抢占方式和非抢占方式两种。在线程的调度算法上，也同样可采用时间片轮转法、优先权算法等。用户级线程的切换通常是发生在一个应用进程的诸线程之间，这时，不仅无需同福哦终端进入操作系统的内核，而且切换的规则页远比进程调度和切换的规则简单。用户级线程的切换速度特别快。 
2. 系统调用：在传统的用户进程调用一个西戎调用时，要由用户状态转入核心状态，用户进程将被封锁。当那个完成系统调用而返回时，才将该进程唤醒，继续执行，而在用户级线程调用一个系统调用时，由于内核并不知道有该用户级进程的存在，因而把西戎调用看作是整个进程的行为，于是使该进程等待，而调度另一个进程执行。当一个进程调用一个系统调用时，内核把系统调用只看作是该线程的行为，以问封锁该进程中的其他线程执行。 
3. 线程执行时间：对于只设置了用户级线程的系统，调度是以进程为单位进行的。

### 混合实现方式

支持混合方式线程的典型操作系统是Solaris。

### Pthread线程包

IEEE标准1003.1c定义了线程标准，Pthread是基于该标准实现的线程包。

## 多道程序设计模型

作用：提高CPU的利用率。

### 程序的顺序执行

程序是一个在时间上按严格次序前后相继的操作序列，这些操作是机器指令或高级语言编写的语句。

#### 特点：

1. 顺序性：程序所规定的动作在机器上严格地按顺序执行。 
2. 封闭性：资源的状态（除了初始状态外）只有程序本身的动作才能改变。 
3. 确定性：程序执行结果与它的执行速度无关，也称为程序执行结果与时间无关性。即CPU在执行程序时，任意两个动作之间的停顿对程序的计算结果都不会产生影响。 
4. 可再现性：如果程序执行在不同的时间执行，只要输入的初始条件相同，则无论何时重复执行该程序都会得到相同的结果。

### 多道程序系统中程序执行环境的变化

#### 多道程序设计技术的引用

为了提高计算机系统中各种资源的利用效率，缩短作业的周转时间。多种硬件资源能并行工作。

- 单CPU：并发程序按给定的时间片交替的在处理机上执行，其执行的时间是重叠的。 
- 多CPU：这些并发程序在各自的处理机上运行。

例： 假设有两个程序A和B都要执行，A程序的执行顺序为在CPU中执行10s、在设备DEV1上执行5s、又在CPU上执行了5s、在设备DEV2上执行了10s、最后在CPU上执行了10s；

B程序的执行顺序为：在设备DEV2上执行10s、在CPU上执行10s、在设备DEV1上执行5s、又在CPU上执行了5s、最后在设备DEV2上执行10s。

在顺序环境下，A执行完之后B执行，或则B执行完之后A执行。假设A先执行，程序A、B全部执行完之后需要80s的时间，其中有40s是程序使用CPU，15S使用设备DEV1，25s使用设备DEV2.

![时间轴](https://webp.debuginn.com/202304142225543.png)

- CPU利用率=40/80=50% 
- DEV1利用率=15/80=18.75% 
- DEV2利用率=25/80=31.25%

在并发环境下，程序A、B可以同时执行，当程序A在CPU上执行时，程序B可以在设备DEV1上执行，程序A、B全部执行完成之后需要45s时间。

![时间轴](https://webp.debuginn.com/202304142226828.png)

- CPU利用率=40/45=89% 
- DEV1利用率=15/45=33% 
- DEV2利用率=25/45=56%

#### 多道程序设计环境的特点

多道程序设计就是允许多个程序同时进入内存并运行。

系统吞吐量衡量系统效率的尺度。吞吐量是指单位时间内系统所处理的作业（程序）的道数（数量）。

> 如果系统的资源利用率高，则单位时间内所完成的有效工作多，吞吐量大。 如果系统的资源利用率低，则单位时间内所完成的有效工作少，吞吐量小。

**作用：**提高了设备资源利用率，提高了内存资源利用率，提高了处理机资源利用率，最终，最终提高了系统吞吐量。

**多道程序设计环境的特点**

1. 独立性：每道程序都是在逻辑上独立的。 
2. 随机性：程序和数据的输入与执行开始时间都是随机的。 
3. 资源共享性：资源共享将导致对进程执行速度的制约。

### 程序的并发执行

程序的并发执行是指两个或两个以上的程序在计算机系统中同处与已开始执行的且尚未结束的状态。能够参与并发执行的程序称为并发程序。

#### 特性

1. 并发程序在执行期间具有相互制约关系：“执行-暂停-执行”。 
2. 程序与计算不再一一对应：允许多个用户作业调用一个共享程序段。 
3. 并发程序执行结果不再可现：宏观上是同时进行的，在单CPU系统中，他们仍是顺序执行。

## 进程模型

### 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配与调度的一个独立单位。

系统进程执行操作系统程序，完成操作系统的某些功能。

用户进程运行用户程序，直接为用户进行服务。

> 系统进程的优先级通常高于一般的用户进程的优先级。

#### 进程与程序的联系与区别

**联系：**

- 程序是构成进程的组成部分之一，一个进程的运行是执行它所对应的程序。 
- 进程是有程序，参数和进程控制块（PCB）部分组成。

**区别：**

- 程序是静态的，而进程是动态的。 
- 程序可以是永久的，而进程存在只是暂时的。 
- 一个进程可以执行一个或几个程序、一个程序可以构成多个进程。 
- 进程具有创建其他进程的功能，被创建的进程称为子程序，创建者称为父程序。

#### 进程的特性

1. 并发行：一个进程的第一个动作可以在另一个进程的最后一个动作结束之前开始。 
2. 动态性：进程动态产生、动态消亡，在进程生命周期内，其状态动态变化。 
3. 独立性：一个进程是一个相对完整的资源分配单位。 
4. 交往性：一个进程在运行过程中可能会与其他进程发生直接或间接的相互作用。 
5. 异步性：每个进程按照各自独自的、不可预知的速度向前推进。

### 进程的状态及其状态转换

#### 三状态进程模型

运行中的进程可以处于以下三种状态之一：**运行、就绪、等待**。

1. 运行状态Running：运行状态是指进程已经获得CPU，并且在CPU上执行的状态。 在一个单CPU系统中，最多只有一个进程处于运行状态。 
2. 就绪状态Ready：指一个进程已经具备运行条件，但由于没有获得CPU而不能运行所处的状态。一旦CPU分配给他，该程序就可以运行，处于就绪状态的进程可以是多个。 
3. 等待状态Waiting：也称阻塞状态或封锁状态，是指程序因等待某种事件发生而暂时不能运行的状态。

![三状态转换](https://webp.debuginn.com/202304142229706.png)

1. 就绪–》运行 未能获取处理机，故仍然不能运行。 
2. 运行–》就绪 由于规定的运行时间片用完而使系统发出超时中断请求，超时中断处理程序把该进程的状态修改为就绪状态。 
3. 运行–》等待 处于运行状态的进程是否能继续运行，除了受时间限制外，还收其他种种因素的影响。 
4. 等待–》就绪 等待的进程在其被柱塞的原因获得解除后，因为处理及满足不了进程的需要，于是将状态有等待变成就绪，仅当进程调度程序把处理机再次分配给他时，才可恢复现场继续运行。
   
#### 五状态进程模型

1. 运行状态 Running：进程占用处理机资源 出于此状态的进程的数目不小等于处理机的数目，再没有其他进程时可以执行是，通常会自动执行系统的空闲进程。 
2. 就绪状态 Ready：进程已获得除处理机外所需的资源，等待分配处理机资源，只要分配处理机就可以执行。 
3. 阻塞状态 Blocked：由于进程等待的I/O操作或进程同步等条件而暂停运行时处于阻塞状态。即使把处理机分配给该进程，也是无法继续执行的。 
4. 创建状态 New：进程正在创建的过程中，还不能运行。包括分配和创建进程控制块表项、建立资源表格并分配资源，机在程序并建立地址空间。 
5. 结束状态 Exit：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关的信息。

![五状态转换](https://webp.debuginn.com/202304142230821.png)

**操作系统中多个进程的并发执行是通过进程交替进入运行状态来实现的。**

1. 创建进程：创建一个新的进程，来运行一个程序。
2. 提交admit：完成一个新进程的创建过程，新进程进入就绪状态。
3. 调度运行dispatch：从就绪进程表中选择一个进程进入运行状态。
4. 释放release：由于进程完成或失败而终止进程运行，进入结束状态。 运行到结束的转换可分为正常退出和异常退出，其中异常退出是指进程执行超时、内存不够。
5. 超时timeout：由于运行的时间片或高优先级进程就绪状态等因素导致进程停止运行。
6. 事件等待event wait：进程要求的事件未出现而进入阻塞。 可能的原因包括申请进程系统服务或资源、通信、I/O等操作。
7. 事件出现event occurs：进程等待的事件出现，如操作完成，申请成功。

#### 七状态进程模型

五状态进程模型没有区分进程地址空间位于内存还是外存，**虚拟存储管理**技术后，需要进一步区分进程的地址空间状态。

**好处：**

1. 有空闲内存空间用于提交新进程。
2. 提供足够的内存。
3. 有利于调试：被挂起的调试程序，可方便对其他地址空间进行读写。

下面是列出在挂起的进程模型中的四种意义变化或新的状态。

1. 就绪状态：立即进入运行状态。
2. 阻塞状态：在内存并等待某事件的出现。
3. 阻塞挂起状态：进程在外存并等待某事件的出现。
4. 就绪挂起状态：进程在外存，但只要进入内存。


1. 挂起：把一个进程从内存转到外存。
  - 阻塞到阻塞挂起。
  - 就绪到就绪挂起：有高优先阻塞加入时。
  - 运行到就绪挂起。
2. 激活：把一个进程从内存转到外存。
  - 就绪挂起到就绪：就绪挂起进程优先级高于就绪进程。
  - 阻塞挂起到阻塞：当一个进程释放足够的内存时，系统会把一个高优先级阻塞挂起进程激活。
3. 事件出现：进程等待的事件出现。
  - 阻塞到就绪：内存进程的事件出现。
  - 阻塞挂起到就绪挂起：针对外存进程的事件出现。
4. 提交：完成一个新进程的创建过程，新进程进入就绪状态或就绪挂起状态。